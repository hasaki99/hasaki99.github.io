{"meta":{"title":"华紫樱绯","subtitle":"华紫樱绯","description":"记录无聊的生活","author":"Judge","url":"https://github.com/hasaki99/hasaki99.github.io","root":"/"},"pages":[{"title":"Medias","date":"2023-03-07T09:33:24.000Z","updated":"2023-03-07T09:33:29.453Z","comments":true,"path":"Medias/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/Medias/index.html","excerpt":"","text":""},{"title":"404","date":"2023-03-02T13:00:05.000Z","updated":"2023-03-02T13:00:27.204Z","comments":true,"path":"404/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-02T12:55:37.000Z","updated":"2023-03-02T13:56:33.672Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-03-02T12:57:24.000Z","updated":"2023-03-02T12:57:39.746Z","comments":true,"path":"about/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2023-03-02T12:57:56.000Z","updated":"2023-03-02T12:58:09.025Z","comments":true,"path":"contact/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-03-02T12:58:34.000Z","updated":"2023-03-02T12:58:50.448Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/friends/index.html","excerpt":"","text":""},{"title":"musics","date":"2023-03-07T09:27:13.000Z","updated":"2023-03-07T09:27:33.522Z","comments":true,"path":"musics/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/musics/index.html","excerpt":"","text":""},{"title":"2023","date":"2023-03-07T09:21:41.000Z","updated":"2023-03-07T09:46:53.439Z","comments":true,"path":"galleries/2023/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/galleries/2023/index.html","excerpt":"","text":""},{"title":"galleries","date":"2023-03-07T09:21:41.000Z","updated":"2023-03-07T09:21:51.044Z","comments":true,"path":"galleries/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/galleries/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-02T12:56:51.000Z","updated":"2023-03-02T12:57:11.500Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试之Java基础","slug":"面试之Java基础","date":"2023-03-08T02:44:14.000Z","updated":"2023-03-08T02:46:19.251Z","comments":true,"path":"2023/03/08/mian-shi-zhi-java-ji-chu/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/08/mian-shi-zhi-java-ji-chu/","excerpt":"","text":"*基础语法 **Q1：简单说说Java有哪些数据类型*答：①分为基本数据类型和引用数据类型。②基本数据类型包括：数值型（byte 1、short2、int4、long、float、double），字符型（char2）以及布尔型（boolean1）。除了基本类型外，其他数据类型都属于引用类型，包括类、接口、数组等。 面向对象 **面向对象就是**：把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同[类对象]抽象出其共性，形成类。类中的大多数数据，只能用本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。对象即为人对各种具体物体抽象后的一个概念，人们每天都要接触各种各样的对象，如手机就是一个对象。 *Q2：**float number=3.4;**有没有问题？为什么？*答：有问题，因为3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于向下转型，可能会造成精度损失，所以必须进行强制类型转换，正确的写法是float number =(float)3.4;/ float number =3.4F;。 *Q3：字符串拼接的方式以及效率？*答：①使用+直接拼接，String 是final对象，不会被修改，每次使用 +进行拼接都会创建新的对象，而不是改变原来的对象，效率低，是线程安全的。②使用StringBuffer可变字符串，效率较高，是线程安全的（StringBuffer的方法使用了synchronized关键字进行修饰）。③使用StringBuilder可变字符串，效率最高，但是线程不安全。 *Q4：简述final，finally和finalize区别*答：①final可以修饰类，方法和变量，被final修饰的类不可继承，被final修饰的方法不可重写，被final修饰的变量引用不可更改，引用的内容可以更改。②finally用于try-catch代码块中，无论是否发生异常最后都将执行，作用是释放资源。③finalize是Object类的方法，在对象被垃圾回收之前将调用一次，一般用于资源的释放。 *Q5：==和equals有什么区别？equals和hashCode有什么联系？*答：①如果是引用类型，==比较的是两个对象的引用是否完全相同，如果是基本类型，比较的是两个基本类型的数值是否相同。②如果没有重写的话，equals默认按照==进行比较，如果重写了equals()方法，则按照对应的比较规则比较。③两个对象如果相等，那么它们的hashCode值必须相等，但两个对象的hashCode值相等时，它们不一定相同。 *Q6：Array和ArrayList的区别？*答：①Array长度在定义之后就不运行改变了，而ArrayList是长度可变的，可以自动扩容。②Array只能存储相同类型的数据，ArrayList可以存储不同类型的数据。③ArrayList提供了更多操作数据的方法。 *Q7：&amp;和&amp;&amp;的区别？*答：①&amp;具有按位与和逻辑与两个功能。②&amp;&amp;作为逻辑与具有短路的特点，当前面的条件表达式为false时就不会进行后面条件表达式的判断，可以用来避免空指针异常。 *Q8：简述JDK8的新特性*答：①接口中可以添加default修饰的非抽象方法，可以有方法体和内容。②可以使用lambda表达式，减少代码冗余。③函数式接口，使用@FunctionalInterface注解标明，该接口有且仅有一个抽象方法。④方法引用，可以直接引用已有Java类或对象的方法或构造器，进一步简化lambda表达式。⑤stream流，用于解决已有集合/数组类库的弊端，简化其操作，有foreach遍历、filter过滤、map映射、concat合并等功能。⑥增加日期相关的API。 *Q9：Stream流了解吗？*答：①Stream流是JDK1.8的新特性，用于解决已有集合/数组类库的弊端，简化集合/数组的操作。②stream流的获取：集合：直接调用stream()方法获取；数组：使用静态方法Stream.of()/Arrays.stream()获取。③常用方法：forEach() 遍历；count() 统计个数；filter() 按条件过滤；limit() 取前面n个元素；skip() 跳过前面n个元素；map() 映射加工；concat() 合并stream流。④终结方法：foreach/count 调用终结方法后流不能继续使用；非终结方法：每次调用完返回一个新的stream对象，可以继续使用，支持链式编程。⑤收集stream流：把流转为Set集合 collect(Collections.toSet())；把流转为List集合 collect(Collections.toList())；把流转为Collection集合 collect(Collections.toCollection())；把流转为数组 toArray()。 *面向对象 10**Q1：简述面向对象的特性*答：①封装：建议成员变量私有，然后提供公有的getter/setter方法来获取值/赋值，封装的核心思想是合理隐藏，合理暴露，可以提高安全性，实现代码的组件化。②继承：一种子类到父类的关系，是“is a”关系，可以提高代码的复用性，相同代码可写到父类，子类的功能更加强大，不仅得到了父类的功能，还有自己的功能。③多态：同一个类型的对象执行相同的行为，在不同的状态下表现出不同的特征。多态可以降低类之间的耦合度，右边对象可以实现组件化切换，业务功能随之改变，便于扩展和维护。 *Q2：类和对象有什么区别？*答：类是一个抽象的概念，是具有相同特征的事物的描述，是对象的模板。对象是一个个具体的存在，是类的实例。 *Q3：列举Object类的方法*答：①equals(Object obj)：判断其他对象是否与当前对象相等。②toString()：打印当前对象的字符串表示。③wait()：导致当前线程等待，等待其他线程唤醒，会释放锁。④notify()/notifyAll()：随机唤醒一个/全部线程。⑤hashCode()：返回当前对象的hashCode值。⑥finalize()：当垃圾回收器要回收对象前调用。⑦clone()：创建并返回对象的一个副本。 *Q4：方法重载和方法重写的区别？*答：①方法重载是同一个类中具有不同参数列表的同名方法（无关返回值类型），方法重写是子类中具有和父类相同参数列表的同名方法，会覆盖父类原有的方法。②重载的返回值类型和权限修饰符，异常抛出类型没有要求，重写方法的返回值类型小于等于父类被重写方法的返回值类型，修饰符权限大于等于父类被重写方法权限修饰符，抛出的异常类型小于等于父类被重写方法抛出的异常类型。 *Q5：接口和抽象类有什么区别？*答：①接口中只能定义public static final修饰的常量，抽象类中可以定义普通变量。②接口和抽象类都不能实例化，但接口没有构造器，抽象类有构造器。③接口可以多实现，抽象类只能单继承。④接口在JDK1.8之前只能定义public abstract修饰的方法，JDK1.8开始可以定义默认方法和静态方法，JDK1.9开始可以定义私有方法，抽象类中的方法没有限制。 *Q6：什么时候应该使用接口，什么时候应该使用抽象类？*答：①如果知道某个类应该成为基类（在面向对象设计中，被定义为包含所有实体共性的class类型，被称为“基类”。），那么第一选择应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。②在接口和抽象类的选择上，必须遵守这样一个原则：行为模型应该总是通过接口而不是抽象类定义。通过抽象类建立行为模型会出现的问题：如果有一个抽象类Moblie，有两个继承它的类Mobile1和Moblie2，分别有自己的功能1和功能2，如果出现一个既有功能1又有功能2的新产品需求，由于Java不允许多继承就出现了问题，而如果是接口的话只需要同时实现两个接口即可。 *Q7：内部类有什么作用？有哪些分类？*答：①内部类有更好的封装性，有更多的权限修饰符，封装性可以得到更多的控制。②静态内部类：由static修饰，属于类本身，只加载一次。类可以定义的成分静态内部类都可以定义，可以访问外部类的静态变量和方法，通过new 外部类.静态内部类构造器来创建对象。③成员内部类：属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可以访问外部类的所有内容，通过new 外部类构造器.new 成员内部类构造器来创建对象。④局部内部类：定义在方法、构造器、代码块、循环中。只能定义实例成员变量和实例方法，作用范围仅在局部代码块中。⑤匿名内部类：没有名字的局部内部类，可以简化代码，匿名内部类会立即创建一个匿名内部类的对象返回，对象类型相当于当前new的类的子类类型。 *Q8：泛型和泛型擦除是什么？*答：①泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制允许程序在编译时检测非法的类型。②在编译阶段采用泛型时加上的类型参数，会被编译器在编译时去掉，这个过程就被称为类型擦除，因此泛型主要用于编译阶段，在编译后生成的Java字节代码文件中不包含泛型中的类型信息。 *Q9：泛型标记的规范了解吗？*答：①E：值Element，在集合中使用，表示在集合中存放的元素。②T：指Type，表示Java类，包括基本的类以及自定义类。③K：指Key，表示键，例如Map集合中的Key。④V：指Value，表示值，例如Map集合中的Value。⑤N：指Number，表示数值类型。⑥？：表示不确定的Java类型。 *Q10：泛型限定是什么？*答：①类型通配符使用？表示所有具体的参数类型，在使用泛型的时候，如果希望将类的继承关系加入泛型应用中就需要对泛型做限定，具体的泛型限定有对泛型上限的限定以及对泛型下限的限定。②对泛型上限的限定使用&lt;? extends T&gt;，它表示该通配符所代表的类型是T类的子类型或T接口的子接口。③对泛型下限的限定使用&lt;? super T&gt;，它表示该通配符所代表的类型是T类的父类型或T接口的父接口。 *异常 2**Q1：异常有哪些分类？出现的原因是什么？*答：①Throwable是所有错误和异常的父类，Throwable分为Error和Exception。②Error指Java程序运行错误，出现Error通常是因为系统的内部错误或资源耗尽，Error不能在运行过程中被动态处理，如果程序运行中出现Error，系统只能记录错误的原因和安全终止。③Exception指Java程序运行异常，即运行中发生了不期望的情况，分为RuntimeException和CheckedException。RuntimeException指在Java虚拟机正常运行期间抛出的异常，可以被捕获并处理，例如空指针异常，数组越界等。CheckedException指编译阶段强制要求捕获并处理的异常，例如IO异常，SQL异常等。 *Q2：有哪些异常处理方式？*答：①抛出异常：遇到异常不进行具体处理，而是将异常抛出给调用者，由调用者根据情况处理。抛出异常有2种形式，一种是throws，作用在方法上，一种是try……catch，作用在方法内。②使用try/catch进行异常的捕获处理，try中发生的异常会被catch代码块捕获，根据情况进行处理，如果有finally代码块无论是否发生异常都会执行，一般用于释放资源，JDK1.7开始可以将资源定义在try代码块中自动释放减少代码。 *集合 10**Q1：简述一下集合主要有哪些类和接口，各自有什么特点*答：①主要有两个接口Collection和Map，其中Collection又包括List、Set和Queue。②List是有序的，主要包括ArrayList，LinkedList和Vector，ArrayList底层通过数组实现，线程不安全，Vector是线程安全的ArrayList，但效率较低，LinkedList底层通过双向链表实现，与ArrayList相比增删快查询慢。③Set是唯一且无序的，主要包括HashSet，LinkedHashSet和TreeSet。HashSet底层其实就是HashMap，利用了key来保证元素的唯一性。LinkedHashSet可以按照key的操作顺序排序，TreeSet支持按照默认或指定的排序规则排序。④Queue是队列结构，主要有ArrayBlockingQueue基于数组的阻塞队列、LinkedBlockingQueue基于链表的阻塞队列等。⑤Map以key-value键值对的形式存储元素，主要包括HashMap、LinkedHashMap和TreeMap。HashMap底层通过数组+链表/红黑树实现，LinkedHashMap可以按照key的操作顺序对集合排序，TreeMap可以按照默认或指定的排序规则对集合排序。 *Q2：HashMap是线程安全的吗？*答：①HashMap是线程不安全的，可以使用ConcurrentHashMap保证线程安全。②ConcurrentHashMap基于减小锁粒度的思想，通过使用分段锁来实现线程安全，内部细分为很多Segment数据段，默认情况下为16个，对每个Segment的数据都单独进行加锁操作，Segment的个数为锁的并发度。ConcurrentHashMap是由Segment数组和HashEntry数组组成的，Segment继承了可重入锁，HashEntry用来存储键值对数据。③Segment的结构和HashMap类似，是数组和链表结构，每个Segment里面都包含一个HashEntry数组，每个HashEntry都是一个链表结构的数据要对其进行i修改必须先获得对应的Segment锁。④多线程下只要加入的数据hashCode映射的数据段不一样就可以做到并行的线程安全。 *Q3：List、Set、Map有什么区别？*答：①List是有序、可重复、有索引的集合，继承了Collection集合全部功能 除了Collection的三种遍历方式外，可用索引遍历。②Set是无序，不可重复的集合，Set的实现类LinkedHashSet和TreeSet是有序的，LinkedHashSet可以按照元素插入的顺序排序，也可以按照元素操作的时间排序，TreeSet可以按照默认的比较规则或者自定义的比较规则排序。③Map是无序、以key-value的键值对形式存储元素的集合，键不可重复，值无要求，重复的键对应的值会覆盖之前的值。 *Q4：HashSet是如何去重的？*答：①对于基本类型的包装类，可以直接按值进行比较。②对于引用数据类型，会先比较hashCode()返回值是否相同，如果不同则代表不是同一个对象，如果相同则继续比较equals()方法返回值是否相同，都相同说明是同一个对象。③如果希望内容相同的对象就代表对象相同，那么除了重写equals()方法还要重写hashCode()方法，因为内容相同的对象hashCode()值不一定相同，因为只有hashCode()和equals()都相同才说明是同一个对象。 *Q5：HashMap和HashSet的底层是怎么实现的？*答：①JDK1.8之前，HashMap的底层是数组加链表实现。数组中的每个元素都是一个单链表，链表中的每个元素都是Entry的实现类Node的一个实例，Node包括4个属性：key、value、hash值和用于指向单链表下一个元素的next。②HashMap在查找数据时，根据hash值可以快速定位到数组的具体下标，然后对链表进行遍历查找数据的时间复杂度为O(n)。JDK1.8起对HashMap进行了优化，底层改为数组+链表或红黑树，当链表中的元素超过8个之后，HashMap会将链表结构转换未红黑树以提高查询效率，时间复杂度为O(logn)。②HashSet的底层是基于HashMap实现的，HashSet中的元素只是存放在了底层HashMap的key上， 而value使用一个static final的Object对象标识。因此HashSet 的实现比较简单，相关操作基本上都是直接调用底层HashMap的相关方法来完成的。 *Q6：Collection和Collections有什么区别？*答：①Collection是一个集合接口，它包括List有序集合、Set无序集合、Queue队列等。②Collections则是Collection的一个工具类，为Collection类型的对象提供了很多方便的方法，例如addAll可以直接对Collection集合批量添加元素，shuffle可以随机打乱List集合的元素顺序，sort可以对List集合进行默认或按比较器进行排序。 *Q7：迭代器是什么？*答：①迭代器实现了Iterator接口，是用于遍历Collection集合元素的一个指针。②主要有三个方法：通过iterator()获得集合的迭代器；通过hasNext()判断集合当中是否还有元素，如果有返回true，没有则返回false，初始时迭代器位于第一个元素之前；通过next()获取集合的下一个元素，并向后移动一个元素的单位。 *Q8：在使用foreach循环遍历集合元素时能否添加或删除元素？*答：使用foreach循环遍历元素集合时不能修改或删除元素，通过java -c查看字节码可以发现foreach循环实际上是用Iterator迭代器实现的，如果进行添加或删除元素会抛出ConcurrentModificationException异常，因为添加或删除元素会改变modCount的值，modCount是集合类的一个成员变量，代表集合的修改次数，当modCount的值和预期的exceptedModCount值不一致时就会抛出ConcurrentModificationException异常。 *Q9：Queue接口中的add()/offer()、remove()/poll()、element()/peek()方法有什么区别?*答：①add()和offer()都是向队列尾部插入一个元素，区别是当超出队列界限时，add方法会抛出异常，而offer()会返回false。②remove()和poll()都是从队列头部移除一个元素并返回，区别是队列为空时remove()方法会抛出异常，poll()方法则是返回null值。③element()和 peek() 都是用于查询队列头部的元素，区别时队列为空时， element() 抛出一个异常，而 peek() 返回 null。 *Q10：有哪些线程安全的集合类？*答：①Vector，是线程安全的ArrayList，底层用数组实现，通过synchronized修饰方法保证线程安全。②HashTable，是线程安全的HashMap，继承自Dictionary，通过synchronized修饰方法保证线程安全，性能较差。③ConcurentHashMap，线程安全的HashMap，通过分段锁实现线程安全，性能较好。 *多线程 34**Q1：创建线程有哪几种实现方式?分别有什么优缺点？*答：①继承Thread类，重写run()方法即可。优点是编码简单，缺点是不能继承其他类，功能单一。②实现Runnable接口，重写run()方法，并将该实现类作为参数传入Thread构造器。优点是可以继承其他类，避免了单继承的局限性；适合多个相同程序代码的线程共享一个资源（同一个线程任务对象可被包装成多个线程对象），实现解耦操作，代码和线程独立。缺点是实现相对复杂。③实现Callable接口，重写call()方法，并包装成FutureTask对象，再作为参数传入Thread构造器。优点是相比方式二可以获取返回值，缺点是实现复杂。④可以通过线程池创建。 *Q2：线程有哪些状态？*答：①New：用new操作创建一个新线程，此时程序还未开始运行线程中的代码。②Runnable：调用start()方法后进入可运行状态。③Blocked：阻塞状态，内部锁（不是juc中的锁）获取失败时进入阻塞状态。④Waiting：等待其他线程唤醒时进入等待状态。⑤Timed Waiting：计时等待，带超时参数的方法，例如sleep(long time)。⑥Terminated：终止状态，线程正常运行完毕或被未捕获异常终止。 *Q3：什么是线程安全问题，如何解决？*答：当多个线程对同一个共享变量进行操作时可能会产生的问题。解决方法：①使用内部锁synchronized，可以使用同步代码块，如果是实例方法可用this作为锁对象，如果是静态方法，可以用类.class作为锁，或者使用同步方法底层和同步代码块一样，如果是实例方法默认用this作为锁，如果是静态方法默认使用类.class。②使用java.util.concurrent包中的锁，例如ReentrantLock。 *Q4：多线程不可见问题的原因和解决方式？*答：①不可见的原因是每个线程有自己的工作内存，线程都是从主内存拷贝共享变量的副本值。每个线程都是在自己的工作内存操作共享变量的。②解决方式：加锁：获得锁后线程会清空工作内存，从主内存拷贝共享变量最新的值成为副本，修改后刷新回主内存，再释放锁；使用volatile关键字：被volatile修饰的变量会通知其他线程之前读取到的值已失效，线程会加载最新值到自己的工作内存。 *Q5：说一说volatile关键字的作用*答：①保证被修饰的变量对所有线程可见，在一个线程修改了变量的值后，新的值对于其他线程是可以立即获取的。②禁止指令重排序，被修饰的变量不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取volatile修饰的变量时总是会返回最新写入的值。③不会执行加锁操作，不会导致线程阻塞，主要适用于一个变量被多个线程共享，多个线程均可对这个变量执行赋值或读取的操作。④volatile可以严格保证变量的单次读写操作的原子性，但并不能保证像i++这种操作的原子性，因为i++在本质上是读、写两次操作。 *Q6：说一说synchronized关键字的作用*答：①用于为Java对象、方法、代码块提供线程安全的操作，属于排它的悲观锁，也属于可重入锁。②被synchronized修饰的方法和代码块在同一时刻只能有一个线程访问，其他线程只有等待当前线程释放锁资源后才能访问。③Java中的每个对象都有一个monitor监视器对象，加锁就是在竞争monitor，对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的，对方是否加锁是通过一个标记位来判断的。 *Q7：synchronized的内部都包括哪些区域？*答：synchronized内部包括6个不同的区域，每个区域的数据都代表锁的不同状态。①ContentionList：锁竞争队列，所有请求锁的线程都被放在竞争队列中。②EntryList：竞争候选列表，在锁竞争队列中有资格成为候选者来竞争锁资源的线程被移动到候选列表中。③WaitSet：等待集合，调用wait方法后阻塞的线程将被放在WaitSet。④OnDeck：竞争候选者，在同一时刻最多只有一个线程在竞争锁资源，该线程的状态被称为OnDeck。⑤Owner：竞争到锁资源的线程状态。⑥!Owner：释放锁后的状态。 *Q8：简述synchronized的实现原理*答：①收到新的锁请求时首先自旋，如果通过自旋也没有获取锁资源，被放入ContentionList（该做法对于已经进入队列的线程是不公平的，体现了synchronized的不公平性）。②为了防止ContentionList尾部的元素被大量线程进行CAS访问影响性能，Owner线程会在是释放锁时将ContentionList的部分线程移动到EntryList并指定某个线程（一般是最先进入的）为OnDeck线程。Owner并没有将锁直接传递给OnDeck线程而是把锁竞争的权利交给他，该行为叫做竞争切换，牺牲了公平性但提高了性能。③获取到锁的OnDeck线程会变为Owner线程，未获取到的仍停留在EntryList中。④Owner线程在被wait阻塞后会进入WaitSet，直到某个时刻被唤醒再次进入EntryList。⑤ContentionList、EntryList、WaitSet中的线程均为阻塞状态。⑥当Owner线程执行完毕后会释放锁资源并变为!Owner状态。 *Q9：JDK对synchronized做了哪些优化？*答：JDK1.6中引入了适应自旋、锁消除、锁粗化、轻量级锁以及偏向锁等以提高锁的效率。锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，这种过程叫做锁膨胀。JDK1.6中默认开启了偏向锁和轻量级锁，可以通过-XX:UseBiasedLocking禁用偏向锁。 *Q10：volatile和synchronized的区别？*答：①volatile只能修饰实例变量和类变量,而synchronized可以修饰方法以及代码块。②volatile只能保证数据的可见性，但是不保证原子性，synchronized是一种排它机制，可以保证原子性。只有在特殊情况下才适合取代synchronized：对变量的写操作不依赖于当前值（例如i++），或者是单纯的变量赋值；该变量没有被包含在具有其他变量的不等式中，不同的volatile变量不能互相依赖，只有在状态真正独立于程序内的其它内容时才能使用volatile。③volatile是一种轻量级的同步机制，在访问volatile修饰的变量时并不会执行加锁操作，线程不会阻塞，使用synchronized加锁会阻塞线程。 *Q11：讲一讲ReentrantLock*答：①ReentrantLock是Lock接口的实现类，是一个可重入式的独占锁，通过AQS实现。②支持公平锁与非公平锁，还提供了可响应中断锁（线程在等待锁的过程中可以根据需要取消对锁的请求，通过interrupt方法中断）、可轮询锁（通过tryLock获取锁，如果有可用锁返回true否则立即返回false）、定时锁（通过带long时间参数的tryLock方法获取锁，如果在给定时间内获取到可用锁且当前线程未被中断返回true，如果超过指定时间则返回false，如果获取锁时被终断则抛出异常并清除已终止状态）等避免死锁的方法。③通过lock和unlock方法显式地加锁和释放锁。 *Q12：synchronized和ReentrantLock有哪些区别？*答：①synchronized是隐式锁，ReentrantLock是显式锁，使用时必须在finally代码块中进行释放锁的操作。②synchronized是非公平锁，ReentrantLock可以实现公平锁。③ReentrantLock可响应中断，可轮回，为处理锁提高了更多灵活性。④synchronized是一个关键字，是JVM级别，ReentrantLock是一个接口，是API级别。⑤synchronized采用悲观并发策略，ReentrantLock采用的是乐观并发策略，会先尝试以CAS方式获取锁。 *Q13：Lock接口有哪些方法？*答：①lock()：给对象加锁。②tryLock()/tryLock(long time,TimeUnit unit)：尝试给对象加锁，成功返回true，可以无参也可以指定等待时间。③unlock()：释放锁，锁只能由持有者释放否则抛出异常。④newCondition()：创建条件对象，使用条件对象管理那些已经获得锁但不满足有效条件的线程，调用await()方法把线程进入等待集，调用sign()/signAll()解除阻塞。⑤lockInterruptibly()：如果当前线程未被中断则获取该锁。 *Q14：Java中的锁有什么作用？有哪些分类？*答：①Java中的锁主要用于保障多并发情况下数据的一致性，线程必须先获取锁才能进行操作，可以保证数据的安全。②从乐观和悲观的角度可以分为乐观锁和悲观锁。③从获取资源的公平性可以分为公平锁和非公平锁。④从是否共享资源的角度可以分为共享锁和排它锁。⑤从锁的状态角度可分为偏向锁、轻量级锁和重量级锁。同时在JVM中还设计了自旋锁以更快地使用CPU资源。 *Q15：讲一讲乐观锁和悲观锁*答：①乐观锁采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁。但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法，具体过程为：比较当前版本号与上一次的版本号，如果一致则更新，否则重复进行读、比较、写操作。Java中的乐观锁是基于CAS操作实现的，CAS是一种原子性操作，在对数据更新之前先比较当前值和传入的值是否一样，一样则更新否则直接返回失败状态。②悲观锁采用悲观的思想处理数据，每次读取数据时都认为别人会修改数据，所以每次都会上锁，其他线程将被阻塞。Java中的悲观锁基于AQS实现，该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到则会转为悲观锁。 *Q16：讲一讲自旋锁*答：①自旋锁认为如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等待小段时间，在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核态的切换上导致锁时间消耗。②优点：减少CPU的上下文切换，对于占用锁时间非常短或锁竞争不激烈的代码块来说性能很高。③缺点：在持有锁的线程长时间占用锁或竞争过于激烈时，线程会长时间自旋浪费CPU资源，有复杂锁依赖的情况不适合使用自旋锁。 *Q17：讲一讲公平锁与非公平锁*答：①公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先将锁分配给排队时间最长的线程。②非公平锁指在分配锁时不考虑线程排队等待的情况，直接尝试获取锁，获取不到锁就在排到队尾等待。③因为公平锁需要在多核情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。synchronized是非公平锁，ReentrantLock默认的lock方法也是非公平锁。 *Q18：讲一讲读写锁*答：①Lock接口提供的锁是普通锁，为了提高性能Java提供了读写锁，读写锁分为读锁和写锁，读锁之间不互斥，读锁与写锁，写锁之间都互斥。②如果系统要求共享数据可以同时支持很多线程并发读，但不能支持很多线程并发写，那么读锁能大大提高效率。如果系统要求共享数据在同一时刻只能有一个线程在写，且写的过程中不能读，则需要使用写锁。③提高juc的locks包中ReadWriteLock的实现类ReentrantReadWriteLock的readLock()和writeLock()来分别获取读锁和写锁。 *Q19：讲一讲共享锁与排它锁*答：①共享锁：允许多个线程同时获取该锁，并发访问共享资源，ReentrantReadWriteLock的读锁为共享锁的实现。②排它锁：也叫互斥锁 ，每次只允许有一个线程独占该锁，ReentrantLock为排它锁的实现。③排它锁是一种悲观的加锁策略，同一时刻只允许一个线程读取锁资源，限制了读操作的并发性，因为并发读线程并不会影响数据的一致性，因此共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。 *Q20：锁有哪些状态？*答：①无锁，偏向锁，轻量级锁和重量级锁。②重量级锁是基于操作系统互斥量实现的，会导致进程在用户态和内核态之间来回切换，开销较大，synchronized内部基于监视器实现，监视器基于底层操作系统实现，因此属于重量级锁，运行效率不高。JDK1.6后为了减少获取锁和释放锁带来的性能消耗提高性能，引入了轻量级锁和偏向锁。③轻量级锁是相对于重量级锁而言的，核心设计实在没有多线程竞争的前提下，减少重量级锁的使用来提高性能。适用于线程交替执行同步代码块的情况，如果同一时刻有多线程访问同一个锁，会导致轻量级锁膨胀成重量级锁。④偏向锁用于在某个线程获取某个锁后，消除这个线程锁重入的开销，看起来似乎是这个线程得到了锁的偏袒。偏向锁的主要目的是在同一个线程多次获取某个所的情况下尽量减少轻量级锁的执行路径，因为轻量级锁需要多次CAS操作，而偏向锁只需要切换ThreadID时执行一次CAS操作，提高效率。出现多线程竞争锁时，JVM会自动撤销偏向锁。偏向锁是进一步提高轻量级锁性能的。⑤随着锁竞争越来越严重，锁可能从偏向锁升级到轻量级锁再到重量级锁，但在Java中只会单向升级不会降级。 *Q21：如何进行锁优化？*答：①减少锁持有的时间：只在有线程安全要求的程序上加锁来尽量减少同步代码块对锁的持有时间。②减小锁粒度：将单个耗时较多的锁操作拆分为多个耗时较少的锁操作来增加锁的并行度，减少同一个锁上的竞争。在减少锁的竞争后，偏向锁、轻量级锁的使用率才会提高，例如ConcurrentHashMap中的分段锁。③读分离：指根据不同的应用场景将锁的功能进行分离以应对不同的变化，最常见的锁分离思想就是读写锁，这样既保证了线程安全又提高了性能。④锁粗化：指为了保障性能，会要求尽可能将锁的操作细化以减少线程持有锁的时间，但如果锁分的太细反而会影响性能提升，这种情况下建议将关联性强的锁操作集中处理。⑤锁消除：注意代码规范，消除不必要的锁来提高性能。 *Q22：线程池是什么？为什么需要线程池？*答：①在生产中为每一个任务创建一个线程存在一些缺陷，如果无限制地大量创建线程会消耗很多资源，影响系统稳定性和性能，产生内存溢出等问题。②线程池是管理一组同构工作线程的资源池，线程池与工作队列密切相关，工作队列中保存了所有需要等待执行的任务。工作线程的任务很简单，从工作队列获取任务，执行任务，返回线程池并等待下一次任务。③线程池通过重用现有的线程，可以在处理多个请求时分摊线程在创建和撤销过程中的开销，另一个好处是当请求到达时工作线程通常已经存在，不会出现等待线程而延迟的任务的执行，提高了响应性。通过调整线程池的大小，可以创建足够多的线程保持处理器处于忙碌状态，同时还可以防止线程过多导致内存资源耗尽。 *Q23：创建线程池时，ThreadPoolExecutor构造器中都有哪些参数，有什么含义？*答：①corePoolSize： 线程池核心大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。②maximumPoolSize： 线程池最大大小，表示可同时活动的线程数量的上限。③keepAliveTime：存活时间，如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过基本大小时，这个线程将被终止。④unit： 存活时间的单位，可选的参数为TimeUnit枚举中的几个静态变量： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。⑤workQueue： 线程池所使用的阻塞队列。⑥thread factory：线程池使用的创建线程工厂方法，可省略，将使用默认工厂。⑦handler：所用的拒绝执行处理策略，可省略，将使用默认拒绝执行策略。 *Q24：线程池的阻塞队列有哪些选择？*答：①ArrayBlockingQueue：基于数组的有界阻塞队列。②LinkedBlockingQueue：基于链表的有界阻塞队列。③PriorityBlockingQueue：支持优先级排序的无界阻塞队列。④DelayedWorkQueue：基于优先级队列的无界阻塞队列。⑤SynchronousQueue：队列内部仅允许容纳一个元素，用于控制互斥的阻塞队列。 *Q25：线程池的拒绝执行策略有哪些选择?*答：①AbortPolicy()： 线程池默认的拒绝策略，抛出RejectedExecutionException异常。②CallerRunsPolicy(): 重试添加当前的任务，他会自动重复调用execute()方法。③DiscardOldestPolicy(): 抛弃旧的任务，加入新的任务。④DiscardPolicy(): 直接抛弃当前的任务。 *Q26：创建线程池的方法有哪些？*答：可以通过Executors的静态工厂方法创建线程池，内部通过重载ThreadExecutorPool不同的构造器创建线程池。①newFixedThreadPool，创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化(如果某个线程由于发生了未预期的异常而结束，那么线程池会补充一个新的线程)。将线程池的核心大小和最大大小都设置为参数中指定的值，创建的线程不会超时，使用LinkedBlockingQueue。②newCachedThreadPool，创建一个可缓存的线程池，如果线程池的当前规模超过了处理器需求，那么将回收空闲的线程，而当需求增加时，可以添加新的线程，线程池的规模不存在任何限制。将线程池的最大大小设置为Integer.MAX_VALUE，而将核心大小设置为0，并将超时设为1分钟，使用SynchronousQueue，这种方法创建出的线程池可被无限扩展，并当需求降低时自动收缩。③newSingleThreadExecutor，一个单线程的Executor，创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来代替。确保依照任务在队列中的顺序来串行执行。将核心线程和最大线程数都设置为1，使用LinkedBlockingQueue。④newScheduledThreadPool，创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer，使用DelayedWorkQueue。 *Q27：线程池的工作原理？*答：①线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。即使队列里面有任务，线程池也不会马上执行它们。②通过 execute(Runnable command)方法被添加到线程池，任务就是一个 Runnable类型的对象，任务的执行方法就是Runnable类型对象的run()方法。③如果workerCount&lt;corePoolSize，那么创建并启动一个线程执行新提交的任务。如果workerCount&gt;=corePoolSize，且线程池内的阻塞队列未满，那么将这个任务放入队列。如果workerCount&gt;=corePoolSize，且阻塞队列已满，若满足workerCount&lt;maximumPoolSize,那么还是要创建并启动一个线程执行新提交的任务。若阻塞队列已满，并且workerCount&gt;=maximumPoolSize，则根据 handler所指定的策略来处理此任务，默认的处理方式直接抛出异常。也就是处理任务的优先级为： 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。④当一个线程完成任务时，它会从队列中取下一个任务来执行。⑤当一个线程没有任务可执行，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize时，那么这个线程会被停用掉，所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。 *Q28：简述ExecutorService的生命周期*答：①ExecutorService的生命周期有3种状态：运行、关闭和已终止。②ExecutorService在初始创建时处于运行状态。③shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。在ExecutorService关闭后提交的任务将有“拒绝执行处理器REH”来处理，它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。④等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已终止。通常在调用awaitTermination后会理解调用shutdown，从而产生同步地关闭ExecutorService的效果。 *Q29：什么是CAS？*答：①CAS指Compare And Swap，比较并交换。CAS(V,E,N)算法包括三个参数，V表示要更新的变量的值，E表示预期的值，N表示新值。在且仅在V的值和E相等时才会将V的值设置为N，如果不同则说明已经有其他线程做了更改，当前线程就什么也不做。最后CAS返回当前V的真实值。②CAS操作采用了乐观锁的思想，有多个线程同时使用CAS操作一个共享变量时只有一个线程会成功，失败的线程不会被挂起仅会被告知失败，并且允许再次尝试，或者放弃操作。基于这样的原理虽然CAS没有使用锁，也可以及时发现其他线程的操作进行适当地并发处理。 *Q30：CAS有什么问题？（什么是ABA问题？）如何解决？*答：①CAS算法地实现有一个重要前提：需要取出内存中某时刻的数据，然后在下一刻进行比较、替换，但在这个时间差内数据可能已经发生了变化，导致ABA问题。②ABA问题指线程1从内存V位置取出A，这时线程2也从内存中取出A，并将其首先修改为B，接着又修改为A，这时线程1在进行CAS操作时会发现内存中数据仍是A，然后线程1操作成功。尽管从操作角度来说线程1成功了，但是在该过程中实际上数据已发生了变化但并未被感知到，某些应用场景下可能会出现数据不一致的问题。③乐观锁通过版本号来解决ABA问题，具体的操作是每次执行数据修改操作时都会带上一个版本号，如果预期版本号和数据版本号一致就进行操作，并将版本号加1，否则执行失败。 *Q31：讲一讲wait、sleep、yield、join方法的区别*答：①wait是Object类的方法，调用wait方法的线程会进入WAITING状态，只有等待其他线程的通知或被中断后才会解除阻塞，调用wait方法会释放锁资源。②sleep是Thread类的方法，调用sleep方法会导致当前线程进入休眠状态，与wait不同的是该方法不会释放锁资源，进入的是TIMED-WAITING状态。③yiled方法会使当前线程让出CPU时间片给优先级相同或更高的线程，回到RUNNABLE状态，与其他线程一起重新竞争CPU时间片。④join方法用于等待其他线程运行终止，如果当前线程调用了另一个线程的join方法，则当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就绪态，等待获取CPU时间片。底层使用的是wait，也会释放锁。 *Q32：讲一讲线程中断*答：①interrupt方法用于向线程发送一个终止信号，会影响该线程内部的中断标识位，这个线程本身不会因为调用了interrupt方法而改变状态，状态的具体变化需要等待接收到中断标识的程序的处理结果判定。②调用interrupt方法不会中断一个正在运行的线程，只会改变内部的中断标识位的值为true。③当调用sleep方法使线程处于TIMED-WAITING状态使，调用interrupt方法会抛出InterruptedException，使线程提前结束TIMED-WAITING状态。在抛出该异常前将清除中断标识位，所以在抛出异常后调用isInterrupted方法返回的值是false。④中断状态是线程固有的一个标识位，可以通过此标识位安全终止线程。比如想终止某个线程时，先调用interrupt方法然后在run方法中根据该线程isInterrupted方法的返回值安全终止线程。 *Q33：什么是守护线程？*答：①守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。守护线程不依赖于终端，但是依赖于JVM，当JVM中仅剩下守护线程时，JVM就会退出。②通过setDaemon方法定义一个守护线程，守护线程的优先级较低，将一个用户线程设置为守护线程必须要在启动守护线程之前。 *Q34：start和run方法的区别？*答：①start方法用于启动线程，真正实现了多线程，调用了start方法后，会在后台创建一个新的线程来执行，不需要等待run方法执行完毕就可以继续执行其他代码。调用start方法时，该线程处于就绪状态，并没有开始运行。②run方法也叫做线程体，包含了要执行的线程的逻辑代码，在调用run方法并没有创建新的线程，而是直接运行run方法中的代码。 *JVM 15**Q1：类的加载机制是什么?*答：类加载到内存中主要有5个阶段，分别为①加载：将Class文件读取到运行时数据区的方法区内，在堆中创建Class对象，并封装类在方法区的数据结构的过程。②验证：主要用于确保Class文件符合当前虚拟机的要求，保障虚拟机自身的安全，只有通过验证的Class文件才能被JVM加载。③准备：主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值。④解析：将常量池中的符号引用替换为直接引用。⑤初始化：主要通过执行类构造器的方法为类进行初始化，该方法是在编译阶段由编译器自动收集类中静态语句块和变量的赋值操作组成的。JVM规定，只有在父类的方法都执行成功后，子类的方法才可以被执行。在一个类中既没有静态变量赋值操作也没有静态语句块时，编译器不会为该类生成方法。 *Q2：有哪些类加载器，类加载器的加载模型是什么，有什么好处？*答：①主要有启动类加载器，负责加载JAVA_HOME/lib中的类库；扩展类加载器，负责加载JAVA_HOME/lib/ext中的类库；应用程序类加载器，也称系统类加载器，负责加载用户类路径上指定的类库；也可以自定义类加载器。②类加载器之间的层次关系叫做双亲委派模型，要求除了顶层的启动类加载器外其余的类加载器都应当有自己的父类加载器。一个类收到类加载请求后会层层找父类加载器去尝试加载，因此所有的加载请求最终都会被传送到顶层的启动类加载器，只有当父类加载器反馈自己无法完成加载时子加载器才会尝试自己去加载。③双亲委派模型的好处是保障类加载的唯一性和安全性，例如加载rt.jar包中的java.lang.Object，无论哪一个类加载最终都会委托给启动类加载器，这样就保证了类加载的唯一性。如果存在包名和类名都相同的两个类，那么该类就无法被加载。 *Q3：简述JVM的内存区域*答：JVM的内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（堆、方法区）和直接内存。①程序计数器是一块很小的内存空间，用于存储当前线程执行字节码文件的行号指示器。②虚拟机栈是描述Java方法执行过程的内存模型，帧栈中存储了局部变量表，操作数栈，动态链接，方法出口等信息。③本地方法栈，和虚拟机栈作用类似，区别是虚拟机栈为Java方法服务，本地方法栈为Native方法服务。④JVM运行过程中创建的对象和生成的数据都存储在堆中，堆是被线程共享的内存区域，也是垃圾回收最主要的内存区域。⑤方法区用来存储常量，静态变量、类信息、即时编译器编译后的机器码、运行时常量池等数据。 *Q4：哪些情况下类不会初始化？*答：①常量在编译时会存放在使用该常量的类的常量池，该过程不要调用常量所在的类，不会初始化。②子类引用父类的静态变量时，子类不会初始化，只有父类会初始化。③定义对象数组，不会触发该类的初始化。④在使用类名获取Class对象时不会触发类的初始化。⑤在使用Class.forName()加载指定的类时，可以通过initialize参数设置是否需要初始化。⑥在使用ClassLoader默认的loadClass方法加载类时不会触发该类的初始化。 *Q5：哪些情况下类会初始化？*答：①创建类的实例。②访问某个类或接口的静态变量，或对该静态变量赋值。③调用类的静态方法。④初始化一个类的子类时（初始化子类，父类必须先初始化）。⑤JVM启动时被标为启动类的类。⑥使用反射进行方法调用时。 *Q6：谈谈JVM的运行时内存*答：JVM的运行时内存也叫做JVM堆，从GC角度更将其分为新生代，老年代和永久代。其中新生代默认占1/3堆空间，老年代默认占2/3堆空间，永久代占非常少的堆空间。新生代又分为Eden区、ServivorFrom区和ServivorTo区，Eden区默认占8/10新生代空间，ServivorFrom区和ServivorTo区默认分别占1/10新生代空间。 *Q7：谈谈新生代是怎么分区的*答：①JVM新创建的对象（除了大对象外）会被存放在新生代，默认占1/3堆内存空间。由于JVM会频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。②新生代又分为Eden区，ServivorFrom区和ServivorTo区。③Eden区：Java新创建的对象首先会被存放在Eden区，如果新创建的对象属于大对象，则直接将其分配到老年代。大对象的定义和具体的JVM版本、堆大小和垃圾回收策略有关，一般为2KB~128KB，可通过-XX:PretenureSizeThreshold设置其大小。在Eden区的内存空间不足时会触发MinorGC，对新生代进行一次垃圾回收。②ServivorTo区：保留上一次MinorGC时的幸存者。③ServivorFrom区：将上一次MinorGC时的幸存者作为这一次MinorGC的被扫描者。 *Q8：谈谈新生代的垃圾回收机制*答：新生代的GC过程叫做MinorGC，采用复制算法实现，具体过程如下：①把在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区，如果某对象的年龄达到老年代的标准，则将其复制到老年代，同时把这些对象的年龄加1。如果ServivorTo区的内存空间不够，则也直接将其复制到老年代。如果对象属于大对象，则也直接复制到老年代。②清空Eden区和ServivorFrom区中的对象。③将ServivorFrom区和ServivorTo区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。 *Q9：谈谈老年代的垃圾回收机制*答：①老年代主要存放有长生命周期的对象和大对象，老年代的GC叫MajorGC。②在老年代，对象比较稳定，MajorGC不会频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，过后仍然出现老年代空间不足或无法找到足够大的连续内存空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。③MajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。因为要先扫描老年代的所有对象再回收，所以MajorGC的时间较长。容易产生内存碎片，在老年代没有内存空间可分配时，会出现内存溢出异常。 *Q10：谈一谈永久代*答：①永久代指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在类加载时被放入永久代。②永久代和老年代、新生代不同，GC不会在程序运行期间对永久代的内存进行清理，这也导致了永久代的内存会随着加载的Class文件的增加而增加，在加载的Class文件过多时会出现内存溢出异常，比如Tomcat引用jar文件过多导致JVM内存不足而无法启动。③在JDK1.8中，永久代已经被元数据区取代。元数据区的作用和永久代类似，二者最大的区别在于：元数据区并没有使用虚拟机的内存，而是直接使用操作系统的本地内存。因此元空间的大小不受JVM内存的限制，只和操作系统的内存有关。④在JDK1.8中，JVM将类的元数据放入本地内存中，将常量池和类的静态常量放入Java堆中，这样JVM能够加载多少元数据信息就不再由JVM的最大可用内存空间决定，而由操作系统的实际可用内存空间决定。 *Q11：如何确定对象是否是垃圾？*答：①Java采用****引用计数法*和*可达性分析****来确定对象是否应该被回收。引用计数法容易产生循环引用的问题，可达性分析通过根搜索算法实现。根搜索算法以一系列GC Roots的点作为起点向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡。根搜索算法主要针对栈中的引用、方法区的静态引用和JNI中的引用展开分析。②引用计数法：在Java中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为对象添加一个引用时，引用计数加1；在为对象删除一个引用时，引用计数减1；如果一个对象的引用计数为0，则表示此刻该对象没有被引用，可以被回收。引用计数法容易产生循环引用问题，循环引用指两个对象相互引用，导致它们的引用一直存在，而不能被回收。③可达性分析：为了解决引用计数法的循环引用问题，Java还采用了可达性分析来判断对象是否可以被回收。具体做法是首先定义一些GC Roots对象，然后以这些GC Roots对象作为起点向下搜索，如果在GC Roots和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象要经过至少两次标记才能判断其是否可被回收，如果两次标记后该对象仍然不可达，则将被垃圾回收器回收。 *Q12：有哪些GC算法？分别有什么特点？*答：①标记清除算法：标记出所有需要回收的对象，然后清除可回收的对象。效率较低，并且因为在清除后没有重新整理可用的内存空间，如果内存中可被回收的小对象居多，会引起内存碎片化问题。②复制算法：将可用内存分为区域1和区域2，将新生成的对象放在区域1，在区域1满后对区域1进行一次标记，将标记后仍然存活的对象复制到区域2，然后清除区域1。效率较高并且易于实现，解决了内存碎片化的问题，缺点是浪费了大量内存，同时在系统中存在长生命周期对象时会在两区域间来回复制影响系统效率。③标记清除算法：结合了标记清除算法和复制算法的优点，标记过程和标记清除算法一样，标记后将存活的对象移动到一端，清理另一端。④分代收集算法：根据对象不同类型把内存划分为不同区域，把堆划分为新生代和老年代。由于新生代的对象生命周期较短，主要采用复制算法。将新生代划分为一块较大的Eden区和两块较小的Survivor区，Servivor区又分为ServivorTo和ServivorFrom区。JVM在运行过程中主要使用Eden和SurvivorFrom区，进行垃圾回收时将这个两个区域存活的对象复制到SurvivorTo区并清除这两个区域。老年代主要存储长生命周期的大对象，因此采用标记清除或标记整理算法。 *Q13：有哪些垃圾回收器？各自有什么特点?*答：①Serial：单线程，基于复制算法，JVM运行在Client时默认的新生代垃圾收集器。②ParNew：Serial的多线程实现，基于复制算法，JVM运行在Server时默认 的新生代垃圾收集器。③Paraller Scavenge：多线程，基于复制算法，以吞吐量最大化为目标，允许较长时间的STW换取吞吐量。④Serial Old：单线程，基于标记整理算法，是JVM运行在Client模式下默认的老年代垃圾回收器，可和Serial搭配使用。⑤Parall Old：多线程，基于标记整理算法，优先考虑系统的吞吐量。⑥CMS：多线程，基于标记清除算法，为老年代设计，追求最短停顿时间。主要有四个步骤：初始标记、并发标记、重新标记、并发清除。⑥G1：将堆内存分为几个大小固定的独立区域，在后台维护了一个优先列表，根据允许的收集时间回收垃圾收集价值最大的区域。相比CMS不会产生内存碎片，并且可精确控制停顿时间。分为四个阶段：初始标记、并发标记、最终标记、筛选回收。 *Q14：Java中有哪些引用类型？*答：①强引用，最常见的引用类型，把一个对象指向一个引用变量时就是强引用。强引用的对象一定为可达性状态，所以不会被垃圾回收，是内存泄漏的主要原因。②软引用，通过SoftReference实现，如果一个对象只有软引用，当内存空间不足时将被回收。③弱引用，通过WeakReference实现，如果一个对象只有弱引用，在垃圾回收过程中一定会被回收。④虚引用，通过PhantomReference实现，虚引用和引用队列联合使用，主要用来跟踪对象的垃圾回收过程。 *Q15：JVM有哪些内存回收与回收策略？*答：①对象优先在Eden区分配：大多数情况下对象在新生代Eden区分配，当Eden区没有足够空间时，虚拟机将发起一次MinorGC。②大对象直接进入老年代：大对象是指需要大量连续内存空间的Java对象，如很长的字符串及数组。虚拟机提供了一个参数-XX:PretenureSizeThreshold，大于该值的对象会直接进入老年代，防止它在新生代之间来回复制。③长期存活的对象进入老年代：虚拟机给每个对象定义了一个年龄计数器，若对象在Eden区出生、经过第一次MinorGC后仍存活且能被Survivor容纳，将被移到Survivor区并且对象年龄设为1。每经过一次MinorGC，年龄就加1。默认在年龄增加到15时晋升到老年代，可通过-XX:MaxTenuringThreshold设置晋升老年代的年龄阈值。④动态对象年龄判定：如果在Survivor空间中相同年龄所有对象大小超过了该空间的一半，大于等于该年龄的对象就可以直接进入老年代而不用等到达到阈值。⑤空间分配担保：发生MinorGC前，先判断老年代最大可用连续空间是否大于新生代所有对象的总空间，如果成立那么MinorGC是安全的。如果不成立会查看HandlePromotionFailure是否允许担保，如果允许会冒险进行MinorGC，否则改为一次FullGC。 *反射与注解 3**Q1：简述反射的基本概念，优缺点和使用场景。*答：①在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java的反射机制。② 优点是运行时动态获取类的全部信息，缺点是破坏了类的封装性，泛型的约束性。③是框架的核心灵魂，动态代理设计模式采用了反射机制，还有 Spring、Hibernate 等框架也大量使用到了反射机制。 *Q2：获取Class对象有哪几种方式？能通过Class对象获取类的哪些信息？*答：①通过类名.class②通过对象.getClass()③通过Class.forName(类的全限名);④可以通过Class对象获取类的成员变量，方法或构造器。带declared的获取方法可以获取到类的一个或全部成员变量，方法，构造器，不带declared的方法只能获取到类的public修饰的成员变量、方法或构造器，包括父类public修饰的成员变量、方法或构造器。 *Q3：注解是什么，元注解是什么，有什么作用？*答：①注解是一种标记，可以使类或接口附加额外的信息，是帮助编译器和JVM完成一些特定功能的。②元注解就是自定义注解的注解，包括@Target：用来约束注解的位置，值是ElementType枚举类，包括METHOD方法、VARIABLE变量、TYPE类/接口、PARAMETER方法参数、CONSTRUCTORS构造器和LOACL_VARIABLE局部变量；@Rentention：用来约束注解的生命周期，值是RetentionPolicy枚举类，包括：SOURCE源码、CLASS字节码和RUNTIME运行时；@Documented：表明这个注解应该被javadoc工具记录；@Inherited：表面某个被标注的类型是被继承的。 *IO流 5**Q1：简单说说File对象表示的是什么？File类有哪些常用方法?*答：①File对象表示的是操作系统上的文件或目录。②获取：getAbsolutePath() 获取绝对路径；getPath() 获取文件定义时使用的路径；getName() 获取文件名，带后缀；length() 返回文件长度，单位是字节。③判断：exists() 判断File对象表示的文件或目录是否存在；isDirectory() 判断是否是目录； isFile() 判断是否是文件。④创建和删除：createNewFile() 不存在时创建新文件；delete() 删除文件，目录（非空目录不能删除）；mkdir() 创建一级目录；mkdirs() 创建多级目录，推荐使用；⑤遍历：list 获取当前目录下所有一级文件名称到一个字符串数组并返回；listFiles 获取当前目录下所有一级File对象到File数组返回。 *Q2：英文、数字和中文字符在文件中分别占多大的空间？*答：①英文和数字在任何编码中都占1个字节。②中文字符在GBK编码下占2个字节，在UTF-8编码下占3个字节。 *Q3：简述传统IO有哪些分类？*答：①按流的方向：输出流：把内存中的数据写出到磁盘文件或网络介质中；输入流：把磁盘文件或网络介质中的数据读取到内存中。②按流的内容：字节流：流中数据的最小单位是字节；字符流：流中数据的最小单位是字符（针对文本内容）。顶层的抽象类包括InputStream、OutputStream、Reader、Writer，它们都实现了Closeable接口。③缓冲流（BufferedInputStream/BufferedOutputStream/BufferedReader/BufferedWriter）：自带一个8KB大小的缓冲池，可以将字节/字符流为缓冲字节/缓冲字符流。④字符转换流（InputStreamReader/OutputStreamWriter）：可以将对应的字节流转换为字符流。⑤打印流：PrintStream，方便快速打印数据，参数是什么就打印什么。 *Q4：简述BIO、NIO、AIO的区别和原理*答：①BIO是同步阻塞的，数据的读写会阻塞在一个线程中，适用于连接数目比较小且固定的架构，对服务器资源要求高，JDK1.4前的唯一选择。②NIO是同步非阻塞的，通过Selector监听Channel上事件的变化，在Channel上有数据发生变化时通知该线程进行读写操作。适用于连接数目比较多且连接比较短的架构，如聊天服务器，从 JDK1.4开始支持。③AIO是异步非阻塞的，异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情。适用于连接数目比较多且连接比较长的架构，从JDK1.7开始支持。 *Q5：序列化和反序列化是什么，有什么要求？*答：①Java在JVM运行时被创建、更新和消耗，当JVM退出时，对象也会随之销毁。可以通过Java序列化实现持久化存储，保存对象及其状态信息到字节数组中。②反序列化就是再将字节数组中存储的信息转换回Java对象。③要求类必须实现序列化接口，并且序列化和反序列化必须保持序列化的ID一致。④静态变量和被transient修饰的变量不会被序列化。 *JavaWeb 19**Q1：HTTP有哪些特点*答：①HTTP是基于TCP/IP协议的。②HTTP使用的默认端口号是80。③HTTP是基于请求/响应模型的，一次请求对应一次响应。④HTTP是无状态的，每次请求之间相互独立，不能交互数据。⑤HTTP1.0每一次请求响应都会建立新的连接，HTTP1.1会复用连接。 *Q2：HTTP请求数据的数据格式是什么？*答：①请求行，包括了请求方式、请求url、请求协议/版本。HTTP协议有7种请求方式，常用的有2种。GET方式，请求参数在请求行中，在url后、 请求的url长度有限制的、不太安全；POST方式，请求参数在请求体中、请求的url长度没有限制的、相对安全。②请求头，是客户端浏览器告诉服务器的一些信息，常见的请求头例如User-Agent，告诉服务器使用的浏览器版本信息，可以在服务器端获取该头的信息，解决浏览器的兼容性问题。Referer，可以告诉服务器，当前请求从哪里来，可以防盗链或者进行统计数据。③请求空行，用于分割POST请求的请求头和请求体的。④请求体(正文)，封装POST请求消息的请求参数的。 *Q3：转发和重定向的区别？*答：①转发的特点： 转发地址栏路径不变、 转发只能访问当前服务器下的资源、转发是一次请求，可以使用request对象来共享数据。②重定向的特点：地址栏发生变化、重定向可以访问其他站点(服务器)的资源、重定向是两次请求，不能使用request对象来共享数据。 *Q4：讲一讲Cookie*答：①Cookie是客户端会话技术，将数据保存到客户端。②创建Cookie对象，绑定数据：new Cookie(String name, String value)；发送Cookie对象：response.addCookie(Cookie cookie)，一次可以发送多个Cookie；获取Cookie，拿到数据：request.getCookies()。③浏览器对于单个cookie 的大小有限制(4kb) 以及对同一个域名下的总cookie数量也有限制(20个)，cookie一般用于存出少量的不太敏感的数据，在不登录的情况下，完成服务器对客户端的身份识别。 *Q5：Cookie的生命周期？*答：①默认情况下，当浏览器关闭后，Cookie数据被销毁。②如果想要持久化存储，可以使用setMaxAge(int seconds)。正数：将Cookie数据写到硬盘的文件中，持久化存储，并指定cookie存活时间，时间到后，cookie文件自动失效。负数：默认值。零：删除cookie信息。 *Q6：Cookie可以存储中文数据吗？*答：①在tomcat 8 之前cookie中不能直接存储中文数据，需要将中文数据转码—一般采用URL编码(%E3)。②在tomcat 8 之后，cookie支持中文数据，特殊字符还是不支持，建议使用URL编码存储，URL解码解析。 *Q7：Cookie的共享范围是什么？*答：①假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie默认情况下不能共享。通过setPath(String path)设置cookie的获取范围，默认情况下，设置为当前的虚拟目录，如果要共享，则可以将path设置为/。②不同的tomcat服务器间cookie共享问题：通过setDomain(String path)设置一级域名，如果一级域名相同，那么多个服务器之间cookie可以共享。例如setDomain(“.baidu.com”)，那么tieba.baidu.com和news.baidu.com中cookie可以共享。 *Q8：讲一讲Session*答：①Session是服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。②获取HttpSession对象：request.getSession()；使用HttpSession对象：Object getAttribute(String name)、void setAttribute(String name, Object value)、void removeAttribute(String name)。③Session的实现是依赖于Cookie的，服务器是通过cookie中的JESSIONID判断session是否是同一个的。 *Q9：Session的生命周期？当客户端关闭后，服务器不关闭，两次获取session是否为同一个？客户端不关闭，服务器关闭后，两次获取的session是同一个吗？*答：①服务器关闭、session对象调用invalidate() 时销毁，session默认失效时间 30分钟。②在默认情况下，当客户端关闭服务端不关闭时，两次获取session值不是同一个。③如果需要相同，则可以创建Cookie，键为JSESSIONID，设置最大存活时间，让cookie持久化保存。④客户端不关闭，服务端关闭，两次获取的session值也不是同一个。但是要确保数据不丢失。tomcat自动完成以下工作。session的钝化： 在服务器正常关闭之前，将session对象序列化到硬盘上。session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。但是IDEA不支持这种操作，因为每次用IDEA重启tomcat时会自动删除catalina_base中work目录（程序动态生成的文件），这样在关闭tomcat时生成的session序列化文件也会被删除。 *Q10：Session的特点，和Cookie有什么区别？*答：①Session用于存储一次会话的多次请求的数据，存在服务器端。session可以存储任意类型，任意大小的数据。②Session存储数据在服务器端，Cookie存储数据在客户端。Session没有存储数据的大小限制，Cookie有数据大小限制。Session存储数据是安全的，使用Cookie存储数据相对于使用Session来说不安全。 *Q11：EL是什么？*答：①EL指Expression Language 表达式语言。②EL表达式的作用是替换和简化jsp页面中java代码的编写。③EL表达式的语法是：${表达式}。④JSP默认支持EL表达式，如果要忽略EL表达式，设置JSP中page指令中的isELIgnored=”true”忽略当前jsp页面中所有的el表达式，也可以通过${表达式} 忽略当前这个EL表达式。 *Q12：JSTL是什么？*答：①JSTL指JavaServer Pages Tag Library JSP标准标签库，是由Apache组织提供的开源的免费的JSP标签。②JSTL的作用是简化和替换jsp页面上的Java代码。③使用时首先需要导入JSTL相关jar包，并引入标签库： &lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core“ %&gt;。 *Q13：JSP定义Java代码有哪些方式？*答：①&lt;% 代码 %&gt;是JSP页面中Java代码片段的容器，将页面转换为servlet类时，会将内容插入到servlet类的jspService()方法中，同时从JSP生成servlet。②&lt;%! 代码 %&gt;用于为JSP页面声明全局的方法和变量。在JSP文件中，必须先声明这些变量和方法然后才能使用它们。在页面转换中，声明的方法和变量成为JSP页面的servlet类中的类成员声明。语法③&lt;%= 代码 %&gt;用于将转换为String的Java表达式的值插入到返回给客户端的响应中。 *Q14：JSP的内置对象有哪些？*答：①pageContext，真实类型是PageContext，可以在当前页面共享数据，还可以获取其他八个内置对象。②page，真实类型是Object，指当前页面(Servlet)的对象this。③request，真实类型是HttpServletRequest，封装客户端的请求。④response，真实类型是HttpServletResponse，封装服务端对客户端的响应。⑤session，真实类型是HttpSession，封装会话数据信息。⑥out，真实类型是JspWriter，字符输出流对象，可以将数据输出到页面上，和response.getWriter()类似。response.getWriter()和out的区别：在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。response.getWriter().write()数据输出永远在out.write()之前。⑦config，真实类型是ServletConfig，是Servlet的配置对象。⑧exception，真实类型是Throwable，封装页面抛出异常的对象。⑨application，真实类型是ServletContext，封装服务器运行环境的对象。 *Q15：过滤器是什么？如何使用？*答：①当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。②需要实现Filter接口，使用注解方式可以在类名上加上注解@WebFilter(“拦截路径”)，使用XML的方式可以配置web.xml中的filter和filter-mapping标签，设置过滤器类和拦截路径。 *Q16：过滤器的执行流程和生命周期是什么？*答：①执行流程：执行过滤器，执行放行后的资源，回来执行过滤器放行代码下边的代码。②生命周期：init：在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次，一般用于加载资源。doFilter：在每一次请求被拦截资源时执行，会执行多次。destroy：在服务器关闭后，Filter对象被销毁，如果服务器是正常关闭，则会执行destroy方法。只执行一次。一般用于释放资源。 *Q17：过滤器拦截路径都有哪些方式？*答：①具体资源路径：，例如/index.jsp ，只有访问index.jsp资源时，过滤器才会被执行。②拦截目录：例如/user/，当访问/user下的所有资源时，过滤器都会被执行。③通过后缀名拦截：例如.jsp， 当访问所有后缀名为jsp资源时，过滤器都会被执行。④拦截所有资源：使用/*，访问所有资源时过滤器都会执行。 *Q18：AJAX是什么？*答：①Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。②通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。③传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面，使用Ajax技术可以提升用户的体验。 *Q19：JSON是什么？如何把Java对象转为JSON？如何把JSON转回Java对象？*答：①JSON指JavaScript Object Notation JavaScript对象表示法。②JSON现在多用于存储和交换文本信息的语法，进行数据的传输。③JSON的优势是想比XML来说占用空间更小、操作数据更快，更易解析。④将Java对象转为JSON时，需要先导入jackson的相关jar包，创建Jackson核心对象 ObjectMapper，之后调用ObjectMapper的writeValue(参数，obj)进行转换，如果参数是File类型，可以将obj对象转换为JSON字符串，并保存到指定的文件中；如果参数是Writer类型，可以将obj对象转换为JSON字符串，并将json数据填充到字符输出流中；如果参数是OutputStream类型，可以将obj对象转换为JSON字符串，并将JSON数据填充到字节输出流中。⑤将JSON转会Java对象时使用readValue的方法，参数为要转回的Java对象的Class字节码对象。 *JavaEE 29**Spring 7**Q1：Spring的IOC和DI是什么？*答：①IOC即控制反转，简单来说就是把对象的控制权委托给spring框架，作用是降低代码的耦合度。②DI即依赖注入，是IOC的一种具体实现方式。假设一个Car类需要Engine的对象，那么一般需要new一个Engine，利用IOC就是只需要定义一个私有的Engine引用变量，容器会在运行时创建一个Engine的实例对象并将引用自动注入给变量。 *Q2：简述Spring中bean对象的生命周期*答：①Spring对bean进行实例化。②Spring将值和bean的引用注入到其对应的属性中。③调用BeanNameAware的setBeanName方法。④调用BeanFactoryAware的setBeanFactory方法。⑤调用AppicationContxtAware的setApplicationContext方法。⑥调用BeanPostProcessor的post-ProcessBeforeInitialization方法。⑦调用InitializingBean的after-PropertiesSet方法。如果bean使用init-method声明了自定义初始化方法，该方法也会被调用。⑧调用BeanPostProcessor的post-ProcessAfterInitialization方法。⑨使用bean。⑩调用DisposableBean的destroy方法，如果bean使用destroy-method声明了自定义销毁方法，该方法也会被调用。 *Q3：简述bean的作用范围*答：通过scope指定bean的作用范围，有①singleton：单例的，每次容器返回的对象是同一个。②prototype :多例的，每次返回的对象是新创建的实例。③request：仅作用于HttpRequest，每次Http请求都会创建一个新的bean。④session：仅作用于HttpSession，不同的Session使用不同的实例，相同的Session使用同一个实例。⑤global session ：仅作用于HttpSession，所有的Session使用同一个实例。 *Q4：BeanFactory和FactoryBean，ApplicationContext的区别？*答：①BeanFactory是一个Factory接口，是用来管理bean的IOC容器或对象工厂，较为古老，不支持spring的一些插件。BeanFactory使用了延迟加载，适合多例模式。②FactoryBean是一个Bean接口，是一个可以生产或者装饰对象的工厂Bean，可以通过实现该接口自定义的实例化Bean的逻辑。③ApplicationConext是BeanFactory的子接口，扩展了其功能，ApplicationContext是立即加载，适合单例模式。一般推荐使用ApplicationContext。 *Q5：使用XML配置有哪些创建Bean对象的方式？*答：①通过默认无参构造器。使用bean标签，只使用id和class属性，如果没有无参构造器会报错。②使用静态工厂，通过bean标签中的class指明静态工厂，factory-method指明静态工厂方法。③使用实例工厂，通过bean标签中的factory-bean指明实例工厂，factory-method指明实例工厂方法。 *Q6：依赖注入可以注入哪些数据类型？有哪些注入方式？*答：①可以注入的数据类型有基本数据类型、String、Bean、以及集合等复杂数据类型。②有三种注入方式，第一种是通过****构造器*注入，通过constructor-arg（）标签实现，缺点是即使不需要该属性也必须注入；第二种是通过*Set方法*注入，通过property标签实现，优点是创建对象时没有明确限制，缺点是某个成员变量必须有值，在获取对象时set方法可能还没有执行；第三种是通过*注解****注入，利用@Autowired自动按类型注入，如果有多个匹配则按照指定bean的id查找，查找不到会报错；@Qualifier在自动按照类型注入的基础之上，再按照 Bean 的 id 注入，给成员变量注入时必须搭配@Autowired，给方法注入时可单独使用；@Resource直接按照 Bean 的 id 注入；@Value用于注入基本数据类型和String。 *Q7：有哪些配置Bean的注解，各有什么区别？*答：①@Component，把当前类对象存入spring容器中，相当于在 xml 中配置一个 bean。value属性指定 bean 的 id，如果不指定 value 属性，默认 id 是当前类的类名，首字母小写。②@Service，一般用于业务层。③@Controller：一般用于表现层。④@Repository：一般用于持久层。⑤@Controller @Service @Repository都是针对@Component的衍生注解，作用及属性都是一模一样的，只是提供了更加明确的语义化。 *Spring Aop 4**Q1：Spring Aop的基本原理是什么？*答：Aop即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理的技术，在不修改源码的基础上对方法进行增强。优点是可以减少代码的冗余，提高开发效率，维护方便。Spring会根据类是否实现了接口来判断动态代理的方式，如果实现了接口会使用JDK的动态代理，核心是InvocationHandler接口和Proxy类，如果没有实现接口会使用cglib的动态代理，cglib是在运行时动态生成某个类的子类，如果某一个类被标记为final，是不能使用cglib动态代理的。 *Q2：简单解释一下AOP的相关术语*答：①*Joinpoint(连接点)*:指那些被拦截到的点，在 spring 中这些点指的是方法，因为 spring 只支持方法类型的连接点。例如业务层实现类中的方法都是连接点。②*Pointcut(切入点)*:指我们要对哪些 Joinpoint 进行拦截的定义。例如业务层实现类中被增强的方法都是切入点，切入点一定是连接点，但连接点不一定是切入点。③*Advice(通知/增强)*:指拦截到 Joinpoint 之后所要做的事情。④*Introduction(引介)*:引介是一种特殊的通知，在不修改类代码的前提下可以在运行期为类动态地添加一些方法或 Field。⑤*Weaving(织入)*:是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。⑥*Proxy（代理）*:一个类被 AOP 织入增强后，就产生一个结果代理类。⑦*Target(目标)*:代理的目标对象。⑧*Aspect(切面)*:是切入点和通知（引介）的结合。 *Q3：Spring Aop有哪些相关注解？*答：@Before前置通知，@AfterThrowing异常通知，@AfterReturning后置通知，@After最终通知，@Around环绕通知。最终通知会在后置通知之前执行，为解决此问题一般使用环绕通知。 *Q4：如何使用XML方式配置AOP？*答：①aop:config用于声明开始 aop 的配置。②aop:aspect用于配置切面。属性：id给切面提供一个唯一标识。ref引用配置好的通知类 bean 的 id。③aop:pointcut用于配置切入点表达式，就是指定对哪些类的哪些方法进行增强。属性：expression用于定义切入点表达式，id用于给切入点表达式提供一个唯一标识。④aop:before用于配置前置通知，在切入点方法执行之前执行；aop:after-returning用于配置后置通知，在切入点方法正常执行之后执行，它和异常通知只能有一个执行；aop:after-throwing用于配置异常通知，在切入点方法执行产生异常后执行；aop:after用于配置最终通知，无论切入点方法执行时是否有异常，它都会在其后面执行。 *Spring MVC 15**Q1：SpringMVC的作用是什么？MVC的含义分别是什么？*答：①springMVC是一种基于Java实现的mvc设计模型的请求驱动类型的轻量级Web层框架，作用包括：参数绑定（获取请求参数）、调用业务层 、进行请求响应。②mvc全名是model view controller模型视图控制器，model指数据模型，JavaBean的类，用来封装数据；view指jsp，html等用来展示数据给用户的界面；controller是整个流程的控制器，用来接收用户请求以及进行数据校验等功能。 *Q2：要搭建一个最基础的SpringMVC环境，你是如何配置的？*答：①在pom.xml中导入以下jar包：org.springframework下的spring-context）、spring-web、spring-webmvc、javax.servlet下的servlet-api、javax.servlet.jsp下的jsp-api以及测试用的junit包。②创建一个springmvc.xml的springconfig配置文件，开启包扫描，注册视图解析器，配置视图的前缀和后缀。③在web.xml中配置核心控制器，servlet和servlet-mapping的映射等。 *Q3：SpringMVC的基础响应流程是怎样的？*答：①浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去（控制器类），转发的路径是根据请求 URL，匹配@RequestMapping 中的内容②根据执行方法的返回值和视图解析器（InternalResourceViewResolver），去指定的目录下查找指定名称的视图文件，Tomcat服务器渲染页面，做出响应。 *Q4：SpringMVC响应流程中会涉及到哪些组件？*答：①DispatcherServlet：前端控制器，用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。②HandlerMapping：处理器映射器，负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。③Handler：处理器，它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。④HandlAdapter：处理器适配器，通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行⑤View Resolver：视图解析器，负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。⑥View：视图，SpringMVC 提供了很多 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 *Q5：讲一讲@RequestMapping注解*答：①作用：建立请求url和处理方法之间的对应关系。②作用位置：类，请求url的第一级访问目录，如果不写相当于根目录，需要以/开头；方法，请求url的第二级访问目录，可以不以/开头。③属性：value/path，绑定路径，支持多个路径，一般只配置一个路径；method 指定访问方式，可配置多个允许的访问方式，默认任何方法都支持，例如POST、GET等。 *Q6：SpringMVC的参数绑定支持哪些类型，分别有哪些要求？*答：①基本数据类型和String，要求请求参数的参数名必须和控制器中方法的形参名一致，例如请求参数为name，控制器方法的形参也必须为name。②可以是Java对象，要求请求属性必须和对应的Java类中的成员变量名一致，例如input标签的name属性值为id，类中也必须有id这一个成员变量。也可以是Java对象中的List或Map集合。 *Q7：如何解决请求参数中文乱码问题？*答：在web.xml中配置一个过滤器，配置一个filter标签，使用org.springframework.web.filter包下的CharacterEncodingFilter类实现，将中的设置为encoding，对应的设置为UTF-8即可。然后配置对应的fiter-mapping标签，fiter-name和之前的一样，设置为/*，表示对所有视图都进行编码过滤。 *Q8：SpringMVC支持哪些Servlet对象作为控制器方法的参数？*答：一共有9个，包括①HttpServletRequest，指客户端的请求。②HttpServletResponse，指服务器端的响应。③HttpSession，Java平台对session机制的实现规范。④Principal，此接口表示主体的抽象概念，它可以用来表示任何实体，例如，个人、公司或登录id。⑤Locale，用于国际化操作的类。⑥InputStream，字节输入流。⑦OutputStream，字节输出流。⑧Reader，字符输入流。⑨Writer，字符输出流。 *Q9：SpringMVC的常用注解有哪些？*答：①@RequestParam：作用是将请求参数和控制器中方法形参绑定(请求参数名和形参名不再要求相同)。属性包括：name/value，当和请求参数名一致可省略；required指定请求参数是否必填项；defaultValue是未提供请求参数时的默认值。②@RequestBody：作用是用于获取请求体的内容，直接使用得到的是key=value形式的字符串，把获取的json数据转换成pojo对象(get方式不可用)。③@RequestBody：作用是将控制器中方法返回的对象通过适当的转换器转换为指定的格式之后进行响应，通常用来返回JSON数据或者是XML。④@PathVariable：作用是绑定url中的占位符，例如请求url中/delete/{id}，{id}就是url占位符。url支持占位符是spring3.0后加入的，是springmvc支持rest风格url的一个重要标志。属性包括name/value 指定url中占位符名称；required指定是否必须提供占位符。⑤@RequestHeader：作用是获取指定请求头的值。属性：value代表请求头的名称。⑥@CookieValue：作用是用于把指定 cookie 名称的值传入控制器方法参数。属性包括value：指定 cookie 的名称。required：是否必须有此 cookie。⑦@ModelAttribute：是 SpringMVC4.3 版本以后加入的，它可以修饰方法和参数，出现在方法上表示当前方法会在控制器的方法执行之前先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。出现在参数上，获取指定的数据给参数赋值。属性value用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。 *Q10：响应数据的格式有哪些？*答：①字符串，控制器中的方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址，例如返回”success”时可解析为success.jsp页面。②返回值为空，默认访问视图解析器前缀+requestmapping路径+视图解析器后缀的视图。③ModelandView，可以通过setViewName()方法设置视图名实现指定视图的跳转。 *Q11：SpringMVC中如何实现转发和重定向，有什么区别？*答：①前提是控制器方法返回值类型必须是String类型。②转发到页面return”forward:+绝对地址”。转发到控制器其他方法：return的是”forward:+类上requestmapping的地址+方法上requestmapping的地址”。③重定向到页面：return的是”redirect:+绝对地址”，注意不能重定向访问WEB-INF下的资源。重定向到控制器其他方法：return的是”redirect:+类上requestmapping的地址+方法上requestmapping的地址”。重定向到外部链接：return的是”redirect:+链接地址(","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Java/"}]},{"title":"MyBatis核心组件面试题","slug":"MyBatis核心组件面试题","date":"2023-03-03T06:25:17.000Z","updated":"2023-03-03T06:26:58.089Z","comments":true,"path":"2023/03/03/mybatis-he-xin-zu-jian-mian-shi-ti/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/03/mybatis-he-xin-zu-jian-mian-shi-ti/","excerpt":"","text":"MyBatis 核心组件 + 面试题[toc] MyBatis&nbsp;介绍MyBatis 是一款优秀的 ORM（Object Relational Mapping，对象关系映射）框架，它可以通过对象和数据库之间的映射，将程序中的对象自动存储到数据库中。它是 Apache 提供的一个开源项目，之前的名字叫做 iBatis，2010 年迁移到了 Google Code，并且将名字改为我们现在所熟知的 MyBatis，又于 2013 年 11 月迁移到了 Github。 MyBatis 提供了普通 SQL 查询、事务、存储过程等功能，它的优缺点如下。 优点： 相比于 JDBC 需要编写的代码更少 使用灵活，支持动态 SQL 提供映射标签，支持对象与数据库的字段关系映射 缺点： SQL 语句依赖于数据库，数据库移植性差 SQL 语句编写工作量大，尤其在表、字段比较多的情况下 总体来说，MyBatis 是一个非常优秀和灵活的数据持久化框架，适用于需求多变的互联网项目，也是当前主流的 ORM 框架。 MyBatis&nbsp;重要组件MyBatis&nbsp;中的重要组件如下： Mapper 配置：用于组织具体的查询业务和映射数据库的字段关系，可以使用 XML 格式或 Java 注解格式来实现； Mapper 接口：数据操作接口也就是通常说的 DAO 接口，要和 Mapper 配置文件中的方法一一对应； Executor：MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 执行的； SqlSession：类似于 JDBC 中的 Connection，可以用 SqlSession 实例来直接执行被映射的 SQL 语句； SqlSessionFactory：SqlSessionFactory 是创建 SqlSession 的工厂，可以通过 SqlSession openSession() 方法创建 SqlSession 对象。 MyBatis 执行流程MyBatis 完整执行流程如下图所示： MyBatis 执行流程说明： 首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。 创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。 创建会话，根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession），会话对象是一个接口，该接口中包含了对数据库操作的增、删、改、查方法。 创建执行器，因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。 封装 SQL 对象，在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。 操作数据库，拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。 MyBatis&nbsp;XML&nbsp;版MyBatis&nbsp;使用分为两个版本：XML&nbsp;版和&nbsp;Java&nbsp;注解版。接下来我们使用 Spring Boot 结合 MyBatis 的 XML 版，来实现对数据库的基本操作，步骤如下。 1）创建数据表drop table if exists `t_user`; create table `t_user` ( `id` bigint(20) not null auto_increment comment '主键id', `username` varchar(32) default null comment '用户名', `password` varchar(32) default null comment '密码', `nick_name` varchar(32) default null, primary key (`id`) ) engine=innodb auto_increment=1 default charset=utf8; 2）添加依赖在项目添加对 MyBatis 和 MySQL 支持的依赖包，在&nbsp;pom.xml&nbsp;文件中添加如下代码： &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; mybatis-spring-boot-starter 是 MyBatis 官方帮助我们快速集成 Spring Boot 提供的一个组件包，mybatis-spring-boot-starter 2.1.0 对应 MyBatis 的版本是 3.5.2。 3）增加配置文件在&nbsp;application.yml&nbsp;文件中添加以下内容： spring: datasource: url: jdbc:mysql://localhost:3306/learndb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver mybatis: config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml type-aliases-package: com.interview.mybatislearning.model 其中： mybatis.config-location：配置 MyBatis 基础属性； mybatis.mapper-locations：配置 Mapper 对应的 XML 文件路径； mybatis.type-aliases-package：配置项目中实体类包路径。 注：如果配置文件使用的是&nbsp;application.properties，配置内容是相同的，只是内容格式不同。 4）创建实体类public class UserEntity implements Serializable { private static final long serialVersionUID = -5980266333958177104L; private Integer id; private String userName; private String passWord; private String nickName; public UserEntity(String userName, String passWord, String nickName) { this.userName = userName; this.passWord = passWord; this.nickName = nickName; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getPassWord() { return passWord; } public void setPassWord(String passWord) { this.passWord = passWord; } public String getNickName() { return nickName; } public void setNickName(String nickName) { this.nickName = nickName; } } 5）创建&nbsp;XML&nbsp;文件mybatis-config.xml（基础配置文件）： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias=\"Integer\" type=\"java.lang.Integer\"/&gt; &lt;typeAlias alias=\"Long\" type=\"java.lang.Long\"/&gt; &lt;typeAlias alias=\"HashMap\" type=\"java.util.HashMap\"/&gt; &lt;typeAlias alias=\"LinkedHashMap\" type=\"java.util.LinkedHashMap\"/&gt; &lt;typeAlias alias=\"ArrayList\" type=\"java.util.ArrayList\"/&gt; &lt;typeAlias alias=\"LinkedList\" type=\"java.util.LinkedList\"/&gt; &lt;/typeAliases&gt; &lt;/configuration&gt; mybatis-config.xml&nbsp;主要是为常用的数据类型设置别名，用于减少类完全限定名的长度，比如：resultType=\"Integer\"&nbsp;完整示例代码如下： &lt;select id=\"getAllCount\" resultType=\"Integer\"&gt; select count(*) from t_user &lt;/select&gt; UserMapper.xml（业务配置文件）： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt; &lt;mapper namespace=\"com.interview.mybatislearning.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.interview.mybatislearning.model.UserEntity\" &gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"BIGINT\" /&gt; &lt;result column=\"username\" property=\"userName\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"password\" property=\"passWord\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"nick_name\" property=\"nickName\" jdbcType=\"VARCHAR\" /&gt; &lt;/resultMap&gt; &lt;sql id=\"Base_Column_List\" &gt; id, username, password, nick_name &lt;/sql&gt; &lt;sql id=\"Base_Where_List\"&gt; &lt;if test=\"userName != null and userName != ''\"&gt; and userName = #{userName} &lt;/if&gt; &lt;/sql&gt; &lt;select id=\"getAll\" resultMap=\"BaseResultMap\" &gt; SELECT &lt;include refid=\"Base_Column_List\" /&gt; FROM t_user &lt;/select&gt; &lt;select id=\"getOne\" parameterType=\"Long\" resultMap=\"BaseResultMap\" &gt; SELECT &lt;include refid=\"Base_Column_List\" /&gt; FROM t_user WHERE id = #{id} &lt;/select&gt; &lt;insert id=\"insert\" parameterType=\"com.interview.mybatislearning.model.UserEntity\" &gt; INSERT INTO t_user (username,password,nick_name) VALUES (#{userName}, #{passWord}, #{nickName}) &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"com.interview.mybatislearning.model.UserEntity\" &gt; UPDATE t_user SET &lt;if test=\"userName != null\"&gt;username = #{userName},&lt;/if&gt; &lt;if test=\"passWord != null\"&gt;password = #{passWord},&lt;/if&gt; nick_name = #{nickName} WHERE id = #{id} &lt;/update&gt; &lt;delete id=\"delete\" parameterType=\"Long\" &gt; DELETE FROM t_user WHERE id =#{id} &lt;/delete&gt; &lt;/mapper&gt; 以上配置我们增加了增删改查等基础方法。 6）增加&nbsp;Mapper&nbsp;文件此步骤我们需要创建一个与&nbsp;XML&nbsp;对应的业务&nbsp;Mapper&nbsp;接口，代码如下： public interface UserMapper { List&lt;UserEntity&gt; getAll(); UserEntity getOne(Long id); void insert(UserEntity user); void update(UserEntity user); void delete(Long id); } 7）添加 Mapper 包扫描在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。 @SpringBootApplication @MapperScan(\"com.interview.mybatislearning.mapper\") public class MyBatisLearningApplication { public static void main(String[] args) { SpringApplication.run(MyBatisLearningApplication.class, args); } } 8）编写测试代码经过以上步骤之后，整个&nbsp;MyBatis&nbsp;的集成就算完成了。接下来我们写一个单元测试，验证一下。 @RunWith(SpringRunner.class) @SpringBootTest public class MybatislearningApplicationTests { @Resource private UserMapper userMapper; @Test public void testInsert() { userMapper.insert(new UserEntity(\"laowang\", \"123456\", \"老王\")); Assert.assertEquals(1, userMapper.getAll().size()); } } 总结通过本文我们知道 MyBatis 是一个优秀和灵活的数据持久化框架，MyBatis 包含 Mapper 配置、Mapper 接口、Executor、SqlSession、SqlSessionFactory 等几个重要的组件，知道了 MyBatis 基本流程：MyBatis 首先加载 Mapper 配置和 SQL 映射文件，通过创建会话工厂得到 SqlSession 对象，再执行 SQL 语句并返回操作信息。我们也使用 XML 的方式，实现了 MyBatis 对数据库的基础操作。","categories":[{"name":"面试专题","slug":"面试专题","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Mybatis/"},{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Mapper","slug":"Mapper","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Mapper/"}]},{"title":"抽象类和接口的应用面试题","slug":"抽象类和接口的应用面试题","date":"2023-03-03T06:22:20.000Z","updated":"2023-03-03T06:23:48.618Z","comments":true,"path":"2023/03/03/chou-xiang-lei-he-jie-kou-de-ying-yong-mian-shi-ti/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/03/chou-xiang-lei-he-jie-kou-de-ying-yong-mian-shi-ti/","excerpt":"","text":"抽象类和接口的应用 + 面试题抽象类定义在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。简单来说，使用关键字 abstract 修饰的类就叫做抽象类。 抽象类使用示例代码，如下： abstract class AbstractAnimal { public AbstractAnimal() { System.out.println(\"Init AbstractAnimal.\"); } static String name = \"AbstractAnimal\"; public abstract void eat(); public void run() { System.out.println(\"AbstractAnimal Run.\"); } } class Animal extends AbstractAnimal { public static void main(String[] args) { AbstractAnimal animal = new Animal(); animal.run(); System.out.println(animal.name); animal.eat(); } @Override public void eat() { System.out.println(\"Animal Eat.\"); } } 以上代码执行的结果： Init AbstractAnimal. AbstractAnimal Run. AbstractAnimal Animal Eat. 抽象方法使用 abstract 关键字修饰的方法叫做抽象方法，抽象方法仅有声明没有方法体。如下代码： public abstract void m(); 抽象类的特性 抽象类不能被初始化 抽象类可以有构造方法 抽象类的子类如果为普通类，则必须重写抽象类中的所有抽象方法 抽象类中的方法可以是抽象方法或普通方法 一个类中如果包含了一个抽象方法，这个类必须是抽象类 子类中的抽象方法不能与父类中的抽象方法同名 抽象方法不能为 private、static、final 等关键字修饰 抽象类中可以包含普通成员变量，访问类型可以任意指定，也可以使用静态变量（static） 接口定义接口（interface）是抽象类的延伸，它允许一个类可以实现多个接口，弥补了抽象类不能多继承的缺陷，接口是对类的描述，使用 interface 关键字来声明。 接口使用示例代码，如下： interface IAnimal { void run(); } class AnimalImpl implements IAnimal { public static void main(String[] args) { IAnimal animal = new AnimalImpl(); animal.run(); } @Override public void run() { System.out.println(\"AnimalImpl Run.\"); } } Java 8 中接口的改动1）接口中增加了 default 方法和 static 方法，可以有方法体示例代码，如下： interface IAnimal { static void printSex() { System.out.println(\"Male Dog\"); } default void printAge() { System.out.println(\"18\"); } } class AnimalImpl implements IAnimal { public static void main(String[] args) { IAnimal.printSex(); IAnimal animal = new AnimalImpl(); animal.printAge(); } } 注意：static 方法属于接口方法，可以直接使用；default 属于实例方法，必须先创建实例。 2）接口中的静态变量会被继承示例代码，如下： interface IAnimal { static String animalName = \"Animal Name\"; static void printSex() { System.out.println(\"Male Dog\"); } } class AnimalImpl implements IAnimal { public static void main(String[] args) { System.out.println(animalName); IAnimal.printSex(); } } 注意：静态变量会被继承，静态方法不会被继承。 3）新增函数式接口 函数式接口（Function Interface）是一个特殊的接口，使用 @FunctionInterface 注解声明，定义这种接口可以使用 Lambda 表达式直接调用。示例代码，如下： @FunctionalInterface interface IAnimal { static String animalName = \"Animal Name\"; static void printSex() { System.out.println(\"Male Dog\"); } default void printAge() { System.out.println(\"18\"); } void sayHi(String name); } class FunctionInterfaceTest { public static void main(String[] args) { IAnimal animal = name -&gt; System.out.println(name); animal.sayHi(\"WangWang\"); } } 注意：使用 @FunctionInterface&nbsp;声明的函数式接口，抽象方法必须有且仅有一个，但可以包含其他非抽象方法。 相关面试题1. 抽象类中能不能包含方法体？答：抽象类中可以包含方法体。抽象类的构成也可以完全是包含方法体的普通方法，只不过这样并不是抽象类最优的使用方式。 题目解析：包含了方法体的抽象类示例代码如下： abstract class AbstractAnimal { public void run() { System.out.println(\"AbstractAnimal Run.\"); } } class Animal extends AbstractAnimal { public static void main(String[] args) { AbstractAnimal animal = new Animal(); animal.run(); } } 以上代码执行的结果是： AbstractAnimal Run. 2. 抽象类能不能被实例化？为什么？答：抽象类不能被实例化，因为抽象类和接口的设计就是用来规定子类行为特征的，就是让其他类来继承，是多态思想的一种设计体现，所以强制规定抽象类不能被实例化。 3. 抽象方法可以被 private 修饰吗？为什么？答：抽象方法不能使用 private 修饰，因为抽象方法就是要子类继承重写的，如果设置 private 则子类不能重写此抽象方法，这与抽象方法的设计理念相违背，所以不能被 private 修饰。 4. 添加以下哪个选项不会引起编译器报错？abstract class AbstractAnimal { static String animalName = \"AbstractAnimal\"; } A：protected abstract void eat();B： void eat();C：abstract void eat(){};D：animalName += “Cat”; 答：A 题目解析：选项 B 普通方法必须有方法体；选项 C 抽象方法不能有方法体；选项 D 变量赋值操作必须在方法内。 5. 以下关于抽象类和抽象方法说法正确的是？A：抽象类中的方法必须全部为抽象方法B： 抽象类中必须包含一个抽象方法C：抽象类中不能包含普通方法D：抽象类中的方法可以全部为普通方法（包含方法体） 答：D 题目解析：抽象类中可以没有方法或者全部为普通方法，都是允许的，如下代码所示： abstract class AbstractAnimal { public void run() { System.out.println(\"AbstractAnimal Run.\"); } } class Animal extends AbstractAnimal { public static void main(String[] args) { AbstractAnimal animal = new Animal(); animal.run(); } } 程序执行的结果为：AbstractAnimal Run. 6. 接口和普通类有什么关系？答：在 Java 语言设计中，接口不是类，而是对类的一组需求描述，这些类必须要遵循接口描述的统一格式进行定义。 7. 接口能不能有方法体？答：JDK 8 之前接口不能有方法体，JDK 8 之后新增了 static 方法和 default 方法，可以包含方法体。 8. 执行以下代码会输出什么结果？interface IAnimal { static String animalName = \"Animal Name\"; } class AnimalImpl implements IAnimal { static String animalName = new String(\"Animal Name\"); public static void main(String[] args) { System.out.println(IAnimal.animalName == animalName); } } 答：执行的结果为 false。 题目解析：子类使用 new String… 重新创建了变量 animalName，又因为使用 == 进行内存地址比较，所以结果就是 false。 9. 抽象类和接口有什么区别？答：抽象类和接口的区别，主要分为以下几个部分。 默认方法 抽象类可以有默认方法的实现 JDK 8 之前接口不能有默认方法的实现，JDK 8 之后接口可以有默认方法的实现 继承方式 子类使用 extends 关键字来继承抽象类 子类使用 implements 关键字类实现接口 构造器 抽象类可以有构造器 接口不能有构造器 方法访问修饰符 抽象方法可以用 public / protected / default 等修饰符 接口默认是 public 访问修饰符，并且不能使用其他修饰符 多继承 一个子类只能继承一个抽象类 一个子类可以实现多个接口 10. 以下抽象方法描述正确的是？A：抽象方法可以是静态（static）的B：抽象方法可同时是本地方法（native）C：抽象方法可以被 synchronized 修饰D：以上都不是 答：D 题目解析：抽象方法需要被子类重写，而静态方法是无法被重写的，因此抽象方法不能被静态（static）修饰；本地方法是由本地代码实现的方法，而抽象方法没有实现，所以抽象方法不能同时是本地方法；synchronized 和方法的实现细节有关，而抽象方法不涉及实现细节，因此抽象方法不能被 synchronized 修饰。 总结抽象类和接口都是面向对象编程中多态的具体实现，在 Java 编程思想中占据着重要的地位，同时也是初级面试岗位必问的问题之一，但由于接口在 JDK 8 中的改动比较大，因而面试者在网上搜到的绝大数关于接口和抽象类区别的答案也是不准确的，这点需要面试者特别注意一下。","categories":[{"name":"面试专题","slug":"面试专题","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Java/"},{"name":"抽象类","slug":"抽象类","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"}]},{"title":"MySQL面试题汇总","slug":"MySQL面试题汇总","date":"2023-03-03T06:19:07.000Z","updated":"2023-03-05T11:11:15.005Z","comments":true,"path":"2023/03/03/mysql-mian-shi-ti-hui-zong/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/03/mysql-mian-shi-ti-hui-zong/","excerpt":"","text":"MySQL 面试题汇总[toc] 1. 说一下 MySQL 执行一条查询语句的内部执行过程？答：MySQL 执行一条查询的流程如下： 客户端先通过连接器连接到 MySQL 服务器； 连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器； 分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器； 优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好； 优化器执行完就进入执行器，执行器则开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。 2.MySQL 查询缓存有什么优缺点？答：MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。 3.MySQL 的常用引擎都有哪些？答：MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。 4. 常用的存储引擎 InnoDB 和 MyISAM 有什么区别？答：InnoDB 和 MyISAM 最大的区别是&nbsp;InnoDB 支持事务，而&nbsp;MyISAM 不支持事务，它们其他主要区别如下： InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复； InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁； InnoDB 支持外键，MyISAM 不支持外键； MyISAM 性能比&nbsp;InnoDB 高； MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好； InnoDB 主键查询性能高于 MyISAM。 5. 什么叫回表查询？答：普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。 6. 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？答：不是，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。 7. 一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？答：如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。 8. 什么是独立表空间和共享表空间？它们的区别是什么？答：共享表空间指的是数据库的所有表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，因此表依然很大，而独立表空间如果删除表就会清除空间。 9. 清空表的所有数据性能最好的语句是？A：delete from tB：delete tC：drop table tD：truncate table t 答：D 题目解析：truncate 清除表数据不会写日志，delete 要写日志，因此 truncate 的效率要高于 delete。 10. 唯一索引和普通索引哪个性能更好？答：唯一索引和普通索引的性能对比分为以下两种情况： 对于查询来说两者都是从索引树进行查询，性能几乎没有任何区别； 对于更新操作来说，因为唯一索引需要先将数据读取到内存，然后需要判断是否有冲突，因此比普通索引要多了判断操作，从而性能就比普通索引性能要低。 11.left join 和 right join 的区别是什么？答：left join 和 right join 的区别如下： left join（左联结），返回左表全部记录和右表联结字段相等的记录； right join（右联结），返回右表全部记录和左表联结字段相等的记录。 12. 什么是最左匹配原则？它的生效原则有哪些？答：最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，指的是索引以最左边为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)： where a=1 只使用了索引 a； where a=1 and b=2 只使用了索引 a,b； where a=1 and b=2 and c=3 使用 a,b,c； where b=1 or where c=1 不使用索引； where a=1 and c=3 只使用了索引 a； where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。 13. 以下 or 查询有什么问题吗？该如何优化？ select * from t where num=10 or num=20; 答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为： select * from t where num=10 union select * from t where num=20; 14. 事务是什么？它有什么特性？答：事务是一系列的数据库操作，是数据库应用的基本单位。 在 MySQL 中只有 InnoDB 引擎支持事务，它的四个特性如下： 原子性（Atomic），要么全部执行，要么全部不执行； 一致性（Consistency），事务的执行使得数据库从一种正确状态转化为另一种正确状态； 隔离性（Isolation），在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务； 持久性（Durability），事务提交后，其结果永久保存在数据库中。 15.MySQL 中有几种事务隔离级别？分别是什么？答：MySQL 中有四种事务隔离级别，分别是： read uncommited，未提交读，读到未提交数据； read committed，读已提交，也叫不可重复读，两次读取到的数据不一致； repetable read，可重复读； serializable，串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。 MySQL 默认使用&nbsp;repetable read 的事务隔离级别。 16. 如何设置 MySQL 的事务隔离级别？答：MySQL 事务隔离级别 mysql.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置： transaction-isolation = REPEATABLE-READ 可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。 17.MySQL 出现了中文乱码该如何解决？答：解决 MySQL 中文乱码的问题，可以设置全局编码或设置某个数据库或表的编码为 utf8。 设置全局编码： set character_set_client='utf8'; set character_set_connection='utf8'; set character_set_results='utf8'; 设置数据库的编码： alter database db character set utf8; 设置表的编码： alter table t character set utf8; 18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？答：因为 B 树、Hash、红黑树或二叉树存在以下问题。 B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。 Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高。 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。 红黑树：树的高度随着数据量增加而增加，IO 代价高。 19.MySQL&nbsp;是如何处理死锁？答：MySQL 对待死锁常见的两种策略： 通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时； 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。 20. 什么是全局锁？它的应用场景有哪些？答：全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全量逻辑备份，这个时候整个库会处于完全的只读状态。 21. 使用全局锁会导致什么问题？答：使用全局锁会使整个系统不能执行更新操作，所有的更新业务会出于等待状态；如果你是在从库进行备份，则会导致主从同步严重延迟。 22.InnoDB 存储引擎有几种锁算法？答：InnoDB 的锁算法包括以下三种： Record Lock — 单个行记录上的锁； Gap Lock — 间隙锁，锁定一个范围，不包括记录本身； Next-Key Lock — 锁定一个范围，包括记录本身。 23.InnoDB 如何实现行锁？答：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁。使用 for update 来实现行锁，具体脚本如下： select * from t where id=1 for update 其中 id 字段必须有索引。 24.MySQL 性能指标都有哪些？如何得到这些指标？答：MySQL 最重要的性能指标有以下两个： QPS（Queries Per Second），每秒查询数，一台数据库每秒能够处理的查询次数； TPS（Transactions Per Second），每秒处理事务数。 这些性能指标可以通过 show status 来查询当前数据库状态的结果信息中估算出来，show status 会有 300 多条状态信息记录，其中以下这些信息 QPS 和 TPS 有关系： Uptime，服务器已经运行的时间，单位秒； Questions，已经发送给数据库查询数； Com_select，查询次数，实际查询次数； Com_insert，插入次数； Com_delete，删除次数； Com_update，更新次数； Com_commit，事务次数； Com_rollback，回滚次数。 25.MySQL 中的重要日志分为哪几个？① 错误日志：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为： mv hostname.err &nbsp;hostname.err.old mysqladmin flush-logs ② 查询日志：查询日志在 MySQL 中被称为 general log（通用日志），查询日志里的内容不要被 “查询日志” 误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下: insert 查询为了避免数据冲突，如果此前插入过数据，则当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错； update 时也会查询因为更新的时候很可能会更新某一块数据； delete 查询，只删除符合条件的数据； 因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。 查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，因此，可以根据自己的实际情况来决定是否开启查询日志。 查询日志模式是关闭的，可以通过以下命令开启查询日志： set global general_log=1 set global log_output=’table’; general_log=1 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。 ③ 慢日志：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句： set global slow_query_log=’ON’; 使用 set global slow_query_log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。因此如果要永久生效，就要修改配置文件 my.cnf，设置 slow_query_log=1 并重启 MySQL 服务器。 ④ redo log（重做日志）：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。 ⑤ undo log（回滚日志）：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。undo log 默认存放在共享表空间中，在 ySQL 5.6 中，undo log 的存放位置还可以通过变量 innodb_undo_directory 来自定义存放目录，默认值为 “.” 表示 datadir 目录。 ⑥ bin log（二进制日志）：是一个二进制文件，主要记录所有数据库表结构变更，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，bin log 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其他额外信息，但是它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句。 binlog 的作用如下： 恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复； 复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步； 审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。 除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。 binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。 通过以下命令来查询 binlog 是否开启： show variables like ‘log_%’; binlog 格式分为 STATEMENT、ROW 和 MIXED 三种。 STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，因此相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间，并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL，比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如，InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制。 ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，因此，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，因此可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等。 MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT_USER()、ROW_COUNT() 等无法确定的函数。 26.redo log&nbsp;和&nbsp;binlog&nbsp;有什么区别？redo log（重做日志）和 binlog（归档日志）都是&nbsp;MySQL&nbsp;的重要的日志，它们的区别如下： redo log 是物理日志，记录的是 “在某个数据页上做了什么修改”； binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 ID=2 这一行的 c 字段加 1”； redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用； redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的，“追加写” 是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，因此 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。 27. 慢查询日志的获取方式有哪些？答：慢查询日志的常见获取方式如下。 使用 MySQL 自带功能，开启慢查询日志，在 MySQL 的安装目录下找到 my.cnf 文件设置 slow-query-log=On 开启慢查询，慢查询默认时长为 10s，默认存储文件名为 host_name-slow.log。 使用三方开源方案 zabbix，zabbix 是一个基于 Web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案，能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位 / 解决存在的各种问题。 28. 如何定位慢查询？答：使用 MySQL 中的 explain 分析执行语句，比如： explain select * from t where id=5; 如下图所示： 其中： id — 选择标识符，id 越大优先级越高，越先被执行 select_type&nbsp;— 表示查询的类型。 table&nbsp;— 输出结果集的表 partitions&nbsp;— 匹配的分区 type&nbsp;— 表示表的连接类型 possible_keys&nbsp;— 表示查询时，可能使用的索引 key&nbsp;— 表示实际使用的索引 key_len&nbsp;— 索引字段的长度 ref—&nbsp; 列与索引的比较 rows&nbsp;— 大概估算的行数 filtered&nbsp;— 按表条件过滤的行百分比 Extra&nbsp;— 执行情况的描述和说明 其中最重要的就是 type 字段，type 值类型如下： all — 扫描全表数据 index — 遍历索引 range — 索引范围查找 index_subquery — 在子查询中使用 ref unique_subquery — 在子查询中使用 eq_ref ref_or_null — 对 null 进行索引的优化的 ref fulltext — 使用全文索引 ref — 使用非唯一索引查找数据 eq_ref — 在 join 查询中使用主键或唯一索引关联 const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点 29.MySQL 中常见的读写分离方案有哪些？答：MySQL 中常见的读写分离方案通常为以下两种： 使用 MySQL 官方提供的数据库代理产品 MySql ProxySQL 搭建自动分配的数据库读写分离环境； 在程序层面配置多数据源使用代码实现读写分离。 30. 怎样保证主备数据库无延迟？答：通常保证主备数据库无延迟有以下三种方法。 每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds_behind_master 参数是用来衡量主备延迟时间的长短。 对比位点确保主备无延迟。Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。 对比 GTID 集合确保主备无延迟。Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。 31. 什么是 MySQL 多实例，如何配置 MySQL 多实例？答：MySQL 多实例就是在同一台服务器上启用多个 MySQL 服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展。 多实例的配置方法有两种： 一个实例一个配置文件，不同端口； 同一配置文件（my.cnf）下配置不同实例，基于 MySQL 的 d_multi 工具。 32. 表的优化策略有哪些？「参考答案」常见的大表优化策略如下。 读写分离，主库负责写，从库负责读。 垂直分区，根据数据属性单独拆表甚至单独拆库。 水平分区，保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中。水平拆分只是解决了单一表数据过大的问题，表数据还在同一台机器上，对于并发能力没有什么意义，因此水平拆分最好分库。另外分片事务难以解决，跨节点 join 性能较差。 33. 数据库分片方案有哪些？「参考答案」数据库分片方案有哪些？ 答：数据库创建的分片方案有两种方式：客户端代理方式和中间件代理方式。 客户端代理 — 分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现，比如 Sharding-JDBC、阿里 TDDL 等。 中间件代理 — 在应用层和数据层中间加了一个代理层。分片逻辑统一维护在中间件服务中，比如 MyCat、网易的 DDB 都是中间件代理的典型代表。 34. 查询语句的优化方案有哪些？「参考答案」常见优化方案如下： 不做列运算，把计算都放入各个业务系统实现； 查询语句尽可能简单，大语句拆小语句，减少锁时间； 不使用 select * 查询； or 查询改写成 in 查询； 不用函数和触发器； 避免 %xx 查询； 少用 join 查询； 使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123； 尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描； 列表数据使用分页查询，每页数据量不要太大。 35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？「参考答案」可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下： 定期断开空闲的长连接； 如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql_reset_connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。","categories":[{"name":"面试专题","slug":"面试专题","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/MySQL/"}]},{"title":"Matery主题的配置","slug":"Matery主题的配置","date":"2023-03-03T05:18:24.000Z","updated":"2023-03-08T03:22:59.772Z","comments":true,"path":"2023/03/03/matery-zhu-ti-de-pei-zhi/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/03/matery-zhu-ti-de-pei-zhi/","excerpt":"","text":"下载本主题推荐你使用 Hexo 5.0.0 及以上的版本。如果，你已经有一个自己的 Hexo 博客了，建议你将 Hexo 升级到最新稳定的版本。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 git clone 命令来下载: git clone https://github.com/blinkfox/hexo-theme-matery.git 配置切换主题修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： --- title: categories date: 2022-09-30 17:25:30 type: \"categories\" layout: \"categories\" --- 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： --- title: tags date: 2022-09-30 18:23:38 type: \"tags\" layout: \"tags\" --- 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： --- title: about date: 2022-09-30 17:25:30 type: \"about\" layout: \"about\" --- 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： --- title: contact date: 2022-09-30 17:25:30 type: \"contact\" layout: \"contact\" --- 注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： --- title: friends date: 2022-12-12 21:25:30 type: \"friends\" layout: \"friends\" --- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： [{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" }] 新建 404 页如果在你的博客 source 目录下还没有 404.md 文件，那么你就需要新建一个 hexo new page 404 编辑你刚刚新建的页面文件 /source/404/index.md，至少需要以下内容： --- title: 404 date: 2022-09-30 17:25:30 type: \"404\" layout: \"404\" description: \"Oops～，我崩溃了！找不到你想要的页面 :(\" --- 菜单导航配置配置基本菜单导航的名称、路径url和图标icon.1.菜单导航名称可以是中文也可以是英文(如：Index或主页)2.图标icon 可以在Font Awesome 中查找 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children) 在children下创建二级菜单的 名称name,路径url和图标icon. 注意每个二级菜单模块前要加 -. 注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Music url: /music icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 代码高亮从 Hexo5.0 版本开始自带了 prismjs 代码语法高亮的支持，本主题对此进行了改造支持。 如果你的博客中曾经安装过 hexo-prism-plugin 的插件，那么你须要执行 npm uninstall hexo-prism-plugin 来卸载掉它，否则生成的代码中会有 &amp;#123; 和 &amp;#125; 的转义字符。 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并将 prismjs.enable 的值设置为 true，主要配置如下： highlight: enable: false line_number: true auto_detect: false tab_replace: '' wrap: true hljs: false prismjs: enable: true preprocess: true line_number: true tab_replace: '' 主题中默认的 prismjs 主题是 Tomorrow Night，如果你想定制自己的主题，可以前往 prismjs 下载页面 定制下载自己喜欢的主题 css 文件，然后将此 css 主题文件取名为 prism.css，替换掉 hexo-theme-matery 主题文件夹中的 source/libs/prism/prism.css 文件即可。 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： search: path: search.xml field: post 中文链接转拼音（建议安装）如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后就可以在文章中对应位置看到你用emoji语法写的表情了。 添加 RSS 订阅支持（可选的）本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 添加中文繁简转换在主题的 _config.yml 文件中，开启 translate 为 enable。 开启中文繁简转换如下修改。默认不开启。实例演示： 繁简转换 底下 footer 栏 translate: enable: true 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的）要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可： # 是否在首页显示音乐 music: enable: true title: # 非吸底模式有效 enable: true show: 听听音乐 server: netease # require music platform: netease, tencent, kugou, xiami, baidu type: playlist # require song, playlist, album, search, artist id: 503838841 # require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐）， baidu（百度音乐）。 type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，playlist的id 即为这串数字。 添加note 演示 Usage{% note [class] [no-icon] [summary] %} Any content (support inline tags too). {% endnote %} [class] : Optional parameter. Supported values: default | primary | success | info | warning | danger. [no-icon] : Optional parameter. Disable icon in note. [summary] : Optional parameter. Optional summary of the note. All parameters are optional. example{% note %} #### Header (without define class style) {% endnote %} 添加button 演示 Usage{% button url, text, icon [class], [title] %} or {% btn url, text, icon [class], [title] %} url : Absolute or relative path to URL. text : Button text. Required if no icon specified. icon : Font Awesome icon name. Required if no text specified. [class] : Optional parameter. Font Awesome class(es): fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5x [title] : Optional parameter. Tooltip at mouseover. Examples{% button #, Text %} 文章 Front-matter 介绍Front-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 hide false 隐藏文章，如果hide值为true，则文章不会在首页显示 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例--- title: typora-vue-theme主题介绍 date: 2022-09-07 09:25:00 --- 最全示例--- title: typora-vue-theme主题介绍 date: 2022-09-07 09:25:00 author: 赵奇 img: /source/images/xxx.jpg top: true hide: false cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 效果截图 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方： 修改主题颜色在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */ .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); } @-webkit-keyframes rainbow { /* 动态切换背景颜色. */ } @keyframes rainbow { /* 动态切换背景颜色. */ } 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 版本变更记录参见 CHANGELOG.md 更多部署方式 Jsdelivr 已经被封了，这两个可以加速访问快一点 vercel 部署cloudflare Pages 部署","categories":[{"name":"主题美化","slug":"主题美化","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"}],"tags":[{"name":"主题","slug":"主题","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E4%B8%BB%E9%A2%98/"},{"name":"美化","slug":"美化","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Hexo/"}]},{"title":"CentOS7安装与配置","slug":"CentOS7安装与配置","date":"2023-03-02T08:18:24.000Z","updated":"2023-03-07T12:39:30.519Z","comments":true,"path":"2023/03/02/centos7-an-zhuang-yu-pei-zhi/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/02/centos7-an-zhuang-yu-pei-zhi/","excerpt":"","text":"CentOS7安装与配置1.安装比较简单，重点在配置磁盘 选择手动分区，一般选择LVM或Standard Partition(标准分区) 进入分区页面/boot分区默认1024M，swap分区为实际内存的1-2倍，除swap外其他分区系统文件类型选择ext4。 ！注意 (1)有的机器若有/boot/efi分区，那必须要配。 (2)在使用U盘安装系统的过程中若进入到到dracut界面，则是机器没有找到你的U盘。这个配置是需要在上一步需要完成的，但在上一步我们并不知道U盘的文件名，所以索性在这一步查看一下U盘的设备名具体命令为 cd /dev ;输入 blkid 查看块设备的文件系统类型、LABEL、UUID等信息,然后记下设备名 按Ctrl+Alt+Delete重启回到安装界面，然后再回到安装界面,按下e或Tab进入编辑模式，将vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso quiet 这一行改成vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4(设备名) quite，改完按下Ctrl+x或Enter执行,就可以正常安装CentOS系统了。 2.关闭selinuxvi /etc/selinux/config SELINUX=disabled reboot 3.优化ulimit修改/etc/security/limits.conf 加入以下两行,reboot重启生效 soft nofile 32768 hard nofile 65536 4.配置网卡ip addr查看网卡信息，由于CentOS mini安装没有net-tools工具包，不能使用ifconfig 查看地址，使用 yum install -y net-tools（yum install net-tools.x86_64）可以安装 编辑网卡配置文件#vi /etc/sysconfig/network-scripts/ifcfg-enxxx（网卡名称） BOOTPROTO=none NAME=enp7s0 DEVICE=enp7s0 ONBOOT=yes IPADDR=10.10.1.112 GATEWAY=10.10.1.254 DNS1=114.114.114.114 DNS2=8.8.8.8 PREFIX=24 配置完成后执行service network restart或者/etc/init.d/network restart 来重启网络 5.常用命令shutdown -h now 关闭系统 /halt 关闭系统 poweroff /关闭系统 shutdown -r now 重启 / reboot 重启 查看防火墙状态:systemctl status firewalldsystemctl stop firewalldsystemctl disable firewalld查看防火墙是否关闭状态:systemctl is-enabled firewalld 修改主机名称:vim /etc/hostname 配置主机名称映射:vim /etc/hosts 重启网卡/etc/init.d/network restart ls -a 列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来ls -l (简写ll) 显示文件和目录的详细资料 mkdir命令：创建 mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录 rm命令：删除 rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ （空目录才能删除）rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv命令：该命令用于移动文件、目录或更名，move之意，它的常用参数如下：-f 如果目标文件已经存在，不会询问而直接覆盖 mv file1 file2 把文件file1重命名为file2 mv file1 file2 dir 把文件file1、file2移动到目录dir中 cp命令：该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下， 它的常用参数如下： cp -a file1 file2 连同文件的所有特性把文件file1复制成文件file2cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录 find命令：find是一个基于查找的功能非常强大的命令 find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 ps命令：该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下： -A ：所有的进程均显示出来-a ：不与terminal有关的所有进程-u ：有效用户的相关进程-x ：一般与a参数一起使用，可列出较完整的信息-l ：较长，较详细地将PID的信息列出其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下： ps aux 查看系统所有的进程数据ps ax 查看不与terminal有关的所有进程ps -lA 查看系统所有的进程数据ps axjf 查看连同一部分进程树状态 kill命令：该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下： kill -signal PIDsignal的常用参数如下：注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。 1：SIGHUP，启动被终止的进程2：SIGINT，相当于输入ctrl+c，中断一个程序的进行9：SIGKILL，强制中断一个进程的进行15：SIGTERM，以正常的结束进程方式来终止进程17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行例如： # 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程kill -SIGTERM %1# 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得kill -SIGHUP PID tar命令：该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下： 压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 查询：tar -jtv -f filename.tar.bz2 解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 chmod命令：该命令用于改变文件的权限，一般的用法如下： chmod -R 777 chmod -R 777 意思就是将当前目录及目录下所有文件都给予777权限（所有权限） 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 6.还是命令(更全)Linux常用命令大全（非常全！！！） 最近都在和Linux打交道，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。我将我了解到的命令列举一下，仅供大家参考： 系统信息arch 显示机器的处理器架构uname -m 显示机器的处理器架构uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统init 0 关闭系统telinit 0 关闭系统shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启reboot 重启logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构lstree 显示文件和目录由根目录开始的树形结构mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录 cp -r dir1 dir2 复制一个目录及子目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统fdformat -n /dev/fd0 格式化一个软盘mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统swapon /dev/hda3 启用一个新的swap文件系统swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav –delete /home /tmp 同步两边的目录rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name ‘.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find /var/log -name ‘.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置ifup eth0 启用一个 ‘eth0’ 网络设备ifdown eth0 禁用一个 ‘eth0’ 网络设备ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)dhclient eth0 以dhcp模式启用 ‘eth0’route -n show routing tableroute add -net 0/0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’route del 0/0 gw IP_gateway remove static routeecho “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routinghostname show hostname of systemhost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversaip link show show link status of all interfacesmii-tool eth0 show link status of ‘eth0’ethtool eth0 show statistics of network card ‘eth0’netstat -tup show all active network connections and their PIDnetstat -tupl show all network services listening on the system and their PIDtcpdump tcp port 80 show all HTTP trafficiwlist scan show wireless networksiwconfig eth1 show configuration of a wireless network cardhostname show hostnamehost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversawhois www.example.com lookup on Whois database JPS工具 jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。 我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。 使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。 jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path. $&gt; jps23991 Jps23789 BossMain23651 Resin 比较常用的参数： -q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数$&gt; jps -q286802378923651 -m 输出传递给main 方法的参数，在嵌入式jvm上可能是null $&gt; jps -m28715 Jps -m23789 BossMain23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log -l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名 $&gt; jps -l28729 sun.tools.jps.Jps23789 com.asiainfo.aimc.bossbi.BossMain23651 com.caucho.server.resin.Resin -v 输出传递给JVM的参数 $&gt; jps -v23789 BossMain28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl - Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl sudo jps看到的进程数量最全 jps 192.168.0.77 列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099 （前提是远程服务器提供jstatd服务） 注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。 安装Srun 4000系统1.安装srun4k获取srun4k包 解压到根目录 / cd / tar -zxvf srun4_centos7_xxxxx.tgz cd /srun3 ./install &gt; ./install.log 2.卸载srun4kcd /srun3 ./uninstall 3.相关命令/srun3/bin/srun3d status # 服务状态 /srun3/bin/srun3d start # 服务启动 /srun3/bin/srun3d restart # 服务重启 /srun3/bin/srun3d stop # 服务关闭 /srun3/bin/rad_auth -v #查看内核版本号及server id /srun3/bin/server_aaa restart /srun3/bin/server_portal restart /srun3/bin/server_httpd restart /etc/init.d/srun3kauth restart #修改Portal页面后执行命令 /srun3/bin/server_bas start #单独启动DPDK网关 /srun3/www/Srun4k-webcron-install_v1.1.3.bin #srun4k开启定时任务8000 netstat -tupln | grep nginx #查看nginx端口 route #显示和操作 IP 路由表。 routel #以好看的输出格式列出路由 #抓包相关 tcpdump -i any -u udp-w /root/xxx.pcap tcpdump -i eth0 port 1812 or 1813 or 3799 or 2000 -w/na.cap killall srun_portal_server;/srun3/bin/srun_portal_server -d killall rad_dm;/srun3/bin/rad_dm -d killall radiusd;/srun3/radius/sbin/radiusd -X &gt;/radius.txt &amp; ss -tnl #查看主机监听的tcp端口信息 /srun3/bin/ldap_test -s -u 用户名 #ldap测试用户名 修改Portal页面后执行命令 /etc/init.d/srun3kauth restart ss详情 ss 是 Socket Statistics 的缩写。ss 命令可以用来获取 socket 统计信息，它显示的内容和 netstat 类似。但 ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，而且比 netstat 更快。当服务器的 socket 连接数量变得非常大时，无论是使用 netstat 命令还是直接 cat /proc/net/tcp，执行速度都会很慢。ss 命令利用到了 TCP 协议栈中 tcp_diag。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，因此 ss 命令的性能会好很多。 -h, --help 帮助 -V, --version 显示版本号 -t, --tcp 显示 TCP 协议的 sockets -u, --udp 显示 UDP 协议的 sockets -x, --unix 显示 unix domain sockets，与 -f 选项相同 -n, --numeric 不解析服务的名称，如 \"22\" 端口不会显示成 \"ssh\" -l, --listening 只显示处于监听状态的端口 -p, --processes 显示监听端口的进程(Ubuntu 上需要 sudo) -a, --all 对 TCP 协议来说，既包含监听的端口，也包含建立的连接 -r, --resolve 把 IP 解释为域名，把端口号解释为协议名称","categories":[{"name":"系统运维","slug":"系统运维","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Linux/"}]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"面试专题","slug":"面试专题","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"},{"name":"主题美化","slug":"主题美化","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"},{"name":"系统运维","slug":"系统运维","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Mybatis/"},{"name":"Mapper","slug":"Mapper","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Mapper/"},{"name":"抽象类","slug":"抽象类","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/MySQL/"},{"name":"主题","slug":"主题","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E4%B8%BB%E9%A2%98/"},{"name":"美化","slug":"美化","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Hexo/"},{"name":"Centos","slug":"Centos","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Linux/"}]}