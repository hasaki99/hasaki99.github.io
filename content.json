{"meta":{"title":"华紫樱绯","subtitle":"华紫樱绯","description":"记录无聊的生活","author":"Judge","url":"https://github.com/hasaki99/hasaki99.github.io","root":"/"},"pages":[{"title":"404","date":"2023-03-02T13:00:05.000Z","updated":"2023-03-02T13:00:27.204Z","comments":true,"path":"404/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2023-03-02T12:57:24.000Z","updated":"2023-03-02T12:57:39.746Z","comments":true,"path":"about/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-03-02T12:58:34.000Z","updated":"2023-03-02T12:58:50.448Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-02T12:56:51.000Z","updated":"2023-03-02T12:57:11.500Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-02T12:55:37.000Z","updated":"2023-03-02T13:56:33.672Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2023-03-02T12:57:56.000Z","updated":"2023-03-02T12:58:09.025Z","comments":true,"path":"contact/index.html","permalink":"https://github.com/hasaki99/hasaki99.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"MyBatis核心组件面试题","slug":"MyBatis核心组件面试题","date":"2023-03-03T06:25:17.000Z","updated":"2023-03-03T06:26:58.089Z","comments":true,"path":"2023/03/03/mybatis-he-xin-zu-jian-mian-shi-ti/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/03/mybatis-he-xin-zu-jian-mian-shi-ti/","excerpt":"","text":"MyBatis 核心组件 + 面试题[toc] MyBatis&nbsp;介绍MyBatis 是一款优秀的 ORM（Object Relational Mapping，对象关系映射）框架，它可以通过对象和数据库之间的映射，将程序中的对象自动存储到数据库中。它是 Apache 提供的一个开源项目，之前的名字叫做 iBatis，2010 年迁移到了 Google Code，并且将名字改为我们现在所熟知的 MyBatis，又于 2013 年 11 月迁移到了 Github。 MyBatis 提供了普通 SQL 查询、事务、存储过程等功能，它的优缺点如下。 优点： 相比于 JDBC 需要编写的代码更少 使用灵活，支持动态 SQL 提供映射标签，支持对象与数据库的字段关系映射 缺点： SQL 语句依赖于数据库，数据库移植性差 SQL 语句编写工作量大，尤其在表、字段比较多的情况下 总体来说，MyBatis 是一个非常优秀和灵活的数据持久化框架，适用于需求多变的互联网项目，也是当前主流的 ORM 框架。 MyBatis&nbsp;重要组件MyBatis&nbsp;中的重要组件如下： Mapper 配置：用于组织具体的查询业务和映射数据库的字段关系，可以使用 XML 格式或 Java 注解格式来实现； Mapper 接口：数据操作接口也就是通常说的 DAO 接口，要和 Mapper 配置文件中的方法一一对应； Executor：MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 执行的； SqlSession：类似于 JDBC 中的 Connection，可以用 SqlSession 实例来直接执行被映射的 SQL 语句； SqlSessionFactory：SqlSessionFactory 是创建 SqlSession 的工厂，可以通过 SqlSession openSession() 方法创建 SqlSession 对象。 MyBatis 执行流程MyBatis 完整执行流程如下图所示： MyBatis 执行流程说明： 首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。 创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。 创建会话，根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession），会话对象是一个接口，该接口中包含了对数据库操作的增、删、改、查方法。 创建执行器，因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。 封装 SQL 对象，在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。 操作数据库，拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。 MyBatis&nbsp;XML&nbsp;版MyBatis&nbsp;使用分为两个版本：XML&nbsp;版和&nbsp;Java&nbsp;注解版。接下来我们使用 Spring Boot 结合 MyBatis 的 XML 版，来实现对数据库的基本操作，步骤如下。 1）创建数据表12345678910drop table if exists `t_user`;create table `t_user` ( `id` bigint(20) not null auto_increment comment '主键id', `username` varchar(32) default null comment '用户名', `password` varchar(32) default null comment '密码', `nick_name` varchar(32) default null, primary key (`id`)) engine=innodb auto_increment=1 default charset=utf8; 2）添加依赖在项目添加对 MyBatis 和 MySQL 支持的依赖包，在&nbsp;pom.xml&nbsp;文件中添加如下代码： 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt;&lt;/dependency&gt; mybatis-spring-boot-starter 是 MyBatis 官方帮助我们快速集成 Spring Boot 提供的一个组件包，mybatis-spring-boot-starter 2.1.0 对应 MyBatis 的版本是 3.5.2。 3）增加配置文件在&nbsp;application.yml&nbsp;文件中添加以下内容： 123456789101112spring: datasource: url: jdbc:mysql://localhost:3306/learndb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Drivermybatis: config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml type-aliases-package: com.interview.mybatislearning.model 其中： mybatis.config-location：配置 MyBatis 基础属性； mybatis.mapper-locations：配置 Mapper 对应的 XML 文件路径； mybatis.type-aliases-package：配置项目中实体类包路径。 注：如果配置文件使用的是&nbsp;application.properties，配置内容是相同的，只是内容格式不同。 4）创建实体类1234567891011121314151617181920212223242526272829303132333435363738public class UserEntity implements Serializable { private static final long serialVersionUID = -5980266333958177104L; private Integer id; private String userName; private String passWord; private String nickName; public UserEntity(String userName, String passWord, String nickName) { this.userName = userName; this.passWord = passWord; this.nickName = nickName; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getPassWord() { return passWord; } public void setPassWord(String passWord) { this.passWord = passWord; } public String getNickName() { return nickName; } public void setNickName(String nickName) { this.nickName = nickName; }} 5）创建&nbsp;XML&nbsp;文件mybatis-config.xml（基础配置文件）： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias=\"Integer\" type=\"java.lang.Integer\"/&gt; &lt;typeAlias alias=\"Long\" type=\"java.lang.Long\"/&gt; &lt;typeAlias alias=\"HashMap\" type=\"java.util.HashMap\"/&gt; &lt;typeAlias alias=\"LinkedHashMap\" type=\"java.util.LinkedHashMap\"/&gt; &lt;typeAlias alias=\"ArrayList\" type=\"java.util.ArrayList\"/&gt; &lt;typeAlias alias=\"LinkedList\" type=\"java.util.LinkedList\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; mybatis-config.xml&nbsp;主要是为常用的数据类型设置别名，用于减少类完全限定名的长度，比如：resultType=\"Integer\"&nbsp;完整示例代码如下： 1234567&lt;select id=\"getAllCount\" resultType=\"Integer\"&gt; select count(*) from t_user&lt;/select&gt; UserMapper.xml（业务配置文件）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.interview.mybatislearning.mapper.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.interview.mybatislearning.model.UserEntity\" &gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"BIGINT\" /&gt; &lt;result column=\"username\" property=\"userName\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"password\" property=\"passWord\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"nick_name\" property=\"nickName\" jdbcType=\"VARCHAR\" /&gt; &lt;/resultMap&gt; &lt;sql id=\"Base_Column_List\" &gt; id, username, password, nick_name &lt;/sql&gt; &lt;sql id=\"Base_Where_List\"&gt; &lt;if test=\"userName != null and userName != ''\"&gt; and userName = #{userName} &lt;/if&gt; &lt;/sql&gt; &lt;select id=\"getAll\" resultMap=\"BaseResultMap\" &gt; SELECT &lt;include refid=\"Base_Column_List\" /&gt; FROM t_user &lt;/select&gt; &lt;select id=\"getOne\" parameterType=\"Long\" resultMap=\"BaseResultMap\" &gt; SELECT &lt;include refid=\"Base_Column_List\" /&gt; FROM t_user WHERE id = #{id} &lt;/select&gt; &lt;insert id=\"insert\" parameterType=\"com.interview.mybatislearning.model.UserEntity\" &gt; INSERT INTO t_user (username,password,nick_name) VALUES (#{userName}, #{passWord}, #{nickName}) &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"com.interview.mybatislearning.model.UserEntity\" &gt; UPDATE t_user SET &lt;if test=\"userName != null\"&gt;username = #{userName},&lt;/if&gt; &lt;if test=\"passWord != null\"&gt;password = #{passWord},&lt;/if&gt; nick_name = #{nickName} WHERE id = #{id} &lt;/update&gt; &lt;delete id=\"delete\" parameterType=\"Long\" &gt; DELETE FROM t_user WHERE id =#{id} &lt;/delete&gt;&lt;/mapper&gt; 以上配置我们增加了增删改查等基础方法。 6）增加&nbsp;Mapper&nbsp;文件此步骤我们需要创建一个与&nbsp;XML&nbsp;对应的业务&nbsp;Mapper&nbsp;接口，代码如下： 123456789public interface UserMapper { List&lt;UserEntity&gt; getAll(); UserEntity getOne(Long id); void insert(UserEntity user); void update(UserEntity user); void delete(Long id);} 7）添加 Mapper 包扫描在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。 123456789@SpringBootApplication@MapperScan(\"com.interview.mybatislearning.mapper\")public class MyBatisLearningApplication { public static void main(String[] args) { SpringApplication.run(MyBatisLearningApplication.class, args); }} 8）编写测试代码经过以上步骤之后，整个&nbsp;MyBatis&nbsp;的集成就算完成了。接下来我们写一个单元测试，验证一下。 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class MybatislearningApplicationTests { @Resource private UserMapper userMapper; @Test public void testInsert() { userMapper.insert(new UserEntity(\"laowang\", \"123456\", \"老王\")); Assert.assertEquals(1, userMapper.getAll().size()); }} 总结通过本文我们知道 MyBatis 是一个优秀和灵活的数据持久化框架，MyBatis 包含 Mapper 配置、Mapper 接口、Executor、SqlSession、SqlSessionFactory 等几个重要的组件，知道了 MyBatis 基本流程：MyBatis 首先加载 Mapper 配置和 SQL 映射文件，通过创建会话工厂得到 SqlSession 对象，再执行 SQL 语句并返回操作信息。我们也使用 XML 的方式，实现了 MyBatis 对数据库的基础操作。","categories":[{"name":"面试专题","slug":"面试专题","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Mybatis/"},{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Mapper","slug":"Mapper","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Mapper/"}]},{"title":"抽象类和接口的应用面试题","slug":"抽象类和接口的应用面试题","date":"2023-03-03T06:22:20.000Z","updated":"2023-03-03T06:23:48.618Z","comments":true,"path":"2023/03/03/chou-xiang-lei-he-jie-kou-de-ying-yong-mian-shi-ti/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/03/chou-xiang-lei-he-jie-kou-de-ying-yong-mian-shi-ti/","excerpt":"","text":"抽象类和接口的应用 + 面试题抽象类定义在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。简单来说，使用关键字 abstract 修饰的类就叫做抽象类。 抽象类使用示例代码，如下： 12345678910111213141516171819202122232425abstract class AbstractAnimal { public AbstractAnimal() { System.out.println(\"Init AbstractAnimal.\"); } static String name = \"AbstractAnimal\"; public abstract void eat(); public void run() { System.out.println(\"AbstractAnimal Run.\"); }}class Animal extends AbstractAnimal { public static void main(String[] args) { AbstractAnimal animal = new Animal(); animal.run(); System.out.println(animal.name); animal.eat(); } @Override public void eat() { System.out.println(\"Animal Eat.\"); }} 以上代码执行的结果： 123456Init AbstractAnimal.AbstractAnimal Run.AbstractAnimalAnimal Eat. 抽象方法使用 abstract 关键字修饰的方法叫做抽象方法，抽象方法仅有声明没有方法体。如下代码： 123public abstract void m(); 抽象类的特性 抽象类不能被初始化 抽象类可以有构造方法 抽象类的子类如果为普通类，则必须重写抽象类中的所有抽象方法 抽象类中的方法可以是抽象方法或普通方法 一个类中如果包含了一个抽象方法，这个类必须是抽象类 子类中的抽象方法不能与父类中的抽象方法同名 抽象方法不能为 private、static、final 等关键字修饰 抽象类中可以包含普通成员变量，访问类型可以任意指定，也可以使用静态变量（static） 接口定义接口（interface）是抽象类的延伸，它允许一个类可以实现多个接口，弥补了抽象类不能多继承的缺陷，接口是对类的描述，使用 interface 关键字来声明。 接口使用示例代码，如下： 123456789101112131415interface IAnimal { void run();}class AnimalImpl implements IAnimal { public static void main(String[] args) { IAnimal animal = new AnimalImpl(); animal.run(); } @Override public void run() { System.out.println(\"AnimalImpl Run.\"); }} Java 8 中接口的改动1）接口中增加了 default 方法和 static 方法，可以有方法体示例代码，如下： 1234567891011121314151617interface IAnimal { static void printSex() { System.out.println(\"Male Dog\"); } default void printAge() { System.out.println(\"18\"); }}class AnimalImpl implements IAnimal { public static void main(String[] args) { IAnimal.printSex(); IAnimal animal = new AnimalImpl(); animal.printAge(); }} 注意：static 方法属于接口方法，可以直接使用；default 属于实例方法，必须先创建实例。 2）接口中的静态变量会被继承示例代码，如下： 1234567891011121314interface IAnimal { static String animalName = \"Animal Name\"; static void printSex() { System.out.println(\"Male Dog\"); }}class AnimalImpl implements IAnimal { public static void main(String[] args) { System.out.println(animalName); IAnimal.printSex(); }} 注意：静态变量会被继承，静态方法不会被继承。 3）新增函数式接口 函数式接口（Function Interface）是一个特殊的接口，使用 @FunctionInterface 注解声明，定义这种接口可以使用 Lambda 表达式直接调用。示例代码，如下： 12345678910111213141516171819@FunctionalInterfaceinterface IAnimal { static String animalName = \"Animal Name\"; static void printSex() { System.out.println(\"Male Dog\"); } default void printAge() { System.out.println(\"18\"); } void sayHi(String name);}class FunctionInterfaceTest { public static void main(String[] args) { IAnimal animal = name -&gt; System.out.println(name); animal.sayHi(\"WangWang\"); }} 注意：使用 @FunctionInterface&nbsp;声明的函数式接口，抽象方法必须有且仅有一个，但可以包含其他非抽象方法。 相关面试题1. 抽象类中能不能包含方法体？答：抽象类中可以包含方法体。抽象类的构成也可以完全是包含方法体的普通方法，只不过这样并不是抽象类最优的使用方式。 题目解析：包含了方法体的抽象类示例代码如下： 12345678910111213abstract class AbstractAnimal { public void run() { System.out.println(\"AbstractAnimal Run.\"); }}class Animal extends AbstractAnimal { public static void main(String[] args) { AbstractAnimal animal = new Animal(); animal.run(); }} 以上代码执行的结果是： AbstractAnimal Run. 2. 抽象类能不能被实例化？为什么？答：抽象类不能被实例化，因为抽象类和接口的设计就是用来规定子类行为特征的，就是让其他类来继承，是多态思想的一种设计体现，所以强制规定抽象类不能被实例化。 3. 抽象方法可以被 private 修饰吗？为什么？答：抽象方法不能使用 private 修饰，因为抽象方法就是要子类继承重写的，如果设置 private 则子类不能重写此抽象方法，这与抽象方法的设计理念相违背，所以不能被 private 修饰。 4. 添加以下哪个选项不会引起编译器报错？123456abstract class AbstractAnimal { static String animalName = \"AbstractAnimal\"; } A：protected abstract void eat();B： void eat();C：abstract void eat(){};D：animalName += “Cat”; 答：A 题目解析：选项 B 普通方法必须有方法体；选项 C 抽象方法不能有方法体；选项 D 变量赋值操作必须在方法内。 5. 以下关于抽象类和抽象方法说法正确的是？A：抽象类中的方法必须全部为抽象方法B： 抽象类中必须包含一个抽象方法C：抽象类中不能包含普通方法D：抽象类中的方法可以全部为普通方法（包含方法体） 答：D 题目解析：抽象类中可以没有方法或者全部为普通方法，都是允许的，如下代码所示： 12345678910111213abstract class AbstractAnimal { public void run() { System.out.println(\"AbstractAnimal Run.\"); }}class Animal extends AbstractAnimal { public static void main(String[] args) { AbstractAnimal animal = new Animal(); animal.run(); }} 程序执行的结果为：AbstractAnimal Run. 6. 接口和普通类有什么关系？答：在 Java 语言设计中，接口不是类，而是对类的一组需求描述，这些类必须要遵循接口描述的统一格式进行定义。 7. 接口能不能有方法体？答：JDK 8 之前接口不能有方法体，JDK 8 之后新增了 static 方法和 default 方法，可以包含方法体。 8. 执行以下代码会输出什么结果？1234567891011interface IAnimal { static String animalName = \"Animal Name\";}class AnimalImpl implements IAnimal { static String animalName = new String(\"Animal Name\"); public static void main(String[] args) { System.out.println(IAnimal.animalName == animalName); }} 答：执行的结果为 false。 题目解析：子类使用 new String… 重新创建了变量 animalName，又因为使用 == 进行内存地址比较，所以结果就是 false。 9. 抽象类和接口有什么区别？答：抽象类和接口的区别，主要分为以下几个部分。 默认方法 抽象类可以有默认方法的实现 JDK 8 之前接口不能有默认方法的实现，JDK 8 之后接口可以有默认方法的实现 继承方式 子类使用 extends 关键字来继承抽象类 子类使用 implements 关键字类实现接口 构造器 抽象类可以有构造器 接口不能有构造器 方法访问修饰符 抽象方法可以用 public / protected / default 等修饰符 接口默认是 public 访问修饰符，并且不能使用其他修饰符 多继承 一个子类只能继承一个抽象类 一个子类可以实现多个接口 10. 以下抽象方法描述正确的是？A：抽象方法可以是静态（static）的B：抽象方法可同时是本地方法（native）C：抽象方法可以被 synchronized 修饰D：以上都不是 答：D 题目解析：抽象方法需要被子类重写，而静态方法是无法被重写的，因此抽象方法不能被静态（static）修饰；本地方法是由本地代码实现的方法，而抽象方法没有实现，所以抽象方法不能同时是本地方法；synchronized 和方法的实现细节有关，而抽象方法不涉及实现细节，因此抽象方法不能被 synchronized 修饰。 总结抽象类和接口都是面向对象编程中多态的具体实现，在 Java 编程思想中占据着重要的地位，同时也是初级面试岗位必问的问题之一，但由于接口在 JDK 8 中的改动比较大，因而面试者在网上搜到的绝大数关于接口和抽象类区别的答案也是不准确的，这点需要面试者特别注意一下。","categories":[{"name":"面试专题","slug":"面试专题","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Java/"},{"name":"抽象类","slug":"抽象类","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"}]},{"title":"MySQL面试题汇总","slug":"MySQL面试题汇总","date":"2023-03-03T06:19:07.000Z","updated":"2023-03-05T11:11:15.005Z","comments":true,"path":"2023/03/03/mysql-mian-shi-ti-hui-zong/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/03/mysql-mian-shi-ti-hui-zong/","excerpt":"","text":"MySQL 面试题汇总[toc] 1. 说一下 MySQL 执行一条查询语句的内部执行过程？答：MySQL 执行一条查询的流程如下： 客户端先通过连接器连接到 MySQL 服务器； 连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器； 分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器； 优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好； 优化器执行完就进入执行器，执行器则开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。 2.MySQL 查询缓存有什么优缺点？答：MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。 3.MySQL 的常用引擎都有哪些？答：MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。 4. 常用的存储引擎 InnoDB 和 MyISAM 有什么区别？答：InnoDB 和 MyISAM 最大的区别是&nbsp;InnoDB 支持事务，而&nbsp;MyISAM 不支持事务，它们其他主要区别如下： InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复； InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁； InnoDB 支持外键，MyISAM 不支持外键； MyISAM 性能比&nbsp;InnoDB 高； MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好； InnoDB 主键查询性能高于 MyISAM。 5. 什么叫回表查询？答：普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。 6. 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？答：不是，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。 7. 一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？答：如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。 8. 什么是独立表空间和共享表空间？它们的区别是什么？答：共享表空间指的是数据库的所有表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，因此表依然很大，而独立表空间如果删除表就会清除空间。 9. 清空表的所有数据性能最好的语句是？A：delete from tB：delete tC：drop table tD：truncate table t 答：D 题目解析：truncate 清除表数据不会写日志，delete 要写日志，因此 truncate 的效率要高于 delete。 10. 唯一索引和普通索引哪个性能更好？答：唯一索引和普通索引的性能对比分为以下两种情况： 对于查询来说两者都是从索引树进行查询，性能几乎没有任何区别； 对于更新操作来说，因为唯一索引需要先将数据读取到内存，然后需要判断是否有冲突，因此比普通索引要多了判断操作，从而性能就比普通索引性能要低。 11.left join 和 right join 的区别是什么？答：left join 和 right join 的区别如下： left join（左联结），返回左表全部记录和右表联结字段相等的记录； right join（右联结），返回右表全部记录和左表联结字段相等的记录。 12. 什么是最左匹配原则？它的生效原则有哪些？答：最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，指的是索引以最左边为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)： where a=1 只使用了索引 a； where a=1 and b=2 只使用了索引 a,b； where a=1 and b=2 and c=3 使用 a,b,c； where b=1 or where c=1 不使用索引； where a=1 and c=3 只使用了索引 a； where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。 13. 以下 or 查询有什么问题吗？该如何优化？ select * from t where num=10 or num=20; 答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为： select * from t where num=10 union select * from t where num=20; 14. 事务是什么？它有什么特性？答：事务是一系列的数据库操作，是数据库应用的基本单位。 在 MySQL 中只有 InnoDB 引擎支持事务，它的四个特性如下： 原子性（Atomic），要么全部执行，要么全部不执行； 一致性（Consistency），事务的执行使得数据库从一种正确状态转化为另一种正确状态； 隔离性（Isolation），在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务； 持久性（Durability），事务提交后，其结果永久保存在数据库中。 15.MySQL 中有几种事务隔离级别？分别是什么？答：MySQL 中有四种事务隔离级别，分别是： read uncommited，未提交读，读到未提交数据； read committed，读已提交，也叫不可重复读，两次读取到的数据不一致； repetable read，可重复读； serializable，串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。 MySQL 默认使用&nbsp;repetable read 的事务隔离级别。 16. 如何设置 MySQL 的事务隔离级别？答：MySQL 事务隔离级别 mysql.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置： transaction-isolation = REPEATABLE-READ 可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。 17.MySQL 出现了中文乱码该如何解决？答：解决 MySQL 中文乱码的问题，可以设置全局编码或设置某个数据库或表的编码为 utf8。 设置全局编码： 12345set character_set_client='utf8';set character_set_connection='utf8';set character_set_results='utf8'; 设置数据库的编码： 123alter database db character set utf8; 设置表的编码： 123alter table t character set utf8; 18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？答：因为 B 树、Hash、红黑树或二叉树存在以下问题。 B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。 Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高。 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。 红黑树：树的高度随着数据量增加而增加，IO 代价高。 19.MySQL&nbsp;是如何处理死锁？答：MySQL 对待死锁常见的两种策略： 通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时； 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。 20. 什么是全局锁？它的应用场景有哪些？答：全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全量逻辑备份，这个时候整个库会处于完全的只读状态。 21. 使用全局锁会导致什么问题？答：使用全局锁会使整个系统不能执行更新操作，所有的更新业务会出于等待状态；如果你是在从库进行备份，则会导致主从同步严重延迟。 22.InnoDB 存储引擎有几种锁算法？答：InnoDB 的锁算法包括以下三种： Record Lock — 单个行记录上的锁； Gap Lock — 间隙锁，锁定一个范围，不包括记录本身； Next-Key Lock — 锁定一个范围，包括记录本身。 23.InnoDB 如何实现行锁？答：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁。使用 for update 来实现行锁，具体脚本如下： select * from t where id=1 for update 其中 id 字段必须有索引。 24.MySQL 性能指标都有哪些？如何得到这些指标？答：MySQL 最重要的性能指标有以下两个： QPS（Queries Per Second），每秒查询数，一台数据库每秒能够处理的查询次数； TPS（Transactions Per Second），每秒处理事务数。 这些性能指标可以通过 show status 来查询当前数据库状态的结果信息中估算出来，show status 会有 300 多条状态信息记录，其中以下这些信息 QPS 和 TPS 有关系： Uptime，服务器已经运行的时间，单位秒； Questions，已经发送给数据库查询数； Com_select，查询次数，实际查询次数； Com_insert，插入次数； Com_delete，删除次数； Com_update，更新次数； Com_commit，事务次数； Com_rollback，回滚次数。 25.MySQL 中的重要日志分为哪几个？① 错误日志：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为： mv hostname.err &nbsp;hostname.err.old mysqladmin flush-logs ② 查询日志：查询日志在 MySQL 中被称为 general log（通用日志），查询日志里的内容不要被 “查询日志” 误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下: insert 查询为了避免数据冲突，如果此前插入过数据，则当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错； update 时也会查询因为更新的时候很可能会更新某一块数据； delete 查询，只删除符合条件的数据； 因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。 查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，因此，可以根据自己的实际情况来决定是否开启查询日志。 查询日志模式是关闭的，可以通过以下命令开启查询日志： set global general_log=1 set global log_output=’table’; general_log=1 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。 ③ 慢日志：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句： set global slow_query_log=’ON’; 使用 set global slow_query_log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。因此如果要永久生效，就要修改配置文件 my.cnf，设置 slow_query_log=1 并重启 MySQL 服务器。 ④ redo log（重做日志）：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。 ⑤ undo log（回滚日志）：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。undo log 默认存放在共享表空间中，在 ySQL 5.6 中，undo log 的存放位置还可以通过变量 innodb_undo_directory 来自定义存放目录，默认值为 “.” 表示 datadir 目录。 ⑥ bin log（二进制日志）：是一个二进制文件，主要记录所有数据库表结构变更，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，bin log 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其他额外信息，但是它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句。 binlog 的作用如下： 恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复； 复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步； 审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。 除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。 binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。 通过以下命令来查询 binlog 是否开启： show variables like ‘log_%’; binlog 格式分为 STATEMENT、ROW 和 MIXED 三种。 STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，因此相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间，并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL，比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如，InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制。 ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，因此，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，因此可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等。 MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT_USER()、ROW_COUNT() 等无法确定的函数。 26.redo log&nbsp;和&nbsp;binlog&nbsp;有什么区别？redo log（重做日志）和 binlog（归档日志）都是&nbsp;MySQL&nbsp;的重要的日志，它们的区别如下： redo log 是物理日志，记录的是 “在某个数据页上做了什么修改”； binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 ID=2 这一行的 c 字段加 1”； redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用； redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的，“追加写” 是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，因此 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。 27. 慢查询日志的获取方式有哪些？答：慢查询日志的常见获取方式如下。 使用 MySQL 自带功能，开启慢查询日志，在 MySQL 的安装目录下找到 my.cnf 文件设置 slow-query-log=On 开启慢查询，慢查询默认时长为 10s，默认存储文件名为 host_name-slow.log。 使用三方开源方案 zabbix，zabbix 是一个基于 Web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案，能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位 / 解决存在的各种问题。 28. 如何定位慢查询？答：使用 MySQL 中的 explain 分析执行语句，比如： explain select * from t where id=5; 如下图所示： 其中： id — 选择标识符，id 越大优先级越高，越先被执行 select_type&nbsp;— 表示查询的类型。 table&nbsp;— 输出结果集的表 partitions&nbsp;— 匹配的分区 type&nbsp;— 表示表的连接类型 possible_keys&nbsp;— 表示查询时，可能使用的索引 key&nbsp;— 表示实际使用的索引 key_len&nbsp;— 索引字段的长度 ref—&nbsp; 列与索引的比较 rows&nbsp;— 大概估算的行数 filtered&nbsp;— 按表条件过滤的行百分比 Extra&nbsp;— 执行情况的描述和说明 其中最重要的就是 type 字段，type 值类型如下： all — 扫描全表数据 index — 遍历索引 range — 索引范围查找 index_subquery — 在子查询中使用 ref unique_subquery — 在子查询中使用 eq_ref ref_or_null — 对 null 进行索引的优化的 ref fulltext — 使用全文索引 ref — 使用非唯一索引查找数据 eq_ref — 在 join 查询中使用主键或唯一索引关联 const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点 29.MySQL 中常见的读写分离方案有哪些？答：MySQL 中常见的读写分离方案通常为以下两种： 使用 MySQL 官方提供的数据库代理产品 MySql ProxySQL 搭建自动分配的数据库读写分离环境； 在程序层面配置多数据源使用代码实现读写分离。 30. 怎样保证主备数据库无延迟？答：通常保证主备数据库无延迟有以下三种方法。 每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds_behind_master 参数是用来衡量主备延迟时间的长短。 对比位点确保主备无延迟。Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。 对比 GTID 集合确保主备无延迟。Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。 31. 什么是 MySQL 多实例，如何配置 MySQL 多实例？答：MySQL 多实例就是在同一台服务器上启用多个 MySQL 服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展。 多实例的配置方法有两种： 一个实例一个配置文件，不同端口； 同一配置文件（my.cnf）下配置不同实例，基于 MySQL 的 d_multi 工具。 32. 表的优化策略有哪些？「参考答案」常见的大表优化策略如下。 读写分离，主库负责写，从库负责读。 垂直分区，根据数据属性单独拆表甚至单独拆库。 水平分区，保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中。水平拆分只是解决了单一表数据过大的问题，表数据还在同一台机器上，对于并发能力没有什么意义，因此水平拆分最好分库。另外分片事务难以解决，跨节点 join 性能较差。 33. 数据库分片方案有哪些？「参考答案」数据库分片方案有哪些？ 答：数据库创建的分片方案有两种方式：客户端代理方式和中间件代理方式。 客户端代理 — 分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现，比如 Sharding-JDBC、阿里 TDDL 等。 中间件代理 — 在应用层和数据层中间加了一个代理层。分片逻辑统一维护在中间件服务中，比如 MyCat、网易的 DDB 都是中间件代理的典型代表。 34. 查询语句的优化方案有哪些？「参考答案」常见优化方案如下： 不做列运算，把计算都放入各个业务系统实现； 查询语句尽可能简单，大语句拆小语句，减少锁时间； 不使用 select * 查询； or 查询改写成 in 查询； 不用函数和触发器； 避免 %xx 查询； 少用 join 查询； 使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123； 尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描； 列表数据使用分页查询，每页数据量不要太大。 35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？「参考答案」可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下： 定期断开空闲的长连接； 如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql_reset_connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。","categories":[{"name":"面试专题","slug":"面试专题","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/MySQL/"}]},{"title":"Matery主题的配置","slug":"Matery主题的配置","date":"2023-03-03T05:18:24.000Z","updated":"2023-03-03T11:37:04.984Z","comments":true,"path":"2023/03/03/matery-zhu-ti-de-pei-zhi/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/03/matery-zhu-ti-de-pei-zhi/","excerpt":"","text":"本主题推荐你使用 Hexo 5.0.0 及以上的版本。如果，你已经有一个自己的 Hexo 博客了，建议你将 Hexo 升级到最新稳定的版本。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 git clone 命令来下载: 1git clone https://github.com/blinkfox/hexo-theme-matery.git 配置切换主题修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： 123456---title: categoriesdate: 2018-09-30 17:25:30type: \"categories\"layout: \"categories\"--- 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： 123456---title: tagsdate: 2018-09-30 18:23:38type: \"tags\"layout: \"tags\"--- 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： 123456---title: aboutdate: 2018-09-30 17:25:30type: \"about\"layout: \"about\"--- 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： 123456---title: contactdate: 2018-09-30 17:25:30type: \"contact\"layout: \"contact\"--- 注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： 123456---title: friendsdate: 2018-12-12 21:25:30type: \"friends\"layout: \"friends\"--- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： 12345678910111213141516171819[{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\"}, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\"}, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\"}] 新建 404 页如果在你的博客 source 目录下还没有 404.md 文件，那么你就需要新建一个 1hexo new page 404 编辑你刚刚新建的页面文件 /source/404/index.md，至少需要以下内容： 1234567---title: 404date: 2018-09-30 17:25:30type: \"404\"layout: \"404\"description: \"Oops～，我崩溃了！找不到你想要的页面 :(\"--- 菜单导航配置配置基本菜单导航的名称、路径url和图标icon.1.菜单导航名称可以是中文也可以是英文(如：Index或主页)2.图标icon 可以在Font Awesome 中查找 12345678910111213141516171819menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children) 在children下创建二级菜单的 名称name,路径url和图标icon. 注意每个二级菜单模块前要加 -. 注意缩进格式 12345678910111213141516171819202122232425262728293031323334menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Music url: /music icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 代码高亮从 Hexo5.0 版本开始自带了 prismjs 代码语法高亮的支持，本主题对此进行了改造支持。 如果你的博客中曾经安装过 hexo-prism-plugin 的插件，那么你须要执行 npm uninstall hexo-prism-plugin 来卸载掉它，否则生成的代码中会有 &amp;#123; 和 &amp;#125; 的转义字符。 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并将 prismjs.enable 的值设置为 true，主要配置如下： 123456789101112highlight: enable: false line_number: true auto_detect: false tab_replace: '' wrap: true hljs: falseprismjs: enable: true preprocess: true line_number: true tab_replace: '' 主题中默认的 prismjs 主题是 Tomorrow Night，如果你想定制自己的主题，可以前往 prismjs 下载页面 定制下载自己喜欢的主题 css 文件，然后将此 css 主题文件取名为 prism.css，替换掉 hexo-theme-matery 主题文件夹中的 source/libs/prism/prism.css 文件即可。 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： 1npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 中文链接转拼音（建议安装）如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： 1npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： 1npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： 1234567postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： 1npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后就可以在文章中对应位置看到你用emoji语法写的表情了。 添加 RSS 订阅支持（可选的）本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： 1npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 添加中文繁简转换在主题的 _config.yml 文件中，开启 translate 为 enable。 开启中文繁简转换如下修改。默认不开启。实例演示： 繁简转换 底下 footer 栏 12translate: enable: true 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： 12345&lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的）要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可： 1234567891011121314151617# 是否在首页显示音乐music: enable: true title: # 非吸底模式有效 enable: true show: 听听音乐 server: netease # require music platform: netease, tencent, kugou, xiami, baidu type: playlist # require song, playlist, album, search, artist id: 503838841 # require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐）， baidu（百度音乐）。 type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，playlist的id 即为这串数字。 添加note 演示 Usage123{% note [class] [no-icon] [summary] %}Any content (support inline tags too).{% endnote %} [class] : Optional parameter. Supported values: default | primary | success | info | warning | danger. [no-icon] : Optional parameter. Disable icon in note. [summary] : Optional parameter. Optional summary of the note. All parameters are optional. example1234{% note %}#### Header(without define class style){% endnote %} 添加button 演示 Usage1{% button url, text, icon [class], [title] %} or 1{% btn url, text, icon [class], [title] %} url : Absolute or relative path to URL. text : Button text. Required if no icon specified. icon : Font Awesome icon name. Required if no text specified. [class] : Optional parameter. Font Awesome class(es): fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5x [title] : Optional parameter. Tooltip at mouseover. Examples1{% button #, Text %} 文章 Front-matter 介绍Front-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 hide false 隐藏文章，如果hide值为true，则文章不会在首页显示 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例1234---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00--- 最全示例123456789101112131415161718---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- 效果截图 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方： 修改主题颜色在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： 123456789101112/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow { /* 动态切换背景颜色. */}@keyframes rainbow { /* 动态切换背景颜色. */} 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： 1$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 版本变更记录参见 CHANGELOG.md 更多部署方式 Jsdelivr 已经被封了，这两个可以加速访问快一点 vercel 部署cloudflare Pages 部署","categories":[{"name":"主题美化","slug":"主题美化","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"}],"tags":[{"name":"主题","slug":"主题","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E4%B8%BB%E9%A2%98/"},{"name":"美化","slug":"美化","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Hexo/"}]},{"title":"CentOS7安装与配置","slug":"CentOS7安装与配置","date":"2023-03-02T08:18:24.000Z","updated":"2023-03-03T13:30:29.573Z","comments":true,"path":"2023/03/02/centos7-an-zhuang-yu-pei-zhi/","link":"","permalink":"https://github.com/hasaki99/hasaki99.github.io/2023/03/02/centos7-an-zhuang-yu-pei-zhi/","excerpt":"","text":"CentOS7安装与配置1.安装比较简单，重点在配置磁盘 选择手动分区，一般选择LVM或Standard Partition(标准分区) 进入分区页面/boot分区默认1024M，swap分区为实际内存的1-2倍，除swap外其他分区系统文件类型选择ext4。 ！注意 (1)有的机器若有/boot/efi分区，那必须要配。 (2)在使用U盘安装系统的过程中若进入到到dracut界面，则是机器没有找到你的U盘。这个配置是需要在上一步需要完成的，但在上一步我们并不知道U盘的文件名，所以索性在这一步查看一下U盘的设备名具体命令为 cd /dev ;输入 blkid 查看块设备的文件系统类型、LABEL、UUID等信息,然后记下设备名 按Ctrl+Alt+Delete重启回到安装界面，然后再回到安装界面,按下e或Tab进入编辑模式，将vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso quiet 这一行改成vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4(设备名) quite，改完按下Ctrl+x或Enter执行,就可以正常安装CentOS系统了。 2.关闭selinux123vi /etc/selinux/configSELINUX=disabledreboot 3.优化ulimit修改/etc/security/limits.conf 加入以下两行,reboot重启生效 12soft nofile 32768hard nofile 65536 4.配置网卡ip addr查看网卡信息，由于CentOS mini安装没有net-tools工具包，不能使用ifconfig 查看地址，使用 yum install -y net-tools（yum install net-tools.x86_64）可以安装 编辑网卡配置文件#vi /etc/sysconfig/network-scripts/ifcfg-enxxx（网卡名称） 123456789BOOTPROTO=noneNAME=enp7s0DEVICE=enp7s0ONBOOT=yesIPADDR=10.10.1.112GATEWAY=10.10.1.254DNS1=114.114.114.114DNS2=8.8.8.8PREFIX=24 配置完成后执行service network restart或者/etc/init.d/network restart 来重启网络 5.常用命令shutdown -h now 关闭系统 /halt 关闭系统 poweroff /关闭系统 shutdown -r now 重启 / reboot 重启 查看防火墙状态:systemctl status firewalldsystemctl stop firewalldsystemctl disable firewalld查看防火墙是否关闭状态:systemctl is-enabled firewalld 修改主机名称:vim /etc/hostname 配置主机名称映射:vim /etc/hosts 重启网卡/etc/init.d/network restart ls -a 列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来ls -l (简写ll) 显示文件和目录的详细资料 mkdir命令：创建 mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录 rm命令：删除 rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ （空目录才能删除）rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv命令：该命令用于移动文件、目录或更名，move之意，它的常用参数如下：-f 如果目标文件已经存在，不会询问而直接覆盖 mv file1 file2 把文件file1重命名为file2 mv file1 file2 dir 把文件file1、file2移动到目录dir中 cp命令：该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下， 它的常用参数如下： cp -a file1 file2 连同文件的所有特性把文件file1复制成文件file2cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录 find命令：find是一个基于查找的功能非常强大的命令 find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 ps命令：该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下： -A ：所有的进程均显示出来-a ：不与terminal有关的所有进程-u ：有效用户的相关进程-x ：一般与a参数一起使用，可列出较完整的信息-l ：较长，较详细地将PID的信息列出其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下： ps aux 查看系统所有的进程数据ps ax 查看不与terminal有关的所有进程ps -lA 查看系统所有的进程数据ps axjf 查看连同一部分进程树状态 kill命令：该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下： kill -signal PIDsignal的常用参数如下：注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。 1：SIGHUP，启动被终止的进程2：SIGINT，相当于输入ctrl+c，中断一个程序的进行9：SIGKILL，强制中断一个进程的进行15：SIGTERM，以正常的结束进程方式来终止进程17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行例如： # 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程kill -SIGTERM %1# 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得kill -SIGHUP PID tar命令：该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下： 压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 查询：tar -jtv -f filename.tar.bz2 解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 chmod命令：该命令用于改变文件的权限，一般的用法如下： chmod -R 777 chmod -R 777 意思就是将当前目录及目录下所有文件都给予777权限（所有权限） 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 6.还是命令(更全)Linux常用命令大全（非常全！！！） 最近都在和Linux打交道，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。我将我了解到的命令列举一下，仅供大家参考： 系统信息arch 显示机器的处理器架构uname -m 显示机器的处理器架构uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统init 0 关闭系统telinit 0 关闭系统shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启reboot 重启logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构lstree 显示文件和目录由根目录开始的树形结构mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录 cp -r dir1 dir2 复制一个目录及子目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统fdformat -n /dev/fd0 格式化一个软盘mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统swapon /dev/hda3 启用一个新的swap文件系统swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav –delete /home /tmp 同步两边的目录rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name ‘.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find /var/log -name ‘.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置ifup eth0 启用一个 ‘eth0’ 网络设备ifdown eth0 禁用一个 ‘eth0’ 网络设备ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)dhclient eth0 以dhcp模式启用 ‘eth0’route -n show routing tableroute add -net 0/0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’route del 0/0 gw IP_gateway remove static routeecho “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routinghostname show hostname of systemhost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversaip link show show link status of all interfacesmii-tool eth0 show link status of ‘eth0’ethtool eth0 show statistics of network card ‘eth0’netstat -tup show all active network connections and their PIDnetstat -tupl show all network services listening on the system and their PIDtcpdump tcp port 80 show all HTTP trafficiwlist scan show wireless networksiwconfig eth1 show configuration of a wireless network cardhostname show hostnamehost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversawhois www.example.com lookup on Whois database JPS工具 jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。 我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。 使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。 jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path. $&gt; jps23991 Jps23789 BossMain23651 Resin 比较常用的参数： -q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数$&gt; jps -q286802378923651 -m 输出传递给main 方法的参数，在嵌入式jvm上可能是null $&gt; jps -m28715 Jps -m23789 BossMain23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log -l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名 $&gt; jps -l28729 sun.tools.jps.Jps23789 com.asiainfo.aimc.bossbi.BossMain23651 com.caucho.server.resin.Resin -v 输出传递给JVM的参数 $&gt; jps -v23789 BossMain28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl - Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl sudo jps看到的进程数量最全 jps 192.168.0.77 列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099 （前提是远程服务器提供jstatd服务） 注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。 安装Srun 4000系统1.安装srun4k获取srun4k包 解压到根目录 / 1234cd /tar -zxvf srun4_centos7_xxxxx.tgzcd /srun3./install &gt; ./install.log 2.卸载srun4k12cd /srun3./uninstall 3.相关命令123456789101112131415161718192021222324/srun3/bin/srun3d status # 服务状态/srun3/bin/srun3d start # 服务启动/srun3/bin/srun3d restart # 服务重启/srun3/bin/srun3d stop # 服务关闭/srun3/bin/rad_auth -v #查看内核版本号及server id/srun3/bin/server_aaa restart/srun3/bin/server_portal restart/srun3/bin/server_httpd restart/etc/init.d/srun3kauth restart #修改Portal页面后执行命令/srun3/bin/server_bas start #单独启动DPDK网关/srun3/www/Srun4k-webcron-install_v1.1.3.bin #srun4k开启定时任务8000netstat -tupln | grep nginx #查看nginx端口route #显示和操作 IP 路由表。routel #以好看的输出格式列出路由#抓包相关tcpdump -i any -u udp-w /root/xxx.pcap tcpdump -i eth0 port 1812 or 1813 or 3799 or 2000 -w/na.capkillall srun_portal_server;/srun3/bin/srun_portal_server -dkillall rad_dm;/srun3/bin/rad_dm -dkillall radiusd;/srun3/radius/sbin/radiusd -X &gt;/radius.txt &amp;ss -tnl #查看主机监听的tcp端口信息/srun3/bin/ldap_test -s -u 用户名 #ldap测试用户名修改Portal页面后执行命令 /etc/init.d/srun3kauth restart ss详情 ss 是 Socket Statistics 的缩写。ss 命令可以用来获取 socket 统计信息，它显示的内容和 netstat 类似。但 ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，而且比 netstat 更快。当服务器的 socket 连接数量变得非常大时，无论是使用 netstat 命令还是直接 cat /proc/net/tcp，执行速度都会很慢。ss 命令利用到了 TCP 协议栈中 tcp_diag。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，因此 ss 命令的性能会好很多。 12345678910-h, --help 帮助-V, --version 显示版本号-t, --tcp 显示 TCP 协议的 sockets-u, --udp 显示 UDP 协议的 sockets-x, --unix 显示 unix domain sockets，与 -f 选项相同-n, --numeric 不解析服务的名称，如 \"22\" 端口不会显示成 \"ssh\"-l, --listening 只显示处于监听状态的端口-p, --processes 显示监听端口的进程(Ubuntu 上需要 sudo)-a, --all 对 TCP 协议来说，既包含监听的端口，也包含建立的连接-r, --resolve 把 IP 解释为域名，把端口号解释为协议名称","categories":[{"name":"系统运维","slug":"系统运维","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Linux/"}]}],"categories":[{"name":"面试专题","slug":"面试专题","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"},{"name":"主题美化","slug":"主题美化","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"},{"name":"系统运维","slug":"系统运维","permalink":"https://github.com/hasaki99/hasaki99.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Mybatis/"},{"name":"面试","slug":"面试","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Mapper","slug":"Mapper","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Mapper/"},{"name":"Java","slug":"Java","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Java/"},{"name":"抽象类","slug":"抽象类","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"MySQL","slug":"MySQL","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/MySQL/"},{"name":"主题","slug":"主题","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E4%B8%BB%E9%A2%98/"},{"name":"美化","slug":"美化","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Hexo/"},{"name":"Centos","slug":"Centos","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/hasaki99/hasaki99.github.io/tags/Linux/"}]}