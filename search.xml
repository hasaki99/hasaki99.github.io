<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CentOS7同步系统时间为网络时间</title>
      <link href="/2023/03/28/centos7-tong-bu-xi-tong-shi-jian-wei-wang-luo-shi-jian/"/>
      <url>/2023/03/28/centos7-tong-bu-xi-tong-shi-jian-wei-wang-luo-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7同步系统时间为网络时间"><a href="#CentOS7同步系统时间为网络时间" class="headerlink" title="CentOS7同步系统时间为网络时间"></a>CentOS7同步系统时间为网络时间</h1><ul><li>linux系统时间，与本地时间不一致，一般有两种情况</li><li>一是时区设置错误，不是当地使用时区</li><li>二是时间设置错误，未联网校时，或者人为不小心设置错了</li></ul><h3 id="处理时区问题"><a href="#处理时区问题" class="headerlink" title="处理时区问题"></a>处理时区问题</h3><p><strong>date查看时间、时区</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">date</span>  <span class="token comment">#查看日期时间</span><span class="token function">date</span> <span class="token parameter variable">-R</span>   <span class="token comment">#会把时区一起显示出来</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>timedatectl查看时间、时区</strong></p><p>也可以使用<code>timedatectl</code>查看和设置时区</p><ul><li>Local time：当前使用的时区的时间，也就是<code>date</code>命令显示的时间</li><li>Universal time：世界时间，也就是0时区时间，世界通用的协调时间</li><li>RTC time：硬件时钟时间，关机也会</li><li>Time zone：现正使用的时区，可以看到上面是<code>CST</code>，中国时区，是对的</li></ul><p><strong>查看localtime</strong></p><ul><li>也可以直接使用<code>ls -l /etc/localtime</code>查看系统当前的时区</li></ul><p><strong>设置时区</strong></p><ul><li>第一种方式，可以通过<code>zoneinfo</code>直接设置</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第二种方式，与第一种类似，使用软连接</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> <span class="token parameter variable">-sf</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第三种方式，使用<code>timedatectl</code>设置时区</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">timedatectl set-timezone Asia/Shanghai<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="处理时间问题"><a href="#处理时间问题" class="headerlink" title="处理时间问题"></a>处理时间问题</h3><ul><li>如果时区已经设置对了，时间显示还是不对，可以手动设置下时间，或者使用互联网校时</li><li>需要安装<code>ntpdate</code>，再校时即可，但是需要在联网情况下进行</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> ntp ntpdate  <span class="token comment">#下载ntpdate工具</span>ntpdate ntp.aliyun.com   <span class="token comment">#同步阿里云时间</span><span class="token function">date</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果没有联网，只能直接使用<code>date -s 日期 时间</code>设置了</li><li>时间显示正确后，查看下硬件时间，顺便把硬件时间也改对，防止重启失效</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hwclock <span class="token parameter variable">--show</span><span class="token comment"># hwclock代表硬件时间，systohc代表系统时间，即用系统时钟同步硬件时钟</span>hwclock <span class="token parameter variable">--systohc</span>  <span class="token comment">## 或   </span>clock <span class="token parameter variable">--systohc</span>  hwclock <span class="token parameter variable">-w</span><span class="token function">date</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>计划任务</strong></p><p>若有将时间同步写入计划任务的需求，就写入crontab</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment">#  crontab -e             </span><span class="token number">59</span> <span class="token number">23</span> * * * ntpdate ntp.aliyun.com<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># crontab -l        #查看计划任务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Radius和Portal</title>
      <link href="/2023/03/14/radius-he-portal/"/>
      <url>/2023/03/14/radius-he-portal/</url>
      
        <content type="html"><![CDATA[<h1 id="一-RADIUS-基本概念"><a href="#一-RADIUS-基本概念" class="headerlink" title="一.RADIUS 基本概念"></a>一.RADIUS 基本概念</h1><h2 id="Radius-与-Radius-："><a href="#Radius-与-Radius-：" class="headerlink" title="Radius 与 Radius+："></a>Radius 与 Radius+：</h2><p>​Radius：目前互联网应用中比较流行的用户验证、授权、计费协议。RFC2865/2866/2869定义了标准radius协议的所有规范。</p><p>​Radius+：各通信设备厂家分别对应于原标准radius协议所未定义到的新应用自行开发定义了一套扩展的radius协议报文和属性，成为radius+协议。</p><p>​采用 UDP 封包为传输协议，标准认证 port 为1812、计费 port 为1813，原来旧式 RADIUS 标准的传输 port 为1645与1646。（现已经基本不用）</p><h2 id="基-本-概-念"><a href="#基-本-概-念" class="headerlink" title="基 本 概 念"></a>基 本 概 念</h2><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">AAA Authentication、Authorization、Accounting验证、授权、记费PAP Password Authentication Protocol口令验证协议CHAP Challenge-Handshake Authentication Protocol盘问握手验证协议NAS Network Access Server网络接入服务器BAS(Broadband Access Server）宽带接入服务器BRAS(Broadband Remote Access Server) 宽带远程接入服务器（新一代接入服务器的称呼）RADIUS Remote Authentication Dial In User Service远程验证拨入用户服务（拨入用户的远程验证服务）TCP Transmission Control Protocol传输控制协议UDP User Datagram Protocol用户数据报协议<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Radius-常用加密方式"><a href="#Radius-常用加密方式" class="headerlink" title="Radius 常用加密方式"></a>Radius 常用加密方式</h2><ul><li><p>PAP (Password Authentication Protocol) </p><p>直接送出密码明文到远程进行验证</p><p>实作容易，但不安全 </p></li><li><p>CHAP (Challenge  Handshake Authentication Protocol) </p><p> 密码经过加密后送到远程进行验证 </p><p>实作容易，但账号系统必须支持明码密码 </p><p>比 PAP 安全一些 </p></li><li><p>EAP (Extensible Authentication Protocol) </p><p>支持多种验证方式的认证协议 </p><p>支持较高等级的加密方式 </p><p>用户必须使用特殊的认证客户端软件 </p><p>相关网络硬件必须支持  EAP </p><p>使用上比较不方便，但是安全性高</p></li></ul><h2 id="RADIUS-角色"><a href="#RADIUS-角色" class="headerlink" title="RADIUS 角色"></a>RADIUS 角色</h2><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230314161956005.png" alt="Radius角色"></p><h2 id="NAS认证拓扑图"><a href="#NAS认证拓扑图" class="headerlink" title="NAS认证拓扑图"></a>NAS认证拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230314162058832.png" alt="PPPOE拨号流程"></p><p>​</p><h2 id="RADIUS协议属性"><a href="#RADIUS协议属性" class="headerlink" title="RADIUS协议属性"></a><strong>RADIUS</strong>协议属性</h2><table><thead><tr><th align="left">属性值</th><th>属性名称</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">1</td><td>User-Name</td><td align="left">用户名</td></tr><tr><td align="left">2</td><td>User-Password</td><td align="left">用户密码</td></tr><tr><td align="left">3</td><td>Chap-Password</td><td align="left">Chap认证方式中的用户密码</td></tr><tr><td align="left">4</td><td>Nas-IP-Address</td><td align="left">Nas的ip地址</td></tr><tr><td align="left">5</td><td>Nas-Port</td><td align="left">用户接入端口号</td></tr><tr><td align="left">6</td><td>Service-Type</td><td align="left">服务类型</td></tr><tr><td align="left">7</td><td>Framed-Protocol</td><td align="left">协议类型</td></tr><tr><td align="left">8</td><td>Framed-IP-Address</td><td align="left">为用户提供的IP地址</td></tr><tr><td align="left">9</td><td>Framed-IP-NetMask</td><td align="left">地址掩码</td></tr><tr><td align="left">10</td><td>Framed-Routing</td><td align="left">为路由器用户设置的路由方式</td></tr><tr><td align="left">11</td><td>Filter-Id</td><td align="left">过滤表的名称</td></tr><tr><td align="left">12</td><td>Framed-MTU</td><td align="left">为用户配置的最大传输单元</td></tr><tr><td align="left">13</td><td>Framed-Compression</td><td align="left">该连接使用压缩协议</td></tr><tr><td align="left">14</td><td>Login-IP-Host</td><td align="left">对login用户提供的可连接主机的ip地址</td></tr><tr><td align="left">15</td><td>Login-Service</td><td align="left">对login用户可提供的服务</td></tr><tr><td align="left">16</td><td>Login-TCP-Port</td><td align="left">TCP服务端口</td></tr><tr><td align="left">17</td><td>Reply-Message</td><td align="left">认证服务器返回用户的信息</td></tr><tr><td align="left">18</td><td>State</td><td align="left">认证服务器发送challenge包时传送的需在接下来的认证报文中回应的字符串（与Acess-Challenge相关的属性）</td></tr><tr><td align="left">19</td><td>Class</td><td align="left">认证通过时认证服务器返回的字符串信息，要求在该用户的计费报文中送给计费服务器</td></tr><tr><td align="left">20</td><td>Vendor-Specific</td><td align="left">可扩展属性</td></tr><tr><td align="left">21</td><td>Session-Timeout</td><td align="left">在认证通过报文或Challenge报文中，通知NAS该用户可用的会话时长 （时长预付费）</td></tr><tr><td align="left">22</td><td>Idle-Timeout</td><td align="left">允许用户空闲在线的最大时长</td></tr><tr><td align="left">23</td><td>NAS-Identifier</td><td align="left">标识NAS的字符串</td></tr><tr><td align="left">24</td><td>Proxy-State</td><td align="left">NAS通过代理服务器转发认证报文时服务器添加在报文中的属性</td></tr><tr><td align="left">25</td><td>Chap-Challenge</td><td align="left">可以代替认证字字段传送</td></tr><tr><td align="left">26</td><td>Nas-Port-Type</td><td align="left">接入端口的类型</td></tr><tr><td align="left">27</td><td>Port-Limit</td><td align="left">服务器限制NAS为用户开放的端口数</td></tr><tr><td align="left">28</td><td>Acct-Status-Type</td><td align="left">计费请求报文的类型</td></tr><tr><td align="left">29</td><td>Acct-Delay-Time</td><td align="left">Radius客户端发送计费报文耗费的时间</td></tr><tr><td align="left">30</td><td>Acct-Input-Octets</td><td align="left">输入字节数</td></tr><tr><td align="left">32</td><td>Acct-Output-Octets</td><td align="left">输出字节数</td></tr><tr><td align="left">33</td><td>Acct-Session-Id</td><td align="left">计费会话标识</td></tr><tr><td align="left">34</td><td>Acct-Authentic</td><td align="left">在计费包中标识用户认证通过的方式</td></tr><tr><td align="left">35</td><td>Acct-Session-Time</td><td align="left">用户在线时长</td></tr><tr><td align="left">36</td><td>Acct-Input-Packets</td><td align="left">输入包数</td></tr><tr><td align="left">37</td><td>Acct-Output-Packets</td><td align="left">输出包数</td></tr><tr><td align="left">38</td><td>Acct-Terminate-Case</td><td align="left">用户下线原因</td></tr><tr><td align="left">39</td><td>Acct-Multi_Session-Id</td><td align="left">相关计费会话标识</td></tr><tr><td align="left">40</td><td>Acct-Link-Count</td><td align="left">生成计费记录时多连接会话的会话个数</td></tr></tbody></table><h2 id="查看radius报文"><a href="#查看radius报文" class="headerlink" title="查看radius报文"></a>查看radius报文</h2><p>使radius认证服务工作在调试模式<br>1、使用root 用户登录<br>2、/srun3/radius/sbin/radius –x<br>     -x参数表示radius认证服务工作在调试模式，所有的报文用户均可以看到<br>3、系统默认不采用调试模式（调试模式是单线程工作，性能会收到影响），工作在后台模式下</p><h2 id="Radius基本报文种类"><a href="#Radius基本报文种类" class="headerlink" title="Radius基本报文种类"></a>Radius基本报文种类</h2><table><thead><tr><th><strong>code</strong></th><th><strong>报文类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>1</td><td>Access-Request</td><td>认证请求报文</td></tr><tr><td>2</td><td>Access-Accept</td><td>认证响应报文</td></tr><tr><td>3</td><td>Access-Reject</td><td>认证拒绝报文</td></tr><tr><td>4</td><td>Accounting-Request</td><td>计费请求报文</td></tr><tr><td>5</td><td>Accounting-Response</td><td>计费响应报文</td></tr></tbody></table><h3 id="计费报文类型"><a href="#计费报文类型" class="headerlink" title="计费报文类型"></a>计费报文类型</h3><p>Code＝4  Accounting-Request</p><p>Accounting-Request 报文中的三种状态类型（Acct-Status-Type）：</p><p>1）Start（Value=1）：Client开始对指定用户提供服务，记帐开始。</p><p>2）Stop（Value=2）：Client停止对指定用户提供服务，记帐结束。</p><p>3）Interim-Update（Value=3）：中途上报流量信息，实时记帐。</p><p>Code＝5  Accounting-Response</p><h3 id="Radius授权报文"><a href="#Radius授权报文" class="headerlink" title="Radius授权报文"></a>Radius授权报文</h3><p>CoA:（Change of Authorization）是指用户认证成功后，管理员可以通过RADIUS协议来修改在线用户的权限。</p><p>DM:（Disconnect Message）是指用户离线报文，即由RADIUS服务器端主动发起的强迫用户下线的报文。</p><p>CoA和DM 端口一致，一般bras设备都是udp 3799</p><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230314164406359.png" alt="COA与DM"></p><table><thead><tr><th><strong>报文名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>CoA-Request</td><td>动态授权请求报文。当管理员需要更改某个在线用户的权限时（例如，管理员不希望用户访问某个网站），可以通过服务器发送一个动态授权请求报文给客户端，使客户端修改在线用户的权限。</td></tr><tr><td>CoA-ACK</td><td>动态授权请求接受报文。如果客户端成功更改了用户的权限，则客户端回应动态授权请求接受报文给服务器。</td></tr><tr><td>CoA-NAK</td><td>动态授权请求拒绝报文。如果客户端未成功更改用户的权限，则客户端回应动态授权请求拒绝报文给服务器。</td></tr><tr><td>DM-Request</td><td>用户离线请求报文。当管理员需要让某个在线的用户下线时，可以通过服务器发送一个用户离线请求报文给客户端，使客户端终结用户的连接。</td></tr><tr><td>DM-ACK</td><td>用户离线请求接受报文。如果客户端已经切断了用户的连接，则客户端回应用户离线请求接受报文给服务器。</td></tr><tr><td>DM-NAK</td><td>用户离线请求拒绝报文。如果客户端无法切断用户的连接，则客户端回应用户离线请求拒绝报文给服务器。</td></tr></tbody></table><h1 id="Portal协议"><a href="#Portal协议" class="headerlink" title="Portal协议"></a>Portal协议</h1><p>规定了采用Portal认证（或Web认证）时，PortalServer和BAS设备之间的报文格式和通信流程，协议支持PAP和CHAP两种认证方式。</p><p>（以下讲解portal v2.0协议,其中portal v2.0协议兼容portal v1.0协议的全部报文类型，同时较portal v1.0新增类型为0x08，0x09，0x0a三种报文类型。对于宽带工程师来说，此过程基本是透明的，因此大部分的内容只需了解即可。）</p><p>​Portal协议报文格式</p><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230314164617099.png" alt="Portal协议报文格式"></p><p>Ver字段是协议的版本号，长度为 1 字节，Ver = 0x02表示是portal V2.0的版本。</p><p>Pap/Chap字段定义此用户的认证方式，长度为 1 字节，只对Type值为 0x03 的认证请求报文（ REQ_AUTH ）有意义：</p><p>1）Chap方式认证－－－值为0x00；</p><p>2）Pap 方式认证－－－值为0x01；</p><p>UserIP字段为Portal用户的IP地址，长度为 4 字节，其值由PortalServer根据其获得的IP地址填写，在所有的报文中此字段都要有具体的值；</p><p>​</p><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230314165159632.png" alt="标准网络拓扑"></p><h2 id="Portal认证流程"><a href="#Portal认证流程" class="headerlink" title="Portal认证流程"></a>Portal认证流程</h2><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230314165250708.png" alt="Portal认证流程"></p><p>基本交互步骤如下：</p><p>  (1) 用户输入用户名和口令；</p><p>  (2) BRAS根据获取的用户名和口令，向radius 服务器发送认证请求包（access-request）。</p><p>  (3) radius 服务器将该用户信息与users 数据库信息进行对比分析，如果认证成功，则将用户的权限信息以认证响应包（access-accept）发送给BRAS；如果认证失败，则返回access-reject 响应包。</p><p>  (4) radius 客户端根据接收到的认证结果接入/拒绝用户。如果可以接入用户，则BRAS向radius 服务器发送计费开始请求包（accounting-request），status-type 取值为start；</p><p>  (5) radius 服务器返回计费开始响应包（accounting-response）；</p><p>  (6) BRAS向radius 服务器发送计费停止请求包（accounting-request），status-type 取值为stop；</p><p>  (7) radius 服务器返回计费结束响应包（accounting-response）。</p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> radius </tag>
            
            <tag> portal </tag>
            
            <tag> 认证计费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试之Java基础</title>
      <link href="/2023/03/08/mian-shi-zhi-java-ji-chu/"/>
      <url>/2023/03/08/mian-shi-zhi-java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="*基础语法 *"></a><em><strong>*基础语法 *</strong></em></h3><p><em><strong>*Q1：简单说说Java有哪些数据类型*</strong></em><br>答：①分为基本数据类型和引用数据类型。②基本数据类型包括：数值型（byte 1、short2、int4、long、float、double），<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E5%9E%8B&amp;spm=1001.2101.3001.7020">字符型</a>（char2）以及布尔型（boolean1）。除了基本类型外，其他数据类型都属于引用类型，包括类、接口、数组等。</p><p>面向对象</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">**面向对象就是**：把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同<span class="token punctuation">[</span>类对象<span class="token punctuation">]</span>抽象出其共性，形成类。类中的大多数数据，只能用本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。对象即为人对各种具体物体抽象后的一个概念，人们每天都要接触各种各样的对象，如手机就是一个对象。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em><strong>*Q2：*</strong></em><em><strong>*float number=3.4;*</strong></em><em><strong>*有没有问题？为什么？*</strong></em><br>答：有问题，因为3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于向下转型，可能会造成精度损失，所以必须进行强制类型转换，正确的写法是float number =(float)3.4;/ float number =3.4F;。</p><p><em><strong>*Q3：字符串拼接的方式以及效率？*</strong></em><br>答：①使用+直接拼接，String 是final对象，不会被修改，每次使用 +进行拼接都会创建新的对象，而不是改变原来的对象，效率低，是线程安全的。②使用StringBuffer可变字符串，效率较高，是线程安全的（StringBuffer的方法使用了synchronized关键字进行修饰）。③使用StringBuilder可变字符串，效率最高，但是线程不安全。</p><p><em><strong>*Q4：简述final，finally和finalize区别*</strong></em><br>答：①final可以修饰类，方法和变量，被final修饰的类不可继承，被final修饰的方法不可重写，被final修饰的变量引用不可更改，引用的内容可以更改。②finally用于try-catch代码块中，无论是否发生异常最后都将执行，作用是释放资源。③finalize是Object类的方法，在对象被垃圾回收之前将调用一次，一般用于资源的释放。</p><p><em><strong>*Q5：==和equals有什么区别？equals和hashCode有什么联系？*</strong></em><br>答：①如果是引用类型，==比较的是两个对象的引用是否完全相同，如果是基本类型，比较的是两个基本类型的数值是否相同。②如果没有重写的话，equals默认按照==进行比较，如果重写了equals()方法，则按照对应的比较规则比较。③两个对象如果相等，那么它们的hashCode值必须相等，但两个对象的hashCode值相等时，它们不一定相同。</p><p><em><strong>*Q6：Array和ArrayList的区别？*</strong></em><br>答：①Array长度在定义之后就不运行改变了，而ArrayList是长度可变的，可以自动扩容。②Array只能存储相同类型的数据，ArrayList可以存储不同类型的数据。③ArrayList提供了更多操作数据的方法。</p><p><em><strong>*Q7：&amp;和&amp;&amp;的区别？*</strong></em><br>答：①&amp;具有按位与和逻辑与两个功能。②&amp;&amp;作为逻辑与具有短路的特点，当前面的条件表达式为false时就不会进行后面条件表达式的判断，可以用来避免空指针异常。</p><p><em><strong>*Q8：简述JDK8的新特性*</strong></em><br>答：①接口中可以添加default修饰的非抽象方法，可以有方法体和内容。②可以使用lambda表达式，减少代码冗余。③函数式接口，使用@FunctionalInterface注解标明，该接口有且仅有一个抽象方法。④方法引用，可以直接引用已有Java类或对象的方法或构造器，进一步简化lambda表达式。⑤stream流，用于解决已有集合/<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">数组</a>类库的弊端，简化其操作，有foreach遍历、filter过滤、map映射、concat合并等功能。⑥增加日期相关的API。</p><p><em><strong>*Q9：Stream流了解吗？*</strong></em><br>答：①Stream流是JDK1.8的新特性，用于解决已有集合/数组类库的弊端，简化集合/数组的操作。②stream流的获取：集合：直接调用stream()方法获取；数组：使用静态方法Stream.of()/Arrays.stream()获取。③常用方法：forEach() 遍历；count() 统计个数；filter() 按条件过滤；limit() 取前面n个元素；skip() 跳过前面n个元素；map() 映射加工；concat() 合并stream流。④终结方法：foreach/count 调用终结方法后流不能继续使用；非终结方法：每次调用完返回一个新的stream对象，可以继续使用，支持链式编程。⑤收集stream流：把流转为Set集合 collect(Collections.toSet())；把流转为List集合 collect(Collections.toList())；把流转为Collection集合 collect(Collections.toCollection())；把流转为数组 toArray()。</p><h3 id="面向对象-10"><a href="#面向对象-10" class="headerlink" title="*面向对象 10*"></a><em><strong>*面向对象 10*</strong></em></h3><p><em><strong>*Q1：简述面向对象的特性*</strong></em><br>答：①封装：建议成员变量私有，然后提供公有的getter/setter方法来获取值/赋值，封装的核心思想是合理隐藏，合理暴露，可以提高安全性，实现代码的组件化。②继承：一种子类到父类的关系，是“is a”关系，可以提高代码的复用性，相同代码可写到父类，子类的功能更加强大，不仅得到了父类的功能，还有自己的功能。③多态：同一个类型的对象执行相同的行为，在不同的状态下表现出不同的特征。多态可以降低类之间的耦合度，右边对象可以实现组件化切换，业务功能随之改变，便于扩展和维护。</p><p><em><strong>*Q2：类和对象有什么区别？*</strong></em><br>答：类是一个抽象的概念，是具有相同特征的事物的描述，是对象的模板。对象是一个个具体的存在，是类的实例。</p><p><em><strong>*Q3：列举Object类的方法*</strong></em><br>答：①equals(Object obj)：判断其他对象是否与当前对象相等。②toString()：打印当前对象的字符串表示。③wait()：导致当前线程等待，等待其他线程唤醒，会释放锁。④notify()/notifyAll()：随机唤醒一个/全部线程。⑤hashCode()：返回当前对象的hashCode值。⑥finalize()：当垃圾回收器要回收对象前调用。⑦clone()：创建并返回对象的一个副本。</p><p><em><strong>*Q4：方法重载和方法重写的区别？*</strong></em><br>答：①方法重载是同一个类中具有不同参数列表的同名方法（无关返回值类型），方法重写是子类中具有和父类相同参数列表的同名方法，会覆盖父类原有的方法。②重载的返回值类型和权限修饰符，异常抛出类型没有要求，重写方法的返回值类型小于等于父类被重写方法的返回值类型，修饰符权限大于等于父类被重写方法权限修饰符，抛出的异常类型小于等于父类被重写方法抛出的异常类型。</p><p><em><strong>*Q5：接口和抽象类有什么区别？*</strong></em><br>答：①接口中只能定义public static final修饰的常量，抽象类中可以定义普通变量。②接口和抽象类都不能实例化，但接口没有构造器，抽象类有构造器。③接口可以多实现，抽象类只能单继承。④接口在JDK1.8之前只能定义public abstract修饰的方法，JDK1.8开始可以定义默认方法和静态方法，JDK1.9开始可以定义私有方法，抽象类中的方法没有限制。</p><p><em><strong>*Q6：什么时候应该使用接口，什么时候应该使用抽象类？*</strong></em><br>答：①如果知道某个类应该成为基类（在面向对象设计中，被定义为包含所有实体共性的class类型，被称为“基类”。），那么第一选择应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。②在接口和抽象类的选择上，必须遵守这样一个原则：行为模型应该总是通过接口而不是抽象类定义。通过抽象类建立行为模型会出现的问题：如果有一个抽象类Moblie，有两个继承它的类Mobile1和Moblie2，分别有自己的功能1和功能2，如果出现一个既有功能1又有功能2的新产品需求，由于Java不允许多继承就出现了问题，而如果是接口的话只需要同时实现两个接口即可。</p><p><em><strong>*Q7：内部类有什么作用？有哪些分类？*</strong></em><br>答：①内部类有更好的封装性，有更多的权限修饰符，封装性可以得到更多的控制。②静态内部类：由static修饰，属于类本身，只加载一次。类可以定义的成分静态内部类都可以定义，可以访问外部类的静态变量和方法，通过new 外部类.静态内部类构造器来创建对象。③成员内部类：属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可以访问外部类的所有内容，通过new 外部类构造器.new 成员内部类构造器来创建对象。④局部内部类：定义在方法、构造器、代码块、循环中。只能定义实例成员变量和实例方法，作用范围仅在局部代码块中。⑤匿名内部类：没有名字的局部内部类，可以简化代码，匿名内部类会立即创建一个匿名内部类的对象返回，对象类型相当于当前new的类的子类类型。<br><img src="file:///C:\Users\朱瑞云\AppData\Local\Temp\ksohtml19700\wps1.jpg" alt="img"></p><p><em><strong>*Q8：泛型和泛型擦除是什么？*</strong></em><br>答：①泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制允许程序在编译时检测非法的类型。②在编译阶段采用泛型时加上的类型参数，会被编译器在编译时去掉，这个过程就被称为类型擦除，因此泛型主要用于编译阶段，在编译后生成的Java字节代码文件中不包含泛型中的类型信息。</p><p><em><strong>*Q9：泛型标记的规范了解吗？*</strong></em><br>答：①E：值Element，在集合中使用，表示在集合中存放的元素。②T：指Type，表示Java类，包括基本的类以及自定义类。③K：指Key，表示键，例如Map集合中的Key。④V：指Value，表示值，例如Map集合中的Value。⑤N：指Number，表示数值类型。⑥？：表示不确定的Java类型。</p><p><em><strong>*Q10：泛型限定是什么？*</strong></em><br>答：①类型通配符使用？表示所有具体的参数类型，在使用泛型的时候，如果希望将类的继承关系加入泛型应用中就需要对泛型做限定，具体的泛型限定有对泛型上限的限定以及对泛型下限的限定。②对泛型上限的限定使用&lt;? extends T&gt;，它表示该通配符所代表的类型是T类的子类型或T接口的子接口。③对泛型下限的限定使用&lt;? super T&gt;，它表示该通配符所代表的类型是T类的父类型或T接口的父接口。</p><h3 id="异常-2"><a href="#异常-2" class="headerlink" title="*异常 2*"></a><em><strong>*异常 2*</strong></em></h3><p><em><strong>*Q1：异常有哪些分类？出现的原因是什么？*</strong></em><br>答：①Throwable是所有错误和异常的父类，Throwable分为Error和Exception。②Error指Java程序运行错误，出现Error通常是因为系统的内部错误或资源耗尽，Error不能在运行过程中被动态处理，如果程序运行中出现Error，系统只能记录错误的原因和安全终止。③Exception指Java程序运行异常，即运行中发生了不期望的情况，分为RuntimeException和CheckedException。RuntimeException指在Java虚拟机正常运行期间抛出的异常，可以被捕获并处理，例如空指针异常，数组越界等。CheckedException指编译阶段强制要求捕获并处理的异常，例如IO异常，SQL异常等。</p><p><em><strong>*Q2：有哪些异常处理方式？*</strong></em><br>答：①抛出异常：遇到异常不进行具体处理，而是将异常抛出给调用者，由调用者根据情况处理。抛出异常有2种形式，一种是throws，作用在方法上，一种是try……catch，作用在方法内。②使用try/catch进行异常的捕获处理，try中发生的异常会被catch代码块捕获，根据情况进行处理，如果有finally代码块无论是否发生异常都会执行，一般用于释放资源，JDK1.7开始可以将资源定义在try代码块中自动释放减少代码。</p><h3 id="集合-10"><a href="#集合-10" class="headerlink" title="*集合 10*"></a><em><strong>*集合 10*</strong></em></h3><p><em><strong>*Q1：简述一下集合主要有哪些类和接口，各自有什么特点*</strong></em><br>答：①主要有两个接口Collection和Map，其中Collection又包括List、Set和Queue。②List是有序的，主要包括ArrayList，LinkedList和Vector，ArrayList底层通过数组实现，线程不安全，Vector是线程安全的ArrayList，但效率较低，LinkedList底层通过双向链表实现，与ArrayList相比增删快查询慢。③Set是唯一且无序的，主要包括HashSet，LinkedHashSet和TreeSet。HashSet底层其实就是HashMap，利用了key来保证元素的唯一性。LinkedHashSet可以按照key的操作顺序排序，TreeSet支持按照默认或指定的排序规则排序。④Queue是队列结构，主要有ArrayBlockingQueue基于数组的阻塞队列、LinkedBlockingQueue基于链表的阻塞队列等。⑤Map以key-value键值对的形式存储元素，主要包括HashMap、LinkedHashMap和TreeMap。HashMap底层通过数组+链表/红黑树实现，LinkedHashMap可以按照key的操作顺序对集合排序，TreeMap可以按照默认或指定的排序规则对集合排序。</p><p><em><strong>*Q2：HashMap是线程安全的吗？*</strong></em><br>答：①HashMap是线程不安全的，可以使用ConcurrentHashMap保证线程安全。②ConcurrentHashMap基于减小锁粒度的思想，通过使用分段锁来实现线程安全，内部细分为很多Segment数据段，默认情况下为16个，对每个Segment的数据都单独进行加锁操作，Segment的个数为锁的并发度。ConcurrentHashMap是由Segment数组和HashEntry数组组成的，Segment继承了可重入锁，HashEntry用来存储键值对数据。③Segment的结构和HashMap类似，是数组和链表结构，每个Segment里面都包含一个HashEntry数组，每个HashEntry都是一个链表结构的数据要对其进行i修改必须先获得对应的Segment锁。④多线程下只要加入的数据hashCode映射的数据段不一样就可以做到并行的线程安全。</p><p><em><strong>*Q3：List、Set、Map有什么区别？*</strong></em><br>答：①List是有序、可重复、有索引的集合，继承了Collection集合全部功能 除了Collection的三种遍历方式外，可用索引遍历。②Set是无序，不可重复的集合，Set的实现类LinkedHashSet和TreeSet是有序的，LinkedHashSet可以按照元素插入的顺序排序，也可以按照元素操作的时间排序，TreeSet可以按照默认的比较规则或者自定义的比较规则排序。③Map是无序、以key-value的键值对形式存储元素的集合，键不可重复，值无要求，重复的键对应的值会覆盖之前的值。</p><p><em><strong>*Q4：HashSet是如何去重的？*</strong></em><br>答：①对于基本类型的包装类，可以直接按值进行比较。②对于引用数据类型，会先比较hashCode()返回值是否相同，如果不同则代表不是同一个对象，如果相同则继续比较equals()方法返回值是否相同，都相同说明是同一个对象。③如果希望内容相同的对象就代表对象相同，那么除了重写equals()方法还要重写hashCode()方法，因为内容相同的对象hashCode()值不一定相同，因为只有hashCode()和equals()都相同才说明是同一个对象。</p><p><em><strong>*Q5：HashMap和HashSet的底层是怎么实现的？*</strong></em><br>答：①JDK1.8之前，HashMap的底层是数组加链表实现。数组中的每个元素都是一个单链表，链表中的每个元素都是Entry的实现类Node的一个实例，Node包括4个属性：key、value、hash值和用于指向单链表下一个元素的next。②HashMap在查找数据时，根据hash值可以快速定位到数组的具体下标，然后对链表进行遍历查找数据的时间复杂度为O(n)。JDK1.8起对HashMap进行了优化，底层改为数组+链表或红黑树，当链表中的元素超过8个之后，HashMap会将链表结构转换未红黑树以提高查询效率，时间复杂度为O(logn)。②HashSet的底层是基于HashMap实现的，HashSet中的元素只是存放在了底层HashMap的key上， 而value使用一个static final的Object对象标识。因此HashSet 的实现比较简单，相关操作基本上都是直接调用底层HashMap的相关方法来完成的。</p><p><em><strong>*Q6：Collection和Collections有什么区别？*</strong></em><br>答：①Collection是一个集合接口，它包括List有序集合、Set无序集合、Queue队列等。②Collections则是Collection的一个工具类，为Collection类型的对象提供了很多方便的方法，例如addAll可以直接对Collection集合批量添加元素，shuffle可以随机打乱List集合的元素顺序，sort可以对List集合进行默认或按比较器进行排序。</p><p><em><strong>*Q7：迭代器是什么？*</strong></em><br>答：①迭代器实现了Iterator接口，是用于遍历Collection集合元素的一个指针。②主要有三个方法：通过iterator()获得集合的迭代器；通过hasNext()判断集合当中是否还有元素，如果有返回true，没有则返回false，初始时迭代器位于第一个元素之前；通过next()获取集合的下一个元素，并向后移动一个元素的单位。</p><p><em><strong>*Q8：在使用foreach循环遍历集合元素时能否添加或删除元素？*</strong></em><br>答：使用foreach循环遍历元素集合时不能修改或删除元素，通过java -c查看字节码可以发现foreach循环实际上是用Iterator迭代器实现的，如果进行添加或删除元素会抛出ConcurrentModificationException异常，因为添加或删除元素会改变modCount的值，modCount是集合类的一个成员变量，代表集合的修改次数，当modCount的值和预期的exceptedModCount值不一致时就会抛出ConcurrentModificationException异常。</p><p><em><strong>*Q9：Queue接口中的add()/offer()、remove()/poll()、element()/peek()方法有什么区别?*</strong></em><br>答：①add()和offer()都是向队列尾部插入一个元素，区别是当超出队列界限时，add方法会抛出异常，而offer()会返回false。②remove()和poll()都是从队列头部移除一个元素并返回，区别是队列为空时remove()方法会抛出异常，poll()方法则是返回null值。③element()和 peek() 都是用于查询队列头部的元素，区别时队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p><p><em><strong>*Q10：有哪些线程安全的集合类？*</strong></em><br>答：①Vector，是线程安全的ArrayList，底层用数组实现，通过synchronized修饰方法保证线程安全。②HashTable，是线程安全的HashMap，继承自Dictionary，通过synchronized修饰方法保证线程安全，性能较差。③ConcurentHashMap，线程安全的HashMap，通过分段锁实现线程安全，性能较好。</p><h3 id="多线程-34"><a href="#多线程-34" class="headerlink" title="*多线程 34*"></a><em><strong>*多线程 34*</strong></em></h3><p><em><strong>*Q1：创建线程有哪几种实现方式?分别有什么优缺点？*</strong></em><br>答：①继承Thread类，重写run()方法即可。优点是编码简单，缺点是不能继承其他类，功能单一。②实现Runnable接口，重写run()方法，并将该实现类作为参数传入Thread构造器。优点是可以继承其他类，避免了单继承的局限性；适合多个相同程序代码的线程共享一个资源（同一个线程任务对象可被包装成多个线程对象），实现解耦操作，代码和线程独立。缺点是实现相对复杂。③实现Callable接口，重写call()方法，并包装成FutureTask对象，再作为参数传入Thread构造器。优点是相比方式二可以获取返回值，缺点是实现复杂。④可以通过线程池创建。</p><p><em><strong>*Q2：线程有哪些状态？*</strong></em><br>答：①New：用new操作创建一个新线程，此时程序还未开始运行线程中的代码。②Runnable：调用start()方法后进入可运行状态。③Blocked：阻塞状态，内部锁（不是juc中的锁）获取失败时进入阻塞状态。④Waiting：等待其他线程唤醒时进入等待状态。⑤Timed Waiting：计时等待，带超时参数的方法，例如sleep(long time)。⑥Terminated：终止状态，线程正常运行完毕或被未捕获异常终止。</p><p><em><strong>*Q3：什么是线程安全问题，如何解决？*</strong></em><br>答：当多个线程对同一个共享变量进行操作时可能会产生的问题。解决方法：①使用内部锁synchronized，可以使用同步代码块，如果是实例方法可用this作为锁对象，如果是静态方法，可以用类.class作为锁，或者使用同步方法底层和同步代码块一样，如果是实例方法默认用this作为锁，如果是静态方法默认使用类.class。②使用java.util.concurrent包中的锁，例如ReentrantLock。</p><p><em><strong>*Q4：多线程不可见问题的原因和解决方式？*</strong></em><br>答：①不可见的原因是每个线程有自己的工作内存，线程都是从主内存拷贝共享变量的副本值。每个线程都是在自己的工作内存操作共享变量的。②解决方式：加锁：获得锁后线程会清空工作内存，从主内存拷贝共享变量最新的值成为副本，修改后刷新回主内存，再释放锁；使用volatile关键字：被volatile修饰的变量会通知其他线程之前读取到的值已失效，线程会加载最新值到自己的工作内存。</p><p><em><strong>*Q5：说一说volatile关键字的作用*</strong></em><br>答：①保证被修饰的变量对所有线程可见，在一个线程修改了变量的值后，新的值对于其他线程是可以立即获取的。②禁止指令重排序，被修饰的变量不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取volatile修饰的变量时总是会返回最新写入的值。③不会执行加锁操作，不会导致线程阻塞，主要适用于一个变量被多个线程共享，多个线程均可对这个变量执行赋值或读取的操作。④volatile可以严格保证变量的单次读写操作的原子性，但并不能保证像i++这种操作的原子性，因为i++在本质上是读、写两次操作。</p><p><em><strong>*Q6：说一说synchronized关键字的作用*</strong></em><br>答：①用于为Java对象、方法、代码块提供线程安全的操作，属于排它的悲观锁，也属于可重入锁。②被synchronized修饰的方法和代码块在同一时刻只能有一个线程访问，其他线程只有等待当前线程释放锁资源后才能访问。③Java中的每个对象都有一个monitor监视器对象，加锁就是在竞争monitor，对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的，对方是否加锁是通过一个标记位来判断的。</p><p><em><strong>*Q7：synchronized的内部都包括哪些区域？*</strong></em><br>答：synchronized内部包括6个不同的区域，每个区域的数据都代表锁的不同状态。①ContentionList：锁竞争队列，所有请求锁的线程都被放在竞争队列中。②EntryList：竞争候选列表，在锁竞争队列中有资格成为候选者来竞争锁资源的线程被移动到候选列表中。③WaitSet：等待集合，调用wait方法后阻塞的线程将被放在WaitSet。④OnDeck：竞争候选者，在同一时刻最多只有一个线程在竞争锁资源，该线程的状态被称为OnDeck。⑤Owner：竞争到锁资源的线程状态。⑥!Owner：释放锁后的状态。</p><p><em><strong>*Q8：简述synchronized的实现原理*</strong></em><br>答：①收到新的锁请求时首先自旋，如果通过自旋也没有获取锁资源，被放入ContentionList（该做法对于已经进入队列的线程是不公平的，体现了synchronized的不公平性）。②为了防止ContentionList尾部的元素被大量线程进行CAS访问影响性能，Owner线程会在是释放锁时将ContentionList的部分线程移动到EntryList并指定某个线程（一般是最先进入的）为OnDeck线程。Owner并没有将锁直接传递给OnDeck线程而是把锁竞争的权利交给他，该行为叫做竞争切换，牺牲了公平性但提高了性能。③获取到锁的OnDeck线程会变为Owner线程，未获取到的仍停留在EntryList中。④Owner线程在被wait阻塞后会进入WaitSet，直到某个时刻被唤醒再次进入EntryList。⑤ContentionList、EntryList、WaitSet中的线程均为阻塞状态。⑥当Owner线程执行完毕后会释放锁资源并变为!Owner状态。</p><p><em><strong>*Q9：JDK对synchronized做了哪些优化？*</strong></em><br>答：JDK1.6中引入了适应自旋、锁消除、锁粗化、轻量级锁以及偏向锁等以提高锁的效率。锁可以从偏向锁升级到轻量级锁，再升级到重量级锁，这种过程叫做锁膨胀。JDK1.6中默认开启了偏向锁和轻量级锁，可以通过-XX:UseBiasedLocking禁用偏向锁。</p><p><em><strong>*Q10：volatile和synchronized的区别？*</strong></em><br>答：①volatile只能修饰实例变量和类变量,而synchronized可以修饰方法以及代码块。②<br>volatile只能保证数据的可见性，但是不保证原子性，synchronized是一种排它机制，可以保证原子性。只有在特殊情况下才适合取代synchronized：对变量的写操作不依赖于当前值（例如i++），或者是单纯的变量赋值；该变量没有被包含在具有其他变量的不等式中，不同的volatile变量不能互相依赖，只有在状态真正独立于程序内的其它内容时才能使用volatile。③volatile是一种轻量级的同步机制，在访问volatile修饰的变量时并不会执行加锁操作，线程不会阻塞，使用synchronized加锁会阻塞线程。</p><p><em><strong>*Q11：讲一讲ReentrantLock*</strong></em><br>答：①ReentrantLock是Lock接口的实现类，是一个可重入式的独占锁，通过AQS实现。②支持公平锁与非公平锁，还提供了可响应中断锁（线程在等待锁的过程中可以根据需要取消对锁的请求，通过interrupt方法中断）、可轮询锁（通过tryLock获取锁，如果有可用锁返回true否则立即返回false）、定时锁（通过带long时间参数的tryLock方法获取锁，如果在给定时间内获取到可用锁且当前线程未被中断返回true，如果超过指定时间则返回false，如果获取锁时被终断则抛出异常并清除已终止状态）等避免死锁的方法。③通过lock和unlock方法显式地加锁和释放锁。</p><p><em><strong>*Q12：synchronized和ReentrantLock有哪些区别？*</strong></em><br>答：①synchronized是隐式锁，ReentrantLock是显式锁，使用时必须在finally代码块中进行释放锁的操作。②synchronized是非公平锁，ReentrantLock可以实现公平锁。③ReentrantLock可响应中断，可轮回，为处理锁提高了更多灵活性。④synchronized是一个关键字，是JVM级别，ReentrantLock是一个接口，是API级别。⑤synchronized采用悲观并发策略，ReentrantLock采用的是乐观并发策略，会先尝试以CAS方式获取锁。</p><p><em><strong>*Q13：Lock接口有哪些方法？*</strong></em><br>答：①lock()：给对象加锁。②tryLock()/tryLock(long time,TimeUnit unit)：尝试给对象加锁，成功返回true，可以无参也可以指定等待时间。③unlock()：释放锁，锁只能由持有者释放否则抛出异常。④newCondition()：创建条件对象，使用条件对象管理那些已经获得锁但不满足有效条件的线程，调用await()方法把线程进入等待集，调用sign()/signAll()解除阻塞。⑤lockInterruptibly()：如果当前线程未被中断则获取该锁。</p><p><em><strong>*Q14：Java中的锁有什么作用？有哪些分类？*</strong></em><br>答：①Java中的锁主要用于保障多并发情况下数据的一致性，线程必须先获取锁才能进行操作，可以保证数据的安全。②从乐观和悲观的角度可以分为乐观锁和悲观锁。③从获取资源的公平性可以分为公平锁和非公平锁。④从是否共享资源的角度可以分为共享锁和排它锁。⑤从锁的状态角度可分为偏向锁、轻量级锁和重量级锁。同时在JVM中还设计了自旋锁以更快地使用CPU资源。</p><p><em><strong>*Q15：讲一讲乐观锁和悲观锁*</strong></em><br>答：①乐观锁采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁。但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法，具体过程为：比较当前版本号与上一次的版本号，如果一致则更新，否则重复进行读、比较、写操作。Java中的乐观锁是基于CAS操作实现的，CAS是一种原子性操作，在对数据更新之前先比较当前值和传入的值是否一样，一样则更新否则直接返回失败状态。②悲观锁采用悲观的思想处理数据，每次读取数据时都认为别人会修改数据，所以每次都会上锁，其他线程将被阻塞。Java中的悲观锁基于AQS实现，该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到则会转为悲观锁。</p><p><em><strong>*Q16：讲一讲自旋锁*</strong></em><br>答：①自旋锁认为如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等待小段时间，在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核态的切换上导致锁时间消耗。②优点：减少CPU的上下文切换，对于占用锁时间非常短或锁竞争不激烈的代码块来说性能很高。③缺点：在持有锁的线程长时间占用锁或竞争过于激烈时，线程会长时间自旋浪费CPU资源，有复杂锁依赖的情况不适合使用自旋锁。</p><p><em><strong>*Q17：讲一讲公平锁与非公平锁*</strong></em><br>答：①公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先将锁分配给排队时间最长的线程。②非公平锁指在分配锁时不考虑线程排队等待的情况，直接尝试获取锁，获取不到锁就在排到队尾等待。③因为公平锁需要在多核情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。synchronized是非公平锁，ReentrantLock默认的lock方法也是非公平锁。</p><p><em><strong>*Q18：讲一讲读写锁*</strong></em><br>答：①Lock接口提供的锁是普通锁，为了提高性能Java提供了读写锁，读写锁分为读锁和写锁，读锁之间不互斥，读锁与写锁，写锁之间都互斥。②如果系统要求共享数据可以同时支持很多线程并发读，但不能支持很多线程并发写，那么读锁能大大提高效率。如果系统要求共享数据在同一时刻只能有一个线程在写，且写的过程中不能读，则需要使用写锁。③提高juc的locks包中ReadWriteLock的实现类ReentrantReadWriteLock的readLock()和writeLock()来分别获取读锁和写锁。</p><p><em><strong>*Q19：讲一讲共享锁与排它锁*</strong></em><br>答：①共享锁：允许多个线程同时获取该锁，并发访问共享资源，ReentrantReadWriteLock的读锁为共享锁的实现。②排它锁：也叫互斥锁 ，每次只允许有一个线程独占该锁，ReentrantLock为排它锁的实现。③排它锁是一种悲观的加锁策略，同一时刻只允许一个线程读取锁资源，限制了读操作的并发性，因为并发读线程并不会影响数据的一致性，因此共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><p><em><strong>*Q20：锁有哪些状态？*</strong></em><br>答：①无锁，偏向锁，轻量级锁和重量级锁。②重量级锁是基于操作系统互斥量实现的，会导致进程在用户态和内核态之间来回切换，开销较大，synchronized内部基于监视器实现，监视器基于底层操作系统实现，因此属于重量级锁，运行效率不高。JDK1.6后为了减少获取锁和释放锁带来的性能消耗提高性能，引入了轻量级锁和偏向锁。③轻量级锁是相对于重量级锁而言的，核心设计实在没有多线程竞争的前提下，减少重量级锁的使用来提高性能。适用于线程交替执行同步代码块的情况，如果同一时刻有多线程访问同一个锁，会导致轻量级锁膨胀成重量级锁。④偏向锁用于在某个线程获取某个锁后，消除这个线程锁重入的开销，看起来似乎是这个线程得到了锁的偏袒。偏向锁的主要目的是在同一个线程多次获取某个所的情况下尽量减少轻量级锁的执行路径，因为轻量级锁需要多次CAS操作，而偏向锁只需要切换ThreadID时执行一次CAS操作，提高效率。出现多线程竞争锁时，JVM会自动撤销偏向锁。偏向锁是进一步提高轻量级锁性能的。⑤随着锁竞争越来越严重，锁可能从偏向锁升级到轻量级锁再到重量级锁，但在Java中只会单向升级不会降级。</p><p><em><strong>*Q21：如何进行锁优化？*</strong></em><br>答：①减少锁持有的时间：只在有线程安全要求的程序上加锁来尽量减少同步代码块对锁的持有时间。②减小锁粒度：将单个耗时较多的锁操作拆分为多个耗时较少的锁操作来增加锁的并行度，减少同一个锁上的竞争。在减少锁的竞争后，偏向锁、轻量级锁的使用率才会提高，例如ConcurrentHashMap中的分段锁。③读分离：指根据不同的应用场景将锁的功能进行分离以应对不同的变化，最常见的锁分离思想就是读写锁，这样既保证了线程安全又提高了性能。④锁粗化：指为了保障性能，会要求尽可能将锁的操作细化以减少线程持有锁的时间，但如果锁分的太细反而会影响性能提升，这种情况下建议将关联性强的锁操作集中处理。⑤锁消除：注意代码规范，消除不必要的锁来提高性能。</p><p><em><strong>*Q22：线程池是什么？为什么需要线程池？*</strong></em><br>答：①在生产中为每一个任务创建一个线程存在一些缺陷，如果无限制地大量创建线程会消耗很多资源，影响系统稳定性和性能，产生内存溢出等问题。②线程池是管理一组同构工作线程的资源池，线程池与工作队列密切相关，工作队列中保存了所有需要等待执行的任务。工作线程的任务很简单，从工作队列获取任务，执行任务，返回线程池并等待下一次任务。③线程池通过重用现有的线程，可以在处理多个请求时分摊线程在创建和撤销过程中的开销，另一个好处是当请求到达时工作线程通常已经存在，不会出现等待线程而延迟的任务的执行，提高了响应性。通过调整线程池的大小，可以创建足够多的线程保持处理器处于忙碌状态，同时还可以防止线程过多导致内存资源耗尽。</p><p><em><strong>*Q23：创建线程池时，ThreadPoolExecutor构造器中都有哪些参数，有什么含义？*</strong></em><br>答：①corePoolSize： 线程池核心大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。②maximumPoolSize： 线程池最大大小，表示可同时活动的线程数量的上限。③keepAliveTime：存活时间，如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过基本大小时，这个线程将被终止。④unit： 存活时间的单位，可选的参数为TimeUnit枚举中的几个静态变量： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。⑤workQueue： 线程池所使用的阻塞队列。⑥thread factory：线程池使用的创建线程工厂方法，可省略，将使用默认工厂。⑦handler：所用的拒绝执行处理策略，可省略，将使用默认拒绝执行策略。</p><p><em><strong>*Q24：线程池的阻塞队列有哪些选择？*</strong></em><br>答：①ArrayBlockingQueue：基于数组的有界阻塞队列。②LinkedBlockingQueue：基于链表的有界阻塞队列。③PriorityBlockingQueue：支持优先级排序的无界阻塞队列。④DelayedWorkQueue：基于优先级队列的无界阻塞队列。⑤SynchronousQueue：队列内部仅允许容纳一个元素，用于控制互斥的阻塞队列。</p><p><em><strong>*Q25：线程池的拒绝执行策略有哪些选择?*</strong></em><br>答：①AbortPolicy()： 线程池默认的拒绝策略，抛出RejectedExecutionException异常。②CallerRunsPolicy(): 重试添加当前的任务，他会自动重复调用execute()方法。③DiscardOldestPolicy(): 抛弃旧的任务，加入新的任务。④DiscardPolicy(): 直接抛弃当前的任务。</p><p><em><strong>*Q26：创建线程池的方法有哪些？*</strong></em><br>答：可以通过Executors的静态工厂方法创建线程池，内部通过重载ThreadExecutorPool不同的构造器创建线程池。①newFixedThreadPool，创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化(如果某个线程由于发生了未预期的异常而结束，那么线程池会补充一个新的线程)。将线程池的核心大小和最大大小都设置为参数中指定的值，创建的线程不会超时，使用LinkedBlockingQueue。②newCachedThreadPool，创建一个可缓存的线程池，如果线程池的当前规模超过了处理器需求，那么将回收空闲的线程，而当需求增加时，可以添加新的线程，线程池的规模不存在任何限制。将线程池的最大大小设置为Integer.MAX_VALUE，而将核心大小设置为0，并将超时设为1分钟，使用SynchronousQueue，这种方法创建出的线程池可被无限扩展，并当需求降低时自动收缩。③newSingleThreadExecutor，一个单线程的Executor，创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来代替。确保依照任务在队列中的顺序来串行执行。将核心线程和最大线程数都设置为1，使用LinkedBlockingQueue。④newScheduledThreadPool，创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer，使用DelayedWorkQueue。</p><p><em><strong>*Q27：线程池的工作原理？*</strong></em><br>答：①线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。即使队列里面有任务，线程池也不会马上执行它们。②通过 execute(Runnable command)方法被添加到线程池，任务就是一个 Runnable类型的对象，任务的执行方法就是Runnable类型对象的run()方法。③如果workerCount&lt;corePoolSize，那么创建并启动一个线程执行新提交的任务。如果workerCount&gt;=corePoolSize，且线程池内的阻塞队列未满，那么将这个任务放入队列。如果workerCount&gt;=corePoolSize，且阻塞队列已满，若满足workerCount&lt;maximumPoolSize,那么还是要创建并启动一个线程执行新提交的任务。若阻塞队列已满，并且workerCount&gt;=maximumPoolSize，则根据 handler所指定的策略来处理此任务，默认的处理方式直接抛出异常。也就是处理任务的优先级为： 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。④当一个线程完成任务时，它会从队列中取下一个任务来执行。⑤当一个线程没有任务可执行，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize时，那么这个线程会被停用掉，所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</p><p><em><strong>*Q28：简述ExecutorService的生命周期*</strong></em><br>答：①ExecutorService的生命周期有3种状态：运行、关闭和已终止。②ExecutorService在初始创建时处于运行状态。③shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。在ExecutorService关闭后提交的任务将有“拒绝执行处理器REH”来处理，它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。④等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已终止。通常在调用awaitTermination后会理解调用shutdown，从而产生同步地关闭ExecutorService的效果。</p><p><em><strong>*Q29：什么是CAS？*</strong></em><br>答：①CAS指Compare And Swap，比较并交换。CAS(V,E,N)算法包括三个参数，V表示要更新的变量的值，E表示预期的值，N表示新值。在且仅在V的值和E相等时才会将V的值设置为N，如果不同则说明已经有其他线程做了更改，当前线程就什么也不做。最后CAS返回当前V的真实值。②CAS操作采用了乐观锁的思想，有多个线程同时使用CAS操作一个共享变量时只有一个线程会成功，失败的线程不会被挂起仅会被告知失败，并且允许再次尝试，或者放弃操作。基于这样的原理虽然CAS没有使用锁，也可以及时发现其他线程的操作进行适当地并发处理。</p><p><em><strong>*Q30：CAS有什么问题？（什么是ABA问题？）如何解决？*</strong></em><br>答：①CAS算法地实现有一个重要前提：需要取出内存中某时刻的数据，然后在下一刻进行比较、替换，但在这个时间差内数据可能已经发生了变化，导致ABA问题。②ABA问题指线程1从内存V位置取出A，这时线程2也从内存中取出A，并将其首先修改为B，接着又修改为A，这时线程1在进行CAS操作时会发现内存中数据仍是A，然后线程1操作成功。尽管从操作角度来说线程1成功了，但是在该过程中实际上数据已发生了变化但并未被感知到，某些应用场景下可能会出现数据不一致的问题。③乐观锁通过版本号来解决ABA问题，具体的操作是每次执行数据修改操作时都会带上一个版本号，如果预期版本号和数据版本号一致就进行操作，并将版本号加1，否则执行失败。</p><p><em><strong>*Q31：讲一讲wait、sleep、yield、join方法的区别*</strong></em><br>答：①wait是Object类的方法，调用wait方法的线程会进入WAITING状态，只有等待其他线程的通知或被中断后才会解除阻塞，调用wait方法会释放锁资源。②sleep是Thread类的方法，调用sleep方法会导致当前线程进入休眠状态，与wait不同的是该方法不会释放锁资源，进入的是TIMED-WAITING状态。③yiled方法会使当前线程让出CPU时间片给优先级相同或更高的线程，回到RUNNABLE状态，与其他线程一起重新竞争CPU时间片。④join方法用于等待其他线程运行终止，如果当前线程调用了另一个线程的join方法，则当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就绪态，等待获取CPU时间片。底层使用的是wait，也会释放锁。</p><p><em><strong>*Q32：讲一讲线程中断*</strong></em><br>答：①interrupt方法用于向线程发送一个终止信号，会影响该线程内部的中断标识位，这个线程本身不会因为调用了interrupt方法而改变状态，状态的具体变化需要等待接收到中断标识的程序的处理结果判定。②调用interrupt方法不会中断一个正在运行的线程，只会改变内部的中断标识位的值为true。③当调用sleep方法使线程处于TIMED-WAITING状态使，调用interrupt方法会抛出InterruptedException，使线程提前结束TIMED-WAITING状态。在抛出该异常前将清除中断标识位，所以在抛出异常后调用isInterrupted方法返回的值是false。④中断状态是线程固有的一个标识位，可以通过此标识位安全终止线程。比如想终止某个线程时，先调用interrupt方法然后在run方法中根据该线程isInterrupted方法的返回值安全终止线程。</p><p><em><strong>*Q33：什么是守护线程？*</strong></em><br>答：①守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。守护线程不依赖于终端，但是依赖于JVM，当JVM中仅剩下守护线程时，JVM就会退出。②通过setDaemon方法定义一个守护线程，守护线程的优先级较低，将一个用户线程设置为守护线程必须要在启动守护线程之前。</p><p><em><strong>*Q34：start和run方法的区别？*</strong></em><br>答：①start方法用于启动线程，真正实现了多线程，调用了start方法后，会在后台创建一个新的线程来执行，不需要等待run方法执行完毕就可以继续执行其他代码。调用start方法时，该线程处于就绪状态，并没有开始运行。②run方法也叫做线程体，包含了要执行的线程的逻辑代码，在调用run方法并没有创建新的线程，而是直接运行run方法中的代码。</p><h3 id="JVM-15"><a href="#JVM-15" class="headerlink" title="*JVM 15*"></a><em><strong>*JVM 15*</strong></em></h3><p><em><strong>*Q1：类的加载机制是什么?*</strong></em><br>答：类加载到内存中主要有5个阶段，分别为①加载：将Class文件读取到运行时数据区的方法区内，在堆中创建Class对象，并封装类在方法区的数据结构的过程。②验证：主要用于确保Class文件符合当前虚拟机的要求，保障虚拟机自身的安全，只有通过验证的Class文件才能被JVM加载。③准备：主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值。④解析：将常量池中的符号引用替换为直接引用。⑤初始化：主要通过执行类构造器的<client>方法为类进行初始化，该方法是在编译阶段由编译器自动收集类中静态语句块和变量的赋值操作组成的。JVM规定，只有在父类的<client>方法都执行成功后，子类的方法才可以被执行。在一个类中既没有静态变量赋值操作也没有静态语句块时，编译器不会为该类生成<client>方法。</client></client></client></p><p><em><strong>*Q2：有哪些类加载器，类加载器的加载模型是什么，有什么好处？*</strong></em><br>答：①主要有启动类加载器，负责加载JAVA_HOME/lib中的类库；扩展类加载器，负责加载JAVA_HOME/lib/ext中的类库；应用程序类加载器，也称系统类加载器，负责加载用户类路径上指定的类库；也可以自定义类加载器。②类加载器之间的层次关系叫做双亲委派模型，要求除了顶层的启动类加载器外其余的类加载器都应当有自己的父类加载器。一个类收到类加载请求后会层层找父类加载器去尝试加载，因此所有的加载请求最终都会被传送到顶层的启动类加载器，只有当父类加载器反馈自己无法完成加载时子加载器才会尝试自己去加载。③双亲委派模型的好处是保障类加载的唯一性和安全性，例如加载rt.jar包中的java.lang.Object，无论哪一个类加载最终都会委托给启动类加载器，这样就保证了类加载的唯一性。如果存在包名和类名都相同的两个类，那么该类就无法被加载。</p><p><em><strong>*Q3：简述JVM的内存区域*</strong></em><br>答：JVM的内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（堆、方法区）和直接内存。①程序计数器是一块很小的内存空间，用于存储当前线程执行字节码文件的行号指示器。②虚拟机栈是描述Java方法执行过程的内存模型，帧栈中存储了局部变量表，操作数栈，动态链接，方法出口等信息。③本地方法栈，和虚拟机栈作用类似，区别是虚拟机栈为Java方法服务，本地方法栈为Native方法服务。④JVM运行过程中创建的对象和生成的数据都存储在堆中，堆是被线程共享的内存区域，也是垃圾回收最主要的内存区域。⑤方法区用来存储常量，静态变量、类信息、即时编译器编译后的机器码、运行时常量池等数据。</p><p><em><strong>*Q4：哪些情况下类不会初始化？*</strong></em><br>答：①常量在编译时会存放在使用该常量的类的常量池，该过程不要调用常量所在的类，不会初始化。②子类引用父类的静态变量时，子类不会初始化，只有父类会初始化。③定义对象数组，不会触发该类的初始化。④在使用类名获取Class对象时不会触发类的初始化。⑤在使用Class.forName()加载指定的类时，可以通过initialize参数设置是否需要初始化。⑥在使用ClassLoader默认的loadClass方法加载类时不会触发该类的初始化。</p><p><em><strong>*Q5：哪些情况下类会初始化？*</strong></em><br>答：①创建类的实例。②访问某个类或接口的静态变量，或对该静态变量赋值。③调用类的静态方法。④初始化一个类的子类时（初始化子类，父类必须先初始化）。⑤JVM启动时被标为启动类的类。⑥使用反射进行方法调用时。</p><p><em><strong>*Q6：谈谈JVM的运行时内存*</strong></em><br>答：JVM的运行时内存也叫做JVM堆，从GC角度更将其分为新生代，老年代和永久代。<br>其中新生代默认占1/3堆空间，老年代默认占2/3堆空间，永久代占非常少的堆空间。<br>新生代又分为Eden区、ServivorFrom区和ServivorTo区，Eden区默认占8/10新生代空间，ServivorFrom区和ServivorTo区默认分别占1/10新生代空间。</p><p><em><strong>*Q7：谈谈新生代是怎么分区的*</strong></em><br>答：①JVM新创建的对象（除了大对象外）会被存放在新生代，默认占1/3堆内存空间。由于JVM会频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。②新生代又分为Eden区，ServivorFrom区和ServivorTo区。③Eden区：Java新创建的对象首先会被存放在Eden区，如果新创建的对象属于大对象，则直接将其分配到老年代。大对象的定义和具体的JVM版本、堆大小和垃圾回收策略有关，一般为2KB~128KB，可通过-XX:PretenureSizeThreshold设置其大小。在Eden区的内存空间不足时会触发MinorGC，对新生代进行一次垃圾回收。②ServivorTo区：保留上一次MinorGC时的幸存者。③ServivorFrom区：将上一次MinorGC时的幸存者作为这一次MinorGC的被扫描者。</p><p><em><strong>*Q8：谈谈新生代的垃圾回收机制*</strong></em><br>答：新生代的GC过程叫做MinorGC，采用复制算法实现，具体过程如下：<br>①把在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区，如果某对象的年龄达到老年代的标准，则将其复制到老年代，同时把这些对象的年龄加1。如果ServivorTo区的内存空间不够，则也直接将其复制到老年代。如果对象属于大对象，则也直接复制到老年代。②清空Eden区和ServivorFrom区中的对象。③将ServivorFrom区和ServivorTo区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。</p><p><em><strong>*Q9：谈谈老年代的垃圾回收机制*</strong></em><br>答：①老年代主要存放有长生命周期的对象和大对象，老年代的GC叫MajorGC。②在老年代，对象比较稳定，MajorGC不会频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，过后仍然出现老年代空间不足或无法找到足够大的连续内存空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。③MajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。因为要先扫描老年代的所有对象再回收，所以MajorGC的时间较长。容易产生内存碎片，在老年代没有内存空间可分配时，会出现内存溢出异常。</p><p><em><strong>*Q10：谈一谈永久代*</strong></em><br>答：①永久代指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在类加载时被放入永久代。②永久代和老年代、新生代不同，GC不会在程序运行期间对永久代的内存进行清理，这也导致了永久代的内存会随着加载的Class文件的增加而增加，在加载的Class文件过多时会出现内存溢出异常，比如Tomcat引用jar文件过多导致JVM内存不足而无法启动。③在JDK1.8中，永久代已经被元数据区取代。元数据区的作用和永久代类似，二者最大的区别在于：元数据区并没有使用虚拟机的内存，而是直接使用操作系统的本地内存。因此元空间的大小不受JVM内存的限制，只和操作系统的内存有关。④在JDK1.8中，JVM将类的元数据放入本地内存中，将常量池和类的静态常量放入Java堆中，这样JVM能够加载多少元数据信息就不再由JVM的最大可用内存空间决定，而由操作系统的实际可用内存空间决定。</p><p><em><strong>*Q11：如何确定对象是否是垃圾？*</strong></em><br>答：①Java采用****引用计数法*<em><strong>和</strong></em>*可达性分析****来确定对象是否应该被回收。引用计数法容易产生循环引用的问题，可达性分析通过根搜索算法实现。根搜索算法以一系列GC Roots的点作为起点向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡。根搜索算法主要针对栈中的引用、方法区的静态引用和JNI中的引用展开分析。②引用计数法：在Java中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为对象添加一个引用时，引用计数加1；在为对象删除一个引用时，引用计数减1；如果一个对象的引用计数为0，则表示此刻该对象没有被引用，可以被回收。引用计数法容易产生循环引用问题，循环引用指两个对象相互引用，导致它们的引用一直存在，而不能被回收。③可达性分析：为了解决引用计数法的循环引用问题，Java还采用了可达性分析来判断对象是否可以被回收。具体做法是首先定义一些GC Roots对象，然后以这些GC Roots对象作为起点向下搜索，如果在GC Roots和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象要经过至少两次标记才能判断其是否可被回收，如果两次标记后该对象仍然不可达，则将被垃圾回收器回收。</p><p><em><strong>*Q12：有哪些GC算法？分别有什么特点？*</strong></em><br>答：①标记清除算法：标记出所有需要回收的对象，然后清除可回收的对象。效率较低，并且因为在清除后没有重新整理可用的内存空间，如果内存中可被回收的小对象居多，会引起内存碎片化问题。②复制算法：将可用内存分为区域1和区域2，将新生成的对象放在区域1，在区域1满后对区域1进行一次标记，将标记后仍然存活的对象复制到区域2，然后清除区域1。效率较高并且易于实现，解决了内存碎片化的问题，缺点是浪费了大量内存，同时在系统中存在长生命周期对象时会在两区域间来回复制影响系统效率。③标记清除算法：结合了标记清除算法和复制算法的优点，标记过程和标记清除算法一样，标记后将存活的对象移动到一端，清理另一端。④分代收集算法：根据对象不同类型把内存划分为不同区域，把堆划分为新生代和老年代。由于新生代的对象生命周期较短，主要采用复制算法。将新生代划分为一块较大的Eden区和两块较小的Survivor区，Servivor区又分为ServivorTo和ServivorFrom区。JVM在运行过程中主要使用Eden和SurvivorFrom区，进行垃圾回收时将这个两个区域存活的对象复制到SurvivorTo区并清除这两个区域。老年代主要存储长生命周期的大对象，因此采用标记清除或标记整理算法。</p><p><em><strong>*Q13：有哪些垃圾回收器？各自有什么特点?*</strong></em><br>答：①Serial：单线程，基于复制算法，JVM运行在Client时默认的新生代垃圾收集器。②ParNew：Serial的多线程实现，基于复制算法，JVM运行在Server时默认 的新生代垃圾收集器。③Paraller Scavenge：多线程，基于复制算法，以吞吐量最大化为目标，允许较长时间的STW换取吞吐量。④Serial Old：单线程，基于标记整理算法，是JVM运行在Client模式下默认的老年代垃圾回收器，可和Serial搭配使用。⑤Parall Old：多线程，基于标记整理算法，优先考虑系统的吞吐量。⑥CMS：多线程，基于标记清除算法，为老年代设计，追求最短停顿时间。主要有四个步骤：初始标记、并发标记、重新标记、并发清除。⑥G1：将堆内存分为几个大小固定的独立区域，在后台维护了一个优先列表，根据允许的收集时间回收垃圾收集价值最大的区域。相比CMS不会产生内存碎片，并且可精确控制停顿时间。分为四个阶段：初始标记、并发标记、最终标记、筛选回收。</p><p><em><strong>*Q14：Java中有哪些引用类型？*</strong></em><br>答：①强引用，最常见的引用类型，把一个对象指向一个引用变量时就是强引用。强引用的对象一定为可达性状态，所以不会被垃圾回收，是内存泄漏的主要原因。②软引用，通过SoftReference实现，如果一个对象只有软引用，当内存空间不足时将被回收。③弱引用，通过WeakReference实现，如果一个对象只有弱引用，在垃圾回收过程中一定会被回收。④虚引用，通过PhantomReference实现，虚引用和引用队列联合使用，主要用来跟踪对象的垃圾回收过程。</p><p><em><strong>*Q15：JVM有哪些内存回收与回收策略？*</strong></em><br>答：①对象优先在Eden区分配：大多数情况下对象在新生代Eden区分配，当Eden区没有足够空间时，虚拟机将发起一次MinorGC。②大对象直接进入老年代：大对象是指需要大量连续内存空间的Java对象，如很长的字符串及数组。虚拟机提供了一个参数-XX:PretenureSizeThreshold，大于该值的对象会直接进入老年代，防止它在新生代之间来回复制。③长期存活的对象进入老年代：虚拟机给每个对象定义了一个年龄计数器，若对象在Eden区出生、经过第一次MinorGC后仍存活且能被Survivor容纳，将被移到Survivor区并且对象年龄设为1。每经过一次MinorGC，年龄就加1。默认在年龄增加到15时晋升到老年代，可通过-XX:MaxTenuringThreshold设置晋升老年代的年龄阈值。④动态对象年龄判定：如果在Survivor空间中相同年龄所有对象大小超过了该空间的一半，大于等于该年龄的对象就可以直接进入老年代而不用等到达到阈值。⑤空间分配担保：发生MinorGC前，先判断老年代最大可用连续空间是否大于新生代所有对象的总空间，如果成立那么MinorGC是安全的。如果不成立会查看HandlePromotionFailure是否允许担保，如果允许会冒险进行MinorGC，否则改为一次FullGC。</p><h3 id="反射与注解-3"><a href="#反射与注解-3" class="headerlink" title="*反射与注解 3*"></a><em><strong>*反射与注解 3*</strong></em></h3><p><em><strong>*Q1：简述反射的基本概念，优缺点和使用场景。*</strong></em><br>答：①在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java的反射机制。② 优点是运行时动态获取类的全部信息，缺点是破坏了类的封装性，泛型的约束性。③是框架的核心灵魂，动态代理设计模式采用了反射机制，还有 Spring、Hibernate 等框架也大量使用到了反射机制。</p><p><em><strong>*Q2：获取Class对象有哪几种方式？能通过Class对象获取类的哪些信息？*</strong></em><br>答：①通过类名.class②通过对象.getClass()③通过Class.forName(类的全限名);④可以通过Class对象获取类的成员变量，方法或构造器。带declared的获取方法可以获取到类的一个或全部成员变量，方法，构造器，不带declared的方法只能获取到类的public修饰的成员变量、方法或构造器，包括父类public修饰的成员变量、方法或构造器。</p><p><em><strong>*Q3：注解是什么，元注解是什么，有什么作用？*</strong></em><br>答：①注解是一种标记，可以使类或接口附加额外的信息，是帮助编译器和JVM完成一些特定功能的。②元注解就是自定义注解的注解，包括@Target：用来约束注解的位置，值是ElementType枚举类，包括METHOD方法、VARIABLE变量、TYPE类/接口、PARAMETER方法参数、CONSTRUCTORS构造器和LOACL_VARIABLE局部变量；@Rentention：用来约束注解的生命周期，值是RetentionPolicy枚举类，包括：SOURCE源码、CLASS字节码和RUNTIME运行时；@Documented：表明这个注解应该被javadoc工具记录；@Inherited：表面某个被标注的类型是被继承的。</p><h3 id="IO流-5"><a href="#IO流-5" class="headerlink" title="*IO流 5*"></a><em><strong>*IO流 5*</strong></em></h3><p><em><strong>*Q1：简单说说File对象表示的是什么？File类有哪些常用方法?*</strong></em><br>答：①File对象表示的是操作系统上的文件或目录。②获取：getAbsolutePath() 获取绝对路径；getPath() 获取文件定义时使用的路径；getName() 获取文件名，带后缀；length() 返回文件长度，单位是字节。③判断：exists() 判断File对象表示的文件或目录是否存在；isDirectory() 判断是否是目录； isFile() 判断是否是文件。④创建和删除：createNewFile() 不存在时创建新文件；delete() 删除文件，目录（非空目录不能删除）；mkdir() 创建一级目录；mkdirs() 创建多级目录，推荐使用；⑤遍历：list 获取当前目录下所有一级文件名称到一个字符串数组并返回；listFiles 获取当前目录下所有一级File对象到File数组返回。</p><p><em><strong>*Q2：英文、数字和中文字符在文件中分别占多大的空间？*</strong></em><br>答：①英文和数字在任何编码中都占1个字节。②中文字符在GBK编码下占2个字节，在UTF-8编码下占3个字节。</p><p><em><strong>*Q3：简述传统IO有哪些分类？*</strong></em><br>答：①按流的方向：输出流：把内存中的数据写出到磁盘文件或网络介质中；输入流：把磁盘文件或网络介质中的数据读取到内存中。②按流的内容：字节流：流中数据的最小单位是字节；字符流：流中数据的最小单位是字符（针对文本内容）。顶层的抽象类包括InputStream、OutputStream、Reader、Writer，它们都实现了Closeable接口。③缓冲流（BufferedInputStream/BufferedOutputStream/BufferedReader/BufferedWriter）：自带一个8KB大小的缓冲池，可以将字节/字符流为缓冲字节/缓冲字符流。④字符转换流（InputStreamReader/OutputStreamWriter）：可以将对应的字节流转换为字符流。⑤打印流：PrintStream，方便快速打印数据，参数是什么就打印什么。</p><p><em><strong>*Q4：简述BIO、NIO、AIO的区别和原理*</strong></em><br>答：①BIO是同步阻塞的，数据的读写会阻塞在一个线程中，适用于连接数目比较小且固定的架构，对服务器资源要求高，JDK1.4前的唯一选择。②NIO是同步非阻塞的，通过Selector监听Channel上事件的变化，在Channel上有数据发生变化时通知该线程进行读写操作。适用于连接数目比较多且连接比较短的架构，如聊天服务器，从 JDK1.4开始支持。③AIO是异步非阻塞的，异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情。适用于连接数目比较多且连接比较长的架构，从JDK1.7开始支持。</p><p><em><strong>*Q5：序列化和反序列化是什么，有什么要求？*</strong></em><br>答：①Java在JVM运行时被创建、更新和消耗，当JVM退出时，对象也会随之销毁。可以通过Java序列化实现持久化存储，保存对象及其状态信息到字节数组中。②反序列化就是再将字节数组中存储的信息转换回Java对象。③要求类必须实现序列化接口，并且序列化和反序列化必须保持序列化的ID一致。④静态变量和被transient修饰的变量不会被序列化。</p><h2 id="JavaWeb-19"><a href="#JavaWeb-19" class="headerlink" title="*JavaWeb 19*"></a><em><strong>*JavaWeb 19*</strong></em></h2><p><em><strong>*Q1：HTTP有哪些特点*</strong></em><br>答：①HTTP是基于TCP/IP协议的。②HTTP使用的默认端口号是80。③HTTP是基于请求/响应模型的，一次请求对应一次响应。④HTTP是无状态的，每次请求之间相互独立，不能交互数据。⑤HTTP1.0每一次请求响应都会建立新的连接，HTTP1.1会复用连接。</p><p><em><strong>*Q2：HTTP请求数据的数据格式是什么？*</strong></em><br>答：①请求行，包括了请求方式、请求url、请求协议/版本。HTTP协议有7种请求方式，常用的有2种。GET方式，请求参数在请求行中，在url后、 请求的url长度有限制的、不太安全；POST方式，请求参数在请求体中、请求的url长度没有限制的、相对安全。②请求头，是客户端浏览器告诉服务器的一些信息，常见的请求头例如User-Agent，告诉服务器使用的浏览器版本信息，可以在服务器端获取该头的信息，解决浏览器的兼容性问题。Referer，可以告诉服务器，当前请求从哪里来，可以防盗链或者进行统计数据。③请求空行，用于分割POST请求的请求头和请求体的。④请求体(正文)，封装POST请求消息的请求参数的。</p><p><em><strong>*Q3：转发和重定向的区别？*</strong></em><br>答：①转发的特点： 转发地址栏路径不变、 转发只能访问当前服务器下的资源、转发是一次请求，可以使用request对象来共享数据。②重定向的特点：地址栏发生变化、重定向可以访问其他站点(服务器)的资源、重定向是两次请求，不能使用request对象来共享数据。</p><p><em><strong>*Q4：讲一讲Cookie*</strong></em><br>答：①Cookie是客户端会话技术，将数据保存到客户端。②创建Cookie对象，绑定数据：new Cookie(String name, String value)；发送Cookie对象：response.addCookie(Cookie cookie)，一次可以发送多个Cookie；获取Cookie，拿到数据：request.getCookies()。③浏览器对于单个cookie 的大小有限制(4kb) 以及对同一个域名下的总cookie数量也有限制(20个)，cookie一般用于存出少量的不太敏感的数据，在不登录的情况下，完成服务器对客户端的身份识别。</p><p><em><strong>*Q5：Cookie的生命周期？*</strong></em><br>答：①默认情况下，当浏览器关闭后，Cookie数据被销毁。②如果想要持久化存储，可以使用setMaxAge(int seconds)。正数：将Cookie数据写到硬盘的文件中，持久化存储，并指定cookie存活时间，时间到后，cookie文件自动失效。负数：默认值。零：删除cookie信息。</p><p><em><strong>*Q6：Cookie可以存储中文数据吗？*</strong></em><br>答：①在tomcat 8 之前cookie中不能直接存储中文数据，需要将中文数据转码—一般采用URL编码(%E3)。②在tomcat 8 之后，cookie支持中文数据，特殊字符还是不支持，建议使用URL编码存储，URL解码解析。</p><p><em><strong>*Q7：Cookie的共享范围是什么？*</strong></em><br>答：①假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie默认情况下不能共享。通过setPath(String path)设置cookie的获取范围，默认情况下，设置为当前的虚拟目录，如果要共享，则可以将path设置为/。②不同的tomcat服务器间cookie共享问题：通过setDomain(String path)设置一级域名，如果一级域名相同，那么多个服务器之间cookie可以共享。例如setDomain(“.baidu.com”)，那么tieba.baidu.com和news.baidu.com中cookie可以共享。</p><p><em><strong>*Q8：讲一讲Session*</strong></em><br>答：①Session是服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。②获取HttpSession对象：request.getSession()；使用HttpSession对象：Object getAttribute(String name)、void setAttribute(String name, Object value)、void removeAttribute(String name)。③Session的实现是依赖于Cookie的，服务器是通过cookie中的JESSIONID判断session是否是同一个的。</p><p><em><strong>*Q9：Session的生命周期？当客户端关闭后，服务器不关闭，两次获取session是否为同一个？客户端不关闭，服务器关闭后，两次获取的session是同一个吗？*</strong></em><br>答：①服务器关闭、session对象调用invalidate() 时销毁，session默认失效时间 30分钟。②在默认情况下，当客户端关闭服务端不关闭时，两次获取session值不是同一个。③如果需要相同，则可以创建Cookie，键为JSESSIONID，设置最大存活时间，让cookie持久化保存。④客户端不关闭，服务端关闭，两次获取的session值也不是同一个。但是要确保数据不丢失。tomcat自动完成以下工作。session的钝化： 在服务器正常关闭之前，将session对象序列化到硬盘上。session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。但是IDEA不支持这种操作，因为每次用IDEA重启tomcat时会自动删除catalina_base中work目录（程序动态生成的文件），这样在关闭tomcat时生成的session序列化文件也会被删除。</p><p><em><strong>*Q10：Session的特点，和Cookie有什么区别？*</strong></em><br>答：①Session用于存储一次会话的多次请求的数据，存在服务器端。session可以存储任意类型，任意大小的数据。②Session存储数据在服务器端，Cookie存储数据在客户端。<br>Session没有存储数据的大小限制，Cookie有数据大小限制。Session存储数据是安全的，使用Cookie存储数据相对于使用Session来说不安全。</p><p><em><strong>*Q11：EL是什么？*</strong></em><br>答：①EL指Expression Language 表达式语言。②EL表达式的作用是替换和简化jsp页面中java代码的编写。③EL表达式的语法是：${表达式}。④JSP默认支持EL表达式，如果要忽略EL表达式，设置JSP中page指令中的isELIgnored=”true”忽略当前jsp页面中所有的el表达式，也可以通过${表达式} 忽略当前这个EL表达式。</p><p><em><strong>*Q12：JSTL是什么？*</strong></em><br>答：①JSTL指JavaServer Pages Tag Library JSP标准标签库，是由Apache组织提供的开源的免费的JSP标签。②JSTL的作用是简化和替换jsp页面上的Java代码。③使用时首先需要导入JSTL相关jar包，并引入标签库： &lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ %&gt;。</p><p><em><strong>*Q13：JSP定义Java代码有哪些方式？*</strong></em><br>答：①&lt;% 代码 %&gt;是JSP页面中Java代码片段的容器，将页面转换为servlet类时，会将内容插入到servlet类的jspService()方法中，同时从JSP生成servlet。②&lt;%! 代码 %&gt;用于为JSP页面声明全局的方法和变量。在JSP文件中，必须先声明这些变量和方法然后才能使用它们。在页面转换中，声明的方法和变量成为JSP页面的servlet类中的类成员声明。语法③&lt;%= 代码 %&gt;用于将转换为String的Java表达式的值插入到返回给客户端的响应中。</p><p><em><strong>*Q14：JSP的内置对象有哪些？*</strong></em><br>答：①pageContext，真实类型是PageContext，可以在当前页面共享数据，还可以获取其他八个内置对象。②page，真实类型是Object，指当前页面(Servlet)的对象this。③request，真实类型是HttpServletRequest，封装客户端的请求。④response，真实类型是HttpServletResponse，封装服务端对客户端的响应。⑤session，真实类型是HttpSession，封装会话数据信息。⑥out，真实类型是JspWriter，字符输出流对象，可以将数据输出到页面上，和response.getWriter()类似。response.getWriter()和out的区别：在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。response.getWriter().write()数据输出永远在out.write()之前。⑦config，真实类型是ServletConfig，是Servlet的配置对象。⑧exception，真实类型是Throwable，封装页面抛出异常的对象。⑨application，真实类型是ServletContext，封装服务器运行环境的对象。</p><p><em><strong>*Q15：过滤器是什么？如何使用？*</strong></em><br>答：①当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。②需要实现Filter接口，使用注解方式可以在类名上加上注解@WebFilter(“拦截路径”)，使用XML的方式可以配置web.xml中的filter和filter-mapping标签，设置过滤器类和拦截路径。</p><p><em><strong>*Q16：过滤器的执行流程和生命周期是什么？*</strong></em><br>答：①执行流程：执行过滤器，执行放行后的资源，回来执行过滤器放行代码下边的代码。②生命周期：init：在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次，一般用于加载资源。doFilter：在每一次请求被拦截资源时执行，会执行多次。destroy：在服务器关闭后，Filter对象被销毁，如果服务器是正常关闭，则会执行destroy方法。只执行一次。一般用于释放资源。</p><p><em><strong>*Q17：过滤器拦截路径都有哪些方式？*</strong></em><br>答：①具体资源路径：，例如/index.jsp ，只有访问index.jsp资源时，过滤器才会被执行。②拦截目录：例如/user/<em>，当访问/user下的所有资源时，过滤器都会被执行。③通过后缀名拦截：例如</em>.jsp， 当访问所有后缀名为jsp资源时，过滤器都会被执行。④拦截所有资源：使用/*，访问所有资源时过滤器都会执行。</p><p><em><strong>*Q18：AJAX是什么？*</strong></em><br>答：①Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。②通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。③传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面，使用Ajax技术可以提升用户的体验。</p><p><em><strong>*Q19：JSON是什么？如何把Java对象转为JSON？如何把JSON转回Java对象？*</strong></em><br>答：①JSON指JavaScript Object Notation JavaScript对象表示法。②JSON现在多用于存储和交换文本信息的语法，进行数据的传输。③JSON的优势是想比XML来说占用空间更小、操作数据更快，更易解析。④将Java对象转为JSON时，需要先导入jackson的相关jar包，创建Jackson核心对象 ObjectMapper，之后调用ObjectMapper的writeValue(参数，obj)进行转换，如果参数是File类型，可以将obj对象转换为JSON字符串，并保存到指定的文件中；如果参数是Writer类型，可以将obj对象转换为JSON字符串，并将json数据填充到字符输出流中；如果参数是OutputStream类型，可以将obj对象转换为JSON字符串，并将JSON数据填充到字节输出流中。⑤将JSON转会Java对象时使用readValue的方法，参数为要转回的Java对象的Class字节码对象。</p><h2 id="JavaEE-29"><a href="#JavaEE-29" class="headerlink" title="*JavaEE 29*"></a><em><strong>*JavaEE 29*</strong></em></h2><h3 id="Spring-7"><a href="#Spring-7" class="headerlink" title="*Spring 7*"></a><em><strong>*Spring 7*</strong></em></h3><p><em><strong>*Q1：Spring的IOC和DI是什么？*</strong></em><br>答：①IOC即控制反转，简单来说就是把对象的控制权委托给spring框架，作用是降低代码的耦合度。②DI即依赖注入，是IOC的一种具体实现方式。假设一个Car类需要Engine的对象，那么一般需要new一个Engine，利用IOC就是只需要定义一个私有的Engine引用变量，容器会在运行时创建一个Engine的实例对象并将引用自动注入给变量。</p><p><em><strong>*Q2：简述Spring中bean对象的生命周期*</strong></em><br>答：①Spring对bean进行实例化。②Spring将值和bean的引用注入到其对应的属性中。③调用BeanNameAware的setBeanName方法。④调用BeanFactoryAware的setBeanFactory方法。⑤调用AppicationContxtAware的setApplicationContext方法。⑥调用BeanPostProcessor的post-ProcessBeforeInitialization方法。⑦调用InitializingBean的after-PropertiesSet方法。如果bean使用init-method声明了自定义初始化方法，该方法也会被调用。⑧调用BeanPostProcessor的post-ProcessAfterInitialization方法。⑨使用bean。⑩调用DisposableBean的destroy方法，如果bean使用destroy-method声明了自定义销毁方法，该方法也会被调用。</p><p><em><strong>*Q3：简述bean的作用范围*</strong></em><br>答：通过scope指定bean的作用范围，有①singleton：单例的，每次容器返回的对象是同一个。②prototype :多例的，每次返回的对象是新创建的实例。③request：仅作用于HttpRequest，每次Http请求都会创建一个新的bean。④session：仅作用于HttpSession，不同的Session使用不同的实例，相同的Session使用同一个实例。⑤global session ：仅作用于HttpSession，所有的Session使用同一个实例。</p><p><em><strong>*Q4：BeanFactory和FactoryBean，ApplicationContext的区别？*</strong></em><br>答：①BeanFactory是一个Factory接口，是用来管理bean的IOC容器或对象工厂，较为古老，不支持spring的一些插件。BeanFactory使用了延迟加载，适合多例模式。②FactoryBean是一个Bean接口，是一个可以生产或者装饰对象的工厂Bean，可以通过实现该接口自定义的实例化Bean的逻辑。③ApplicationConext是BeanFactory的子接口，扩展了其功能，ApplicationContext是立即加载，适合单例模式。一般推荐使用ApplicationContext。</p><p><em><strong>*Q5：使用XML配置有哪些创建Bean对象的方式？*</strong></em><br>答：①通过默认无参构造器。使用bean标签，只使用id和class属性，如果没有无参构造器会报错。②使用静态工厂，通过bean标签中的class指明静态工厂，factory-method指明静态工厂方法。③使用实例工厂，通过bean标签中的factory-bean指明实例工厂，factory-method指明实例工厂方法。</p><p><em><strong>*Q6：依赖注入可以注入哪些数据类型？有哪些注入方式？*</strong></em><br>答：①可以注入的数据类型有基本数据类型、String、Bean、以及集合等复杂数据类型。②有三种注入方式，第一种是通过****构造器*<em><strong>注入，通过constructor-arg（）标签实现，缺点是即使不需要该属性也必须注入；第二种是通过</strong></em>*Set方法*<em><strong>注入，通过property标签实现，优点是创建对象时没有明确限制，缺点是某个成员变量必须有值，在获取对象时set方法可能还没有执行；第三种是通过</strong></em>*注解****注入，利用@Autowired自动按类型注入，如果有多个匹配则按照指定bean的id查找，查找不到会报错；@Qualifier在自动按照类型注入的基础之上，再按照 Bean 的 id 注入，给成员变量注入时必须搭配@Autowired，给方法注入时可单独使用；@Resource直接按照 Bean 的 id 注入；@Value用于注入基本数据类型和String。</p><p><em><strong>*Q7：有哪些配置Bean的注解，各有什么区别？*</strong></em><br>答：①@Component，把当前类对象存入spring容器中，相当于在 xml 中配置一个 bean。value属性指定 bean 的 id，如果不指定 value 属性，默认 id 是当前类的类名，首字母小写。②@Service，一般用于业务层。③@Controller：一般用于表现层。④@Repository：一般用于持久层。⑤@Controller @Service @Repository都是针对@Component的衍生注解，作用及属性都是一模一样的，只是提供了更加明确的语义化。</p><h3 id="Spring-Aop-4"><a href="#Spring-Aop-4" class="headerlink" title="*Spring Aop 4*"></a><em><strong>*Spring Aop 4*</strong></em></h3><p><em><strong>*Q1：Spring Aop的基本原理是什么？*</strong></em><br>答：Aop即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理的技术，在不修改源码的基础上对方法进行增强。优点是可以减少代码的冗余，提高开发效率，维护方便。Spring会根据类是否实现了接口来判断动态代理的方式，如果实现了接口会使用JDK的动态代理，核心是InvocationHandler接口和Proxy类，如果没有实现接口会使用cglib的动态代理，cglib是在运行时动态生成某个类的子类，如果某一个类被标记为final，是不能使用cglib动态代理的。</p><p><em><strong>*Q2：简单解释一下AOP的相关术语*</strong></em><br>答：①<em><strong>*Joinpoint(连接点)*</strong></em>:指那些被拦截到的点，在 spring 中这些点指的是方法，因为 spring 只支持方法类型的连接点。例如业务层实现类中的方法都是连接点。②<em><strong>*Pointcut(切入点)*</strong></em>:指我们要对哪些 Joinpoint 进行拦截的定义。例如业务层实现类中被增强的方法都是切入点，切入点一定是连接点，但连接点不一定是切入点。③<em><strong>*Advice(通知/增强)*</strong></em>:指拦截到 Joinpoint 之后所要做的事情。④<em><strong>*Introduction(引介)*</strong></em>:引介是一种特殊的通知，在不修改类代码的前提下可以在运行期为类动态地添加一些方法或 Field。⑤<em><strong>*Weaving(织入)*</strong></em>:是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。⑥<em><strong>*Proxy（代理）*</strong></em>:一个类被 AOP 织入增强后，就产生一个结果代理类。⑦<em><strong>*Target(目标)*</strong></em>:代理的目标对象。⑧<em><strong>*Aspect(切面)*</strong></em>:是切入点和通知（引介）的结合。</p><p><em><strong>*Q3：Spring Aop有哪些相关注解？*</strong></em><br>答：@Before前置通知，@AfterThrowing异常通知，@AfterReturning后置通知，@After最终通知，@Around环绕通知。最终通知会在后置通知之前执行，为解决此问题一般使用环绕通知。</p><p><em><strong>*Q4：如何使用XML方式配置AOP？*</strong></em><br>答：①aop:config用于声明开始 aop 的配置。②aop:aspect用于配置切面。属性：id给切面提供一个唯一标识。ref引用配置好的通知类 bean 的 id。③aop:pointcut用于配置切入点表达式，就是指定对哪些类的哪些方法进行增强。属性：expression用于定义切入点表达式，id用于给切入点表达式提供一个唯一标识。④aop:before用于配置前置通知，在切入点方法执行之前执行；aop:after-returning用于配置后置通知，在切入点方法正常执行之后执行，它和异常通知只能有一个执行；aop:after-throwing用于配置异常通知，在切入点方法执行产生异常后执行；aop:after用于配置最终通知，无论切入点方法执行时是否有异常，它都会在其后面执行。</p><h3 id="Spring-MVC-15"><a href="#Spring-MVC-15" class="headerlink" title="*Spring MVC 15*"></a><em><strong>*Spring MVC 15*</strong></em></h3><p><em><strong>*Q1：SpringMVC的作用是什么？MVC的含义分别是什么？*</strong></em><br>答：①springMVC是一种基于Java实现的mvc设计模型的请求驱动类型的轻量级Web层框架，作用包括：参数绑定（获取请求参数）、调用业务层 、进行请求响应。②mvc全名是model view controller模型视图控制器，model指数据模型，JavaBean的类，用来封装数据；view指jsp，html等用来展示数据给用户的界面；controller是整个流程的控制器，用来接收用户请求以及进行数据校验等功能。</p><p><em><strong>*Q2：要搭建一个最基础的SpringMVC环境，你是如何配置的？*</strong></em><br>答：①在pom.xml中导入以下jar包：org.springframework下的spring-context）、spring-web、spring-webmvc、javax.servlet下的servlet-api、javax.servlet.jsp下的jsp-api以及测试用的junit包。②创建一个springmvc.xml的springconfig配置文件，开启包扫描，注册视图解析器，配置视图的前缀和后缀。③在web.xml中配置核心控制器，servlet和servlet-mapping的映射等。</p><p><em><strong>*Q3：SpringMVC的基础响应流程是怎样的？*</strong></em><br>答：①浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去（控制器类），转发的路径是根据请求 URL，匹配@RequestMapping 中的内容②根据执行方法的返回值和视图解析器（InternalResourceViewResolver），去指定的目录下查找指定名称的视图文件，Tomcat服务器渲染页面，做出响应。</p><p><em><strong>*Q4：SpringMVC响应流程中会涉及到哪些组件？*</strong></em><br>答：①DispatcherServlet：前端控制器，用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。②HandlerMapping：处理器映射器，负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。③Handler：处理器，它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。④HandlAdapter：处理器适配器，<br>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行⑤View Resolver：视图解析器，负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。⑥View：视图，SpringMVC 提供了很多 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p><p><em><strong>*Q5：讲一讲@RequestMapping注解*</strong></em><br>答：①作用：建立请求url和处理方法之间的对应关系。②作用位置：类，请求url的第一级访问目录，如果不写相当于根目录，需要以/开头；方法，请求url的第二级访问目录，可以不以/开头。③属性：value/path，绑定路径，支持多个路径，一般只配置一个路径；method 指定访问方式，可配置多个允许的访问方式，默认任何方法都支持，例如POST、GET等。</p><p><em><strong>*Q6：SpringMVC的参数绑定支持哪些类型，分别有哪些要求？*</strong></em><br>答：①基本数据类型和String，要求请求参数的参数名必须和控制器中方法的形参名一致，例如请求参数为name，控制器方法的形参也必须为name。②可以是Java对象，要求请求属性必须和对应的Java类中的成员变量名一致，例如input标签的name属性值为id，类中也必须有id这一个成员变量。也可以是Java对象中的List或Map集合。</p><p><em><strong>*Q7：如何解决请求参数中文乱码问题？*</strong></em><br>答：在web.xml中配置一个过滤器，配置一个filter标签，使用org.springframework.web.filter包下的CharacterEncodingFilter类实现，将<init-param>中的<param-name>设置为encoding，对应的<param-value>设置为UTF-8即可。然后配置对应的fiter-mapping标签，fiter-name和之前的一样，<url-pattern>设置为/*，表示对所有视图都进行编码过滤。</url-pattern></param-value></param-name></init-param></p><p><em><strong>*Q8：SpringMVC支持哪些Servlet对象作为控制器方法的参数？*</strong></em><br>答：一共有9个，包括①HttpServletRequest，指客户端的请求。②HttpServletResponse，指服务器端的响应。③HttpSession，Java平台对session机制的实现规范。④Principal，此接口表示主体的抽象概念，它可以用来表示任何实体，例如，个人、公司或登录id。⑤Locale，用于国际化操作的类。⑥InputStream，字节输入流。⑦OutputStream，字节输出流。⑧Reader，字符输入流。⑨Writer，字符输出流。</p><p><em><strong>*Q9：SpringMVC的常用注解有哪些？*</strong></em><br>答：①@RequestParam：作用是将请求参数和控制器中方法形参绑定(请求参数名和形参名不再要求相同)。属性包括：name/value，当和请求参数名一致可省略；required指定请求参数是否必填项；defaultValue是未提供请求参数时的默认值。②@RequestBody：作用是用于获取请求体的内容，直接使用得到的是key=value形式的字符串，把获取的json数据转换成pojo对象(get方式不可用)。③@RequestBody：作用是将控制器中方法返回的对象通过适当的转换器转换为指定的格式之后进行响应，通常用来返回JSON数据或者是XML。④@PathVariable：作用是绑定url中的占位符，例如请求url中/delete/{id}，{id}就是url占位符。url支持占位符是spring3.0后加入的，是springmvc支持rest风格url的一个重要标志。属性包括name/value 指定url中占位符名称；required指定是否必须提供占位符。⑤@RequestHeader：作用是获取指定请求头的值。属性：value代表请求头的名称。⑥@CookieValue：作用是用于把指定 cookie 名称的值传入控制器方法参数。属性包括value：指定 cookie 的名称。required：是否必须有此 cookie。⑦@ModelAttribute：是 SpringMVC4.3 版本以后加入的，它可以修饰方法和参数，出现在方法上表示当前方法会在控制器的方法执行之前先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。出现在参数上，获取指定的数据给参数赋值。属性value用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。</p><p><em><strong>*Q10：响应数据的格式有哪些？*</strong></em><br>答：①字符串，控制器中的方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址，例如返回”success”时可解析为success.jsp页面。②返回值为空，默认访问视图解析器前缀+requestmapping路径+视图解析器后缀的视图。③ModelandView，可以通过setViewName()方法设置视图名实现指定视图的跳转。</p><p><em><strong>*Q11：SpringMVC中如何实现转发和重定向，有什么区别？*</strong></em><br>答：①前提是控制器方法返回值类型必须是String类型。②转发到页面return”forward:+绝对地址”。转发到控制器其他方法：return的是”forward:+类上requestmapping的地址+方法上requestmapping的地址”。③重定向到页面：return的是”redirect:+绝对地址”，注意不能重定向访问WEB-INF下的资源。重定向到控制器其他方法：return的是”redirect:+类上requestmapping的地址+方法上requestmapping的地址”。重定向到外部链接：return的是”redirect:+链接地址(<a href="http://www.qq.com)" .4转发和重定向的区别是转发只是一次请求,重定向是两次请求;转发地址栏不变,重定向地址栏将改变;转发只能到内部资源,重定向可以到内部或外部资源;转发可以到web-inf下资源,重定向不可以.="" "="">http://www.qq.com)"。④转发和重定向的区别是转发只是一次请求，重定向是两次请求；转发地址栏不变，重定向地址栏将改变；转发只能到内部资源，重定向可以到内部或外部资源；转发可以到WEB-INF下资源，重定向不可以。</a></p><p><em><strong>*Q12：SpringMVC实现简单文件上传有哪些要求？*</strong></em><br>答：①浏览器端要求：表单提交方式为post(get有文件大小限制)。提供文件上传框对应的标签：<input type="file">。表单的entype属性必须为multipart/form-data。②服务器端要求：使用**request.getInputStream()**获取数据。springmvc底层封装了commons-fileupload文件上传工具包。</p><p><em><strong>*Q13：SpringMVC的异常处理流程是什么？*</strong></em><br>答：Dao层发生的异常会向上抛出到Service层、Service层的异常会向上抛出到Controller层，Controller层的异常会继续向上抛出到SpringMVC的前端控制器，由前端控制器将异常交给SpringMVC的异常处理器进行处理。如果是自定义的异常处理器，需要实现HandlerExceptionResolver接口，并使用@Component注解配置或在对应的springconfig配置文件中注册。</p><p><em><strong>*Q14：SpringMVC中的拦截器和拦截器链是什么，和过滤器有什么区别？*</strong></em><br>答：①Spring MVC 的拦截器用于对处理器进行预处理和后处理，用户可以自己定义一些拦截器来实现特定的功能。拦截器链就是将拦截器按一定的顺序联结成一条链，在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。②它和过滤器的区别是：过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用，拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用；过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截，拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp、html、css、image 或者 js 是不会进行拦截的；它也是 AOP 思想的具体应用，如果要想自定义拦截器， 要求必须实现HandlerInterceptor 接口。</p><p><em><strong>*Q15：拦截器有哪些常用方法，各自有什么特点？*</strong></em><br>答：①preHandle：按拦截器定义顺序调用，只要配置了都会调用。如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回 true，如果不需要再调用其他的组件去处理请求，则返回 false。②postHandle：<br>按拦截器定义逆序调用，在拦截器链内所有拦截器返回成功时调用。在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用， 在该方法中对用户请求 request 进行处理。③afterCompletion：按拦截器定义逆序调用，只有 preHandle 返回 true时才调用。在 DispatcherServlet 完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。</p><h3 id="Mybatis-3"><a href="#Mybatis-3" class="headerlink" title="*Mybatis 3*"></a><em><strong>*Mybatis 3*</strong></em></h3><p><em><strong>*Q1：延迟加载是什么？Mybatis支持吗?*</strong></em><br>答：①Mybatis支持延迟加载。实际开发过程中很多时候我们并不需要总是在加载某些信息时就一定要加载其关联信息，例如在加载用户信息时不是用户关联的账户信息不是必需的，此时就可以采用延迟加载。②延迟加载就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。③好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。④坏处：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。</p><p><em><strong>*Q2：讲一讲Mybatis的缓存*</strong></em><br>答：Mybatis的缓存分为：①一级缓存：指的是Mybatis中SqlSession对象的缓存，当我们执行完查询结果后，查询的结果会同时存入到SqlSession为我们提供的一块区域中，该区域的结构是一个Map，当我们再次查询同样数据时，Mybatis会先去SqlSession中查询是否有，有的话直接拿出来用。当SqlSession对象消失时，Mybatis的一级缓存也就消失了。一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。②二级缓存：二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</p><p><em><strong>*Q3：如何开启Mybatis的二级缓存？*</strong></em><br>答：①在springconfig配置文件中，将setting标签的cacheEnabled值设置为true（默认值为true，所以这一步可省略）。②配置相关的 Mapper 映射文件，使用<cache>标签表示当前这个 mapper 映射将使用二级缓存。③配置 statement 上面的 useCache 属性，设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。④如果是使用注解的方式，可以省略第二步，只需要在dao层接口上加上注解@CacheNamespace(blocking=true)。</cache></p><h2 id="数据库-47"><a href="#数据库-47" class="headerlink" title="*数据库 47*"></a><em><strong>*数据库 47*</strong></em></h2><h3 id="MySQL-21"><a href="#MySQL-21" class="headerlink" title="*MySQL 21*"></a><em><strong>*MySQL 21*</strong></em></h3><p><em><strong>*Q1：MySQL主要有哪些存储引擎，分别适合哪些应用场景？*</strong></em><br>答：主要有①MyISAM，是5.5版本之前的默认存储引擎，支持表级锁，不支持事务和外键，并发效率较低，读取数据快，更新数据慢。适合以读操作为主，并且对并发性要求较低的应用。②InnoDB，MySQL目前的默认存储引擎，支持行级锁、事务和外键，并发效率好。适合对事务的完整性和并发性、数据的准确性要求比较高，增删操作多的应用。③Memory，所有的数据都保存在内存中，访问速度快，一旦服务关闭数据将丢失。适合更新不太频繁的数据量小的表用来快速得到访问结果。④Archive、Federated等。</p><p><em><strong>*Q2：索引是什么？*</strong></em><br>答：MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><em><strong>*Q3：索引的优缺点有哪些？*</strong></em><br>答：①优势：提高数据检索的效率，降低数据库的IO成本。通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。②劣势：实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p><p><em><strong>*Q4：MySQL支持哪几种索引？*</strong></em><br>答：①BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。②HASH 索引：只有Memory引擎支持 ， 使用场景简单 。③R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。④Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</p><p><em><strong>*Q5：B+树是什么和B树有什么区别？*</strong></em><br>答：①BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下： 树中每个节点最多包含m个孩子。 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。若根节点不是叶子节点，则至少有两个孩子。所有的叶子节点都在同一层。每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1。②B+Tree为BTree的变种，B+Tree与BTree的区别为： n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。 B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。所有的非叶子节点都可以看作是key的索引部分。③由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p><p><em><strong>*Q6：MySQL的索引对B+树做了哪些优化？*</strong></em><br>答：MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p><em><strong>*Q7：索引有哪些分类？*</strong></em><br>答：①单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引。②唯一索引 ：索引列的值必须唯一，但允许有空值。③复合索引 ：即一个索引包含多个列。</p><p><em><strong>*Q8：数据库的索引创建有哪些设计原则？*</strong></em><br>答：①对查询频次较高，数据量较大的表创建索引。②****限制索引数量*<em><strong>：对于增删改操作较多的表，如果索引过多将需要很高的维护代价，降低操作效率，增加操作耗时。③</strong></em>*利用最左前缀*<em><strong>：如果索引字段值过长，会降低索引的执行效率。④</strong></em>*删除不常用索引*<em><strong>。⑤</strong></em>*使用唯一索引*<em><strong>，区分度越高，效率越高。⑤</strong></em>*使用短索引*<em><strong>，如果索引值很长则占用磁盘变大，会影响效。⑥为常作为</strong></em>*查询条件*<em><strong>、经常需要</strong></em>*排序、分组和联合*<em><strong>操作的字段建立索引。⑦尽量</strong></em>*扩展现有索引****，联合索引的效率高于多个独立索引。</p><p><em><strong>*Q9：索引在什么情况下会失效?*</strong></em><br>答：①复合索引未使用最左列索引时或跳跃使用时失效，例如以name，age和sex字段建立索引，只使用age和sex或只使用name和sex时索引失效。②在索引上进行运算或函数操作时索引失效。③数字字符没有加单引号索引失效，因为MySQL查询优化器会自动进行类型转换。④LIKE以%开头的查询索引失效，%在前时执行计划更倾向于使用全表扫描。⑤OR的前后没有同时使用索引时索引失效。⑥当全表扫描比使用索引速度更快时会使用全表扫描。</p><p><em><strong>*Q10：简述数据库三大范式*</strong></em><br>答：①第一范式：如果每列都是不可再分的最小数据单元，则满足第一范式。例如address：中国北京可拆分为两列，countyr：中国，city：北京。②第二范式：在第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖，即第二范式要求每个表只描述一件事情。例如订单表：订单编号、产品编号、订单日期、产品价格可拆分为订单表：订单编号、订单日期和产品表：产品编号、产品价格。③第三范式：满足第一和第二范式，并且表中的列不存在对非主键列的传递依赖。例如订单表：订单编号、订单日期、用户编号、用户姓名可优化为订单表：订单编号、订单日期、用户姓名。</p><p><em><strong>*Q11：MySQL数据库的隔离级别有哪些？分别有什么特点？*</strong></em><br>答：①未提交读，一个事务会读取到另一个事务没有提交的数据，存在脏读、不可重复读、幻读的问题。②已提交读，一个事务可以读取到另一个事务已经提交的数据，解决了幻读的问题，存在不可重复读、幻读的问题。③可重复读，MySQL默认的隔离级别，在一次事务中读取同一个数据结果是一样的，解决了不可重复读的问题，存在幻读问题。④可串行化，每次读都需要获得表级共享锁，读写互相阻塞，效率低，解决了幻读问题。</p><p><em><strong>*Q12：读取数据库时可能出现哪些问题？*</strong></em><br>答：①脏读，一个事务中会读取到另一个事务中还没有提交的数据，如果另一事务最终回滚了数据，那么所读取到的数据就是无效的。②不可重复读，一个事务中可以读取到另一个事务中已经提交的数据，在同一次事务中对同一数据读取的结果可能不同。③幻读，一个事务在读取数据时，当另一个事务在表中插入了一些新数据时再次读取表时会多出几行，如同出现了幻觉。</p><p><em><strong>*Q13：简述事务的ACID属性*</strong></em><br>答：①Atomicity表示原子性，事务中的所有操作都是不可分割的原子单位，要么全部成功，要么全部失败。②Consistency表示一致性，无论正常执行还是异常退出，事务执行前后数据的完整性必须保持一致，比如转账前后双方的总金额是不变的。③Isolation表示隔离性，并发操作中不同事务是互相隔离的，之间不会互相影响。④Durability表示持久性，事务操作完成后数据就会被持久化修改到永久存储中。</p><p><em><strong>*Q14：简述主从复制的基本原理*</strong></em><br>答：①主从复制是指一台服务器充当主数据库服务器，另外一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器中。对于多级复制，数据库服务器既可充当主机也可充当从机。②MySQL主从复制的基础是主服务器对数据库修改二进制记录，从服务器通过主服务器的二进制日志自动执行更新。</p><p><em><strong>*Q15：MySQL有哪些锁？*</strong></em><br>答：①按操作类型可以分为读锁（共享锁S）和写锁（排它锁X）。读锁：对同一份数据，多个读操作可以同时进行而不会互相影响。写锁：当前操作没有完成之前，会阻塞其他读锁和写锁。②按操作粒度分为行锁、表锁、页锁。行锁指对某行数据加锁，是一种排它锁。表锁指对当前操作的整张表加锁，实现简单，资源消耗较少。③页锁的锁定粒度介于行锁和表锁之间，一次锁定相邻的一组记录。</p><p><em><strong>*Q16：视图是什么？和普通的表有什么区别？*</strong></em><br>答：①视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。②视图相对于普通的表的优势主要包括以下几项：简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</p><p><em><strong>*Q17：存储过程和函数是什么？有什么区别？*</strong></em><br>答：①存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 ②两者的区别在于函数必须有返回值，而存储过程没有返回值。</p><p><em><strong>*Q18：触发器是什么？*</strong></em><br>答：①触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。②使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><p><em><strong>*Q19：了解MySQL的体系结构吗？*</strong></em><br>答：① 连接层：最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。②服务层：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。③ 引擎层：存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。④存储层：数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p><p><em><strong>*Q20：存储引擎应当怎样进行选择？*</strong></em><br>答：①在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。②InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。③MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。④MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。⑤MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。</p><p><em><strong>*Q21：优化SQL的步骤了解吗？*</strong></em><br>答：①查看SQL执行频率。②定位低效率执行SQL。可以通过以下两种方式：慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句。show processlist : 慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。③通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。④Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里了。⑤MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p><p> <em><strong>*Q22：请问数据库主键、外键和索引的区别？？*</strong></em></p><p>定义：<br>主键-唯一标识一条记录，不能有重复的，不允许为空<br>外键-表的外键是另一表的主键，外键可以有重复的，可以是空值<br>索引-该字段没有重复值，但可以有一个空值<br>作用：<br>主键-用来保证数据完整性<br>外键用来和其他表建立联系用的<br>索引一是提高查询排序的速度<br>个数：<br>主键-主键只能有一个<br>外键-一个表可以有多个外键<br>索引-一个表可以有多个唯一索引</p><h3 id="JDBC-10"><a href="#JDBC-10" class="headerlink" title="*JDBC 10*"></a><em><strong>*JDBC 10*</strong></em></h3><p><em><strong>*Q1：了解JDBC吗？*</strong></em><br>答：①JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库（java.sql,javax.sql），使用这些类库可以以一种标准的方法方便地访问数据库资源。<br>②JDBC为访问不同的数据库提供了统一的途径，为开发者屏蔽了一些细节问题。③JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p><p><em><strong>*Q2：JDBC的操作步骤？*</strong></em><br>答：①导入相应的jar包。②加载、注册sql驱动。③获取Connection连接对象。④创建Statement对象并执行SQL语句。⑤使用ResultSet对象获取查询结果集。⑥依次关闭ResultSet、Statement、Connection对象。</p><p><em><strong>*Q3：Statement和PrepatedStatement的区别是什么？*</strong></em><br>答：①Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。②PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。③使用Statement操作数据表存在弊端：存在拼串操作，繁琐；存在SQL注入问题。④PreparedStatement代码的可读性和可维护性更强，能实现更高效的批量操作。DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。在statement语句中,每执行一次都要对传入的语句编译一次。⑤PreparedStatement 可以防止 SQL 注入，还可以操作Blob类数据。</p><p><em><strong>*Q4：ResultSet对象存储的是什么？*</strong></em><br>答：①PreparedStatement 的 executeQuery()方法，查询结果是一个ResultSet 对象，<br>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现。②ResultSet 返回的实际上就是一张数据表，有一个指针指向数据表的第一条记录的前面。③ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的next()方法移动到下一行。调用 next()方法检测下一行是否存在。若存在，该方法返回true，且指针下移，相当于Iterator对象的 hasNext() 和 next()方法的结合体。可以通过调用对应的getXxx()获取每一列的值。</p><p><em><strong>*Q5：ResultSetMetaData对象存储的是什么？*</strong></em><br>答：①可用于获取关于 ResultSet 对象中列的类型和属性信息的对象。②通过调用ResultSet对象的getMetaData()方法获得ResultSetMetaData对象，getColumnName(int column)：获取指定列的名称，getColumnLabel(int column)：获取指定列的别名<br>，getColumnCount()：返回当前 ResultSet 对象中的列数。</p><p><em><strong>*Q6：JDBC要释放的资源有哪些，释放的顺序是什么？*</strong></em><br>答：①释放ResultSet, Statement,Connection。②数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统问题。Connection的使用原则是尽量晚创建，尽量早的释放。③可以在finally中释放资源，保证及时其他代码出现异常，资源也一定能被释放。</p><p><em><strong>*Q7：数据库连接池是什么？它的工作原理是怎样的？*</strong></em><br>答：①传统开发模式存在的问题：普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，数据库的连接资源并没有得到很好的重复利用。若在高并发情况下，频繁进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。②为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。③数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p><p><em><strong>*Q8：数据库连接池有哪些优点？*</strong></em><br>答：①资源重用：由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。② 更快的系统反应速度：数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。<br>③ 新的资源分配手段：对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。④ 统一的连接管理，避免数据库连接泄漏：在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露。</p><p><em><strong>*Q9：数据库连接池有哪些分类？*</strong></em><br>答：①JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现。②DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。③C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用。④Druid 是阿里提供的数据库连接池，集合了DBCP 、C3P0 、Proxool 的优点。</p><p><em><strong>*Q10：数据源DataSource和数据库连接Connection有什么区别？*</strong></em><br>答：①DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池。DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。②数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</p><h3 id="Redis-16"><a href="#Redis-16" class="headerlink" title="*Redis 16*"></a><em><strong>*Redis 16*</strong></em></h3><p><em><strong>*Q1：什么是NoSQL？列举几个你知道的NoSQL数据库。*</strong></em><br>答：①许多网站在海量用户访问的高并发情况下出现崩溃问题，根本原因是关系型数据库。关系型数据库有性能瓶颈：磁盘IO性能低下、扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群。②NoSQL即Not-Only SQL，泛指非关系型数据库，作为关系型数据库的补充，降低了磁盘IO次数——使用内存存储、去除数据间关系——不存储关系，仅存储数据。③NoSQL的特征：特征：可扩容，可伸缩；大数据量下高性能；灵活的数据模型；高可用。④常见的NoSQL数据库：Redis、memcache、HBase、MongoDB。</p><p><em><strong>*Q2：简单讲讲Redis的含义*</strong></em><br>答：①Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。②Redis数据库中的数据间没有必然的关联关系，内部采用单线程机制进行工作，性能比较高，支持持久化存储。③支持多种数据类型，包括字符串类型 string、列表类型 list、散列类型 hash、集合类型 set、有序集合类型 sorted_set。</p><p><em><strong>*Q3：Redis有哪些应用场景？*</strong></em><br>答：①为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等。②应用于任务队列，如秒杀、抢购、购票排队等。③即时信息查询，如排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等。④时效性信息控制，如验证码控制、投票控制等。⑤分布式数据共享，如分布式集群架构中的 session 分离以及消息队列、分布式锁等。</p><p><em><strong>*Q4：简述string类型的基本操作和注意事项*</strong></em><br>答：①存储的数据：单个数据，最简单常用的数据存储类型。存储数据的格式：一个存储空间保存一个数据。存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用。②添加/修改数据：set key value、获取数据：get key、删除数据：del key、添加/修改多个数据：mset key1 value1 key2 value2 …、获取多个数据：mget key1 key2 …、获取数据字符个数（字符串长度）：strlen key、追加信息到原始信息后部（如果原始信息存在就追加，否则新建）：append key value。③string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发 带来的数据影响。注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围（java中long型数据最大值，Long.MAX_VALUE）将报错。</p><p><em><strong>*Q5：简述hash类型的基本操作和注意事项*</strong></em><br>答：①存储需求：对一系列存储的数据进行编组，方便管理，一般存储对象信息。存储结构：一个存储空间保存多个键值对数据。底层使用哈希表结构实现数据存储。②如果field数量较少，存储结构优化为类数组结构；如果field数量较多，存储结构使用HashMap结构。③添加/修改数据：hset key field value、获取数据：hget key field，hgetall key、 删除数据：hdel key field1 [field2]、添加/修改多个数据：hmset key field1 value1 field2 value2 …、 获取多个数据：hmget key field1 field2 …、获取哈希表中字段的数量：hlen key、获取哈希表中是否存在指定的字段：hexists key field。③hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到， 对应的值为（nil）。每个 hash 可以存储 2^32 - 1 个键值对。hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，不可滥用，更不可以将hash作为对象列表使用。hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈。</p><p><em><strong>*Q6：简述list类型的基本操作和注意事项*</strong></em><br>答：①存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分。存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序。保存多个数据，底层使用双向链表存储结构实现。②添加/修改数据：lpush key value1 [value2] …，rpush key value1 [value2] …、获取数据：lrange key start stop，lindex key index，llen key、获取并移除数据：lpop key，rpop key。获取数据时可以设置等待时间，list为空时等待获取。移除指定数据：lrem key count value。③list中保存的数据都是string类型的，数据总容量是有限的，最多2^32- 1 个元素(4294967295)。list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作。获取全部数据操作结束索引设置为-1。list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载。</p><p><em><strong>*Q7：简述set类型的基本操作和注意事项*</strong></em><br>答：①存储需求：存储大量的数据，在查询方面提供更高的效率。存储结构：能够保存大量的数据，高效的内部存储机制，便于查询。与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。②添加数据：sadd key member1 [member2]、获取全部数据：smembers key、删除数据：srem key member1 [member2]、获取集合数据总量：scard key、判断集合中是否包含指定数据：sismember key member。③set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。</p><p><em><strong>*Q8：简述sorted-set类型的相关操作和注意事项*</strong></em><br>答：①存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式。存储结构：新的存储模型，可以保存可排序的数据，在set的存储结构基础上添加可排序字段。②添加数据：zadd key score1 member1 [score2 member2]、获取全部数据：zrange key start stop [WITHSCORES]，zrevrange key start stop [WITHSCORES]、删除数据：zrem key member [member …]。③score保存的数据存储空间是64位，超过该范围的话score保存的数据也可以是一个双精度的double值，但可能会丢失精度，使用时候要慎重。sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果。</p><p><em><strong>*Q9：Key有哪些通用指令？*</strong></em><br>答：①删除指定key：del key、获取key是否存在：exists key、获取key的类型：type key。②为指定key设置有效期：expire key seconds 单位秒，pexpire key milliseconds 单位毫秒、获取key的有效时间：ttl key 如果key不存在或key失效显示-2，没设置有效期或永久性显示-1，单位秒、pttl key以毫秒为单位、切换key从时效性转换为永久性：persist key。③查询key：keys pattern。查询模式规则：* 匹配任意数量的任意符号，? 配合一个任意符号，[] 匹配一个指定符号。④为key改名：rename key newkey、renamenx key newkey新名不存在时才可使用。</p><p><em><strong>*Q10：Redis如何解决key的重复问题？数据库有哪些基本操作？*</strong></em><br>答：①redis为每个服务提供有16个数据库，编号从0到15。每个数据库之间的数据相互独立。②切换数据库：select index、退出：quit、测试连通：ping、输出信息：echo message。③移动到其他数据库：move key db 、数据个数：dbsize 、清除该数据库：flushdb 、清除所有数据库：flushall 。</p><p><em><strong>*Q11：Jedis是什么？*</strong></em><br>答：①Jedis是一种利用Java语言连接redis的服务，需要依赖redis.clients下的jedis包。②通过new Jedis(String address,int port)创建一个操作redis数据库的对象，第一个参数是字符串类的ip地址，第二个参数是int类型的端口号。③之后通过Jedis类实例对象调用相关API实现对redis数据库的操作。</p><p><em><strong>*Q12：新闻网站会出现热点新闻，热点新闻最大的特征是时效性，如何自动控制热点新闻的时效性？*</strong></em><br>答：redis 可以控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作，使用String数据结构，通过setex key seconds value 可以设置数据有效的生命周期，有效时间以秒为单位，也可以通过psetex key milliseconds value设置数据的有效时间，有效时间以毫秒为单位。</p><p><em><strong>*Q13：你会如何设计与实现电商网站购物车？*</strong></em><br>答：①可以使用redis数据库，以客户id作为key，每位客户创建一个hash存储结构存储对应的购物车信息。②将商品编号作为field，购买数量作为value进行存储。③添加商品：追加全新的field与value。④浏览：遍历hash。⑤更改数量：自增/自减，设置value值。⑥删除商品：直接删除field。⑦清空购物车：直接删除key。⑧当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要二次查询数据库，将每条购物车中的商品记录保存成两条field，field1专用于保存购买数量，命名格式：商品id:nums 数值；field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等，命名格式：商品id:info json数据 。</p><p><em><strong>*Q14：双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000张，你会怎么解决？*</strong></em><br>答：①使用redis的hash数据结构，以商家id作为key、将参与抢购的商品id作为field、将参与抢购的商品数量作为对应的value。②抢购时使用降值的方式控制产品数量，通过hincrby key field increment实现对指定key的field值实现值的更新操作，例如hincrby CMCC card30:nums -10实现对移动的30元商品数量实现-10操作。</p><p><em><strong>*Q15：微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息，如果取消点赞，移除对应好友信息，你会怎么实现？*</strong></em><br>答：redis 可以应用于具有操作先后顺序的数据控制，可以使用list数据结构实现，点赞时使用rpush key value从右添加实现顺序显示功能，取消点赞通过lrem key count value从list左边开始移除指定数据。</p><p><em><strong>*Q16：每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？*</strong></em><br>答：①可以利用redis数据库的set数据结构完成，系统分析出各个分类的最新或最热点信息条目并组织成set集合，随机挑选其中部分信息，配合用户关注信息分类中的热点信息组织成展示的全信息集合。②通过srandmember key [count]随机获取集合中指定数量的数据，通过spop key [count]随机获取集合中的某个数据并将该数据移出集合。</p><h2 id="设计模式-29"><a href="#设计模式-29" class="headerlink" title="*设计模式 29*"></a><em><strong>*设计模式 29*</strong></em></h2><p><em><strong>*Q1：设计模式是什么？*</strong></em><br>答：设计模式是经过高度抽象化的在编程中可以被反复使用的代码设计经验的总结。正确使用设计模式能提高代码的可读性、可重用性和可靠性，编写符合设计模式规范的代码不但有利于自身系统的稳定、可靠，还有利于外部系统的对接。在使用了良好设计模式的系统工程中，无论是对满足当前的需求还是对适应未来的需求，无论是对自身系统间模块的对接还是对外部系统的对接，都有很大帮助。</p><p><em><strong>*Q2：设计模式有哪些原则？*</strong></em><br>答：①单一职责原则：单一职责原则又称单一功能原则，它规定一个类只有一个职责。如果有多个职责（功能）设计在一个类中，这个类就违反了单一职责原则。②开闭原则：<br>开闭原则规定软件中的对象（类、模块、函数等）对扩展开放，对修改封闭，这意味着一个实体允许在不改变其源代码的前提下改变其行为，该特性在产品化的环境下是特别有价值的，在这种环境下，改变源代码需要经过代码审查，单元测试等过程以确保产品的使用质量。遵循这个原则的代码在扩展时并不发生改变，因此不需要经历上述过程。③里氏代换原则：里氏代换原则是对开闭原则的补充，规定了在任意父类可以出现的地方，子类都一定可以出现。实现开闭原则的关键就是抽象化，父类与子类的继承关系就是抽象化的具体表现，所以里氏代换原则是对实现抽象化的具体步骤的规范。④依赖倒转原则：依赖倒转原则指程序要依赖于抽象（Java中的抽象类和接口），而不依赖于具体的实现（Java中的实现类）。简单地说，就是要求对抽象进行编程，不要求对实现进行编程，这就降低了用户与实现模块之间的耦合度。⑤接口隔离原则：接口隔离原则是指通过将不同的功能定义在不同的接口中来实现接口的隔离，这样就避免了其他类在依赖该接口（接口上定义的功能）时依赖其不需要的接口，可减少接口之间依赖的冗余性和复杂性。<br>⑥合成/聚合复用原则：合成/聚合复用原则指通过在一个新的对象中引入（注入）已有的对象以达到类的功能复用和扩展的目的。它的设计原则是要尽量使用合成或聚合而不要使用继承来扩展类的功能。⑦迪米特法则：迪米特法则指一个对象尽可能少地与其他对象发生相互作用，即一个对象对其他对象应该有尽可能少的了解或依赖。其核心思想在于降低模块之间的耦合度，提高模块的内聚性。迪米特法则规定每个模块对其它模块都要有尽可能少的了解和依赖，因此很容易使系统模块之间的功能独立，这使得各个模块的独立运行变得更加简单，同时使得各个模块之间的组合变得更加容易。</p><p><em><strong>*Q3：设计模式有哪些分类？*</strong></em><br>答：①创建型模式：提供了多种优雅创建对象的方法，包括工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。②结构型模式：通过类和接口之间的继承和引用实现创建复杂结构对象的功能，包括适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式、代理模式。③行为型模式：通过类之间不同的通信方式实现不同的行为方式，包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板模式、访问者模式。</p><p><em><strong>*Q4：简述工厂模式*</strong></em><br>答：①工厂模式是最常见的设计模式，该模式属于创建型模式，它提供了一种简单、快速、高效而安全地创建对象的方式。②工厂模式在接口中定义了创建对象的方法，而将具体的创建对象的过程在子类中实现，用户只需通过接口创建需要的对象即可，不用关注对象的具体创建过程。同时，不同的子类可根据需求灵活实现创建对象的不同方法。③通俗地讲，工厂模式的本质就是用工厂方法代替new操作创建一种实例化对象的方式，以便提供一种方便地创建有同种类型接口地产品的复杂对象。</p><p><em><strong>*Q5：简述抽象工厂模式*</strong></em><br>答：①抽象工厂模式在工厂模式上添加了一个创建不同工厂的抽象接口（抽象类或接口实现），该接口可叫做超级工厂。在使用过程中，我们首先通过抽象接口创建出不同的工厂对象，然后根据不同的工厂对象创建不同的对象。②在同一个厂商有多个维度的产品时，如果使用工厂模式，则势必会存在多个独立的工厂，这样的话设计和物理世界是不对应的。正确的做法是通过抽象工厂模式来实现，我们可以将抽象工厂类比成厂商，将通过抽象工厂创建出来的工厂类比成不同产品的生产线，在需要生产产品时根据抽象工厂生产。</p><p><em><strong>*Q6：讲一讲单例模式*</strong></em><br>答：①单例模式是保证系统实例唯一性的重要手段。单例模式首先通过将类的实例化方法私有化来防止程序通过其他方式创建该类的实例，然后通过提供一个全局唯一获取该类实例的方法帮助用户获取类的实例，用户只需也只能通过调用该方法获取类的实例。②单例模式的设计保证了一个类在整个系统中同一时刻只有一个实例存在，主要被用于一个全局类的对象在多个地方被使用并且对象的状态是全局变化的场景下。同时单例模式为系统资源的优化提供了很好的思路，频繁创建或销毁对象都会增加系统的资源消耗，而单例模式保障了整个系统只有一个对象能被使用，很好地节约了资源。③单例模式的实现很简单，每次在获取对象前都判断系统是否已经有这个单例对象，有则返回，无则创建。需要注意的是，单例模型的类构造器是私有的，只能由自身创建和销毁对象，不允许除了该类的其他程序使用new关键字创建对象及破坏单例模式。</p><p><em><strong>*Q7：懒汉模式线程安全吗？*</strong></em><br>答：①懒汉模式是线程不安全的，在需要时才会创建实例对象。②可以通过加synchronized锁实现线程安全的懒汉模式。③可以在加锁的基础上使用volatile关键字和双重校验锁进一步提升懒汉模式的线程安全性。</p><p><em><strong>*Q8：讲一讲建造者模式*</strong></em><br>答：①建造者模式使用多个简单的对象创建一个复杂的对象，用于将一个复杂的构建与其表示分离，使得同样的构建过程可以创建不同的表示，然后通过一个Builder类（该Builder类是独立于其他对象的）创建最终的对象。②建造者模式主要用于解决软件系统中复杂对象的创建问题，比如有些复杂对象的创建需要通过各部分的子对象用一定的算法构成，在需求变化时这些复杂对象将面临很大的改变，不利于系统稳定。但是使用建造者模式能将它们各部分的算法包装起来，在需求变化后只需调整各个算法的组合方式和顺序，能极大提供系统稳定性。建造者模式常被用于一些基本部件不会变而其组合经常变化的应用场景下。③建造者模式与工厂模式的最大区别是，建造者模式更关注产品的组合方式和装配顺序，而工厂模式关注产品的生产本身。④建造者模式在设计时有以下几种角色：Builder 创建一个复杂产品对象的抽象接口、ConcreteBuilder Builder接口的实现类，用于定义复杂产品各个部件的装配流程、Director 构造一个使用Builder接口的对象、Product 表示被构造的复杂对象，ConcreteBuilder定义了该复杂对象的装配流程，而Product定义了该复杂对象的结构和内部表示。</p><p><em><strong>*Q9：讲一讲原型模式*</strong></em><br>答：①原型模式指通过调用原型实例的Clone方法或其他手段来创建对象。②原型模式属于创建型设计模式，它以当前对象为原型来创建另一个新的对象，而无需知道创建的细节。原型模式在Java中通常使用Clone技术实现，在JavaScript中通常使用对象的原型属性实现。原型模式的Java实现很简单，只需要原型类实现Cloneable接口并重写clone方法即可。</p><p><em><strong>*Q10：浅复制和深复制的区别？*</strong></em><br>答：Java中的复制分为浅复制和深复制。①浅复制：Java中的浅复制是通过实现Cloneable接口并重写clone方法实现。在浅复制的过程中，对象的基本数据类型的变量值会重新被复制和创建，而引用数据类型仍指向原对象的引用，也就是说浅复制不复制对象的引用数据类型。②深复制：在深复制的过程中，不论是基本数据类型还是引用数据类型，都会被重新复制和创建。简而言之，深复制彻底复制了对象的数据，浅复制的复制不彻底（忽略了引用数据类型）。</p><p><em><strong>*Q11：讲一讲适配器模式*</strong></em><br>答：①适配器模式通过定义一个适配器类作为两个不兼容的接口之间的桥梁，将一个类的接口转换成用户期望的另一个接口，使得两个或多个原本不兼容的接口可以基于适配器类一起工作。②适配器模式主要通过适配器类实现各个接口之间的兼容，该类通过依赖注入或者继承实现各个接口的功能并对外统一提供服务。在适配器模式的实现中有三种角色：source、targetable、adapter。sourc是待适配的类，targetable是目标接口，adapter是适配器。我们在具体应用中通过adapter将source的功能扩展到targetable，以实现接口的兼容。适配器的实现主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。</p><p><em><strong>*Q12：讲一讲装饰者模式*</strong></em><br>答：①装饰者模式指在无需改变原有类及类的继承关系的情况下，动态扩展一个类的功能。它通过装饰者来包裹真实的对象，并动态地向对象添加或者撤销功能。②装饰者模式包括Source和Decorator两种角色，source是被装饰者，decorator是装饰者。装饰者模式通过装饰者可以为被装饰者Source动态地添加一些功能。</p><p><em><strong>*Q13：讲一讲代理模式*</strong></em><br>答：①代理模式指为对象提供一种通过代理的方式来访问并控制该对象行为的方法。在客户端不适合或者不能够直接引用一个对象时，可以通过该对象的代理对象实现对该对象的访问，可以将该代理对象理解为客户端和目标对象之间的中介者。②在代理模式下有两种角色，一种是被代理者，一种是代理（Proxy），在被代理者需要做一项工作时，不用自己做而是交给代理做。以企业招聘为例，不用自己去市场找，可以通过代理去找。</p><p><em><strong>*Q14：讲一讲外观模式*</strong></em><br>答：①外观模式也叫做门面模式，通过一个门面向客户端提供一个访问系统的统一接口，客户端无需关心和知晓系统内部各子模块（系统）之间的复杂关系，其主要目的是降低访问拥有多个子系统的复杂系统的难度，简化客户端与其之间的接口。外观模式将子系统中的功能抽象成一个统一的接口，客户端通过这个接口访问系统，使得系统使用起来更加容易。②简单来说外观模式就是将多个子系统及其之间的复杂关系和调用流程封装到一个统一的接口或类中以对外提供服务，这种模式设计三种角色：子系统角色：实现了子系统的功能；门面角色：外观模式的核心， 熟悉各子系统的功能和调用关系并根据客户端的需求封装统一的方法来对外提供服务；客户角色：通过调用门面来完成业务功能。</p><p><em><strong>*Q15：讲一讲桥接模式*</strong></em><br>答：①桥接模式通过将抽象及其实现解耦，使二者可以根据需求独立变化。这种类型的设计模式属于结构型模式，通过定义一个抽象和实现之间的桥接者来达到解耦的目的。②桥接模型主要用于解决在需求多变的情况下使用继承造成类爆炸的问题，扩展起来不够灵活。可以通过桥接模式将抽象部分与实现部分分离，使其能够独立变化而相互之间的功能不受影响。具体的做法是通过定义一个桥接接口，使得实体类的功能独立于接口实现类，降低他们之间的耦合度。</p><p><em><strong>*Q16：你知道哪些应用使用了桥接模式吗？*</strong></em><br>答：JDBC和DriverManager就使用了桥接模式，JDBC在连接数据库时，在各个数据库之间切换而不需要修改代码，因为JDBC提供了统一的接口，每个数据库都提供了各自的实现，通过一个叫做数据库驱动的程序来桥接即可。</p><p><em><strong>*Q17：讲一讲组合模式*</strong></em><br>答：①组合模式又叫做部分整体模式，主要用于实现部分和整体操作的一致性。组合模式常根据树形结构来表示部分及整体之间的关系，使得用户对单个对象和组合对象的操作具有一致性。②组合模式通过特定的数据结构简化了部分和整体之间的关系，使得客户端可以像处理单个元素一样来处理整体的数据集，而无需关心单个元素和整体数据集之间的内部复杂结构。</p><p><em><strong>*Q18：讲一讲享元模式*</strong></em><br>答：①享元模式主要通过对象的复用减少对象创建的次数和数量，减少系统内存的使用和降低系统负载。享元模式属于结构型模型，在系统需要一个对象时享元模式首先在系统中查找并尝试重用现有的对象，如果未找到匹配对象则创建新对象并将其缓存在系统中。②享元模式主要用于避免在有大量对象时频繁创建和销毁对象造成系统资源的浪费，把其中共同的部分抽象出来，如果有相同的业务请求则直接返回内存中已有的对象。</p><p><em><strong>*Q19：讲一讲策略模式*</strong></em><br>答：①策略模式为同一个行为定义了不同策略，为每种策略实现了不同方法。用户使用时系统根据不同的策略自动切换不同的方法实现策略的改变。同一策略下的不同方法是对同一功能的不同实现，因此在使用时可相互替换而不影响用户的使用。②策略模式的实现是在接口中定义不同的策略，在实现类中完成了对不同策略下具体行为的实现，并将用户的策略状态存储在上下文中来完成策略的存储和状态的改变。</p><p><em><strong>*Q20：讲一讲模板方法模式*</strong></em><br>答：①模板方法模式定义了一个算法框架，并通过继承的方式将算法的实现延迟到子类中，使得子类可以在不改变算法框架及其流程的前提下重新定义该算法在某些特定环节的实现，是一种类行为型模式。②该模式在抽象类中定义了算法的结构并实现了公共部分算法，在子类中实现可变的部分并根据不同的业务需求实现不同的扩展。模板方法模式的优点在于其父类（抽象类）中定义了算法的框架以及保障算法的稳定性，同时在父类中实现了算法公共部分的方法保证代码的复用，将部分算法延迟到子类实现，因此子类可以通过继承扩展或重新定义算法的功能而不影响稳定性，符合开闭原则。③抽象类：定义算法框架，由基本方法和模板方法组成。基本方法定义了算法有哪些环节，模板方法定义了算法各个环节执行的流程。具体子类：对在抽象类中定义的算法根据需求进行不同的实现。</p><p><em><strong>*Q21：讲一讲观察者模式*</strong></em><br>答：①观察者模式指在被观察者的状态发生变化时，系统基于事件驱动理论将其状态通知到订阅其状态的观察者对象中，以完成状态的修改和事件传播。观察者模式是一种对象行为模式，观察者和被观察者之间的关系属于抽象耦合关系，主要优点是观察者与被观察者之间建立了一套事件触发机制，以降低二者之间的耦合度。②观察者模式的主要角色如下：抽象主题Subject：持有订阅了该主题的观察者对象的集合，同时提供了增加删除观察者对象的方法和主题状态变化后的通知方法。具体主题Concrete Subject：实现了抽象主题的通知方法，在主题内部状态发生变化时，调用该方法通知订阅了主题状态的观察者对象。抽象观察者Observer：观察者的抽象类或接口，定义了主题状态变化时需要调用的方法。具体观察者 Concrete Observer：抽象观察者的实现类，在收到主题状态变化的信息后执行具体触发机制。</p><p><em><strong>*Q22：讲一讲迭代器模式*</strong></em><br>答：①迭代器模式提供了顺序访问集合对象中的各种元素，而不暴露该对象内部结构的方法。Java中的集合就是典型的迭代器模式，比如HashMap，当遍历HashMap时，需要迭代器不停地获取Next元素就可以循环遍历集合中所有元素。②迭代器模式将遍历集合中所有元素地操作封装成一个迭代器类，目的是在不暴露集合对象内部结构地情况下，对外提供统一访问集合内部数据的方法。迭代器的实现一般包括一个迭代器，用于执行具体的遍历操作，以及一个Collection，用于存储具体的数据。</p><p><em><strong>*Q23：讲一讲责任链模式*</strong></em><br>答：①责任链模式用于避免请求发送者与多个请求处理者耦合在一起，让所有请求的处理者持有下一个对象的引用，从而将请求串联成一条链，在有请求发生时，可将请求沿着这条链传递，直到遇到该对象的处理器。②该模式下用户只需将请求发送到责任链上即可，无需关心请求的处理细节和传递过程，所以责任链模式优雅地将请求的发送和处理进行了解耦。责任链模式常用于Web模式。③责任链模式包含以下三种角色：Handler接口：规定责任链上要执行的具体方法。AbstractHandler抽象类：持有Handler实例并通过get/set方法将各个具体的业务Handler串联成一个责任链，客户端上的请求在责任链上执行。业务Handler：用户根据具体的业务需求实现的业务逻辑。</p><p><em><strong>*Q24：讲一讲命令模式*</strong></em><br>答：①命令模式将请求封装为命令基于事件驱动异步执行，以实现命令的发送者和命令的执行者之间的解耦，提高命令发送执行的效率和灵活度。②命令模式主要包含以下角色：<br>抽象命令类：执行命令的接口，定义执行命令的抽象方法。具体命令类：抽象命令类的实现类，持有接收者对象，并在收到命令后调用命令执行者的方法action()实现命令的调用和执行。命令执行者：命令的具体执行者，定义了命令执行的具体方法action()。命令调用者：接收客户端的命令并异步执行。</p><p><em><strong>*Q25：讲一讲备忘录模式*</strong></em><br>答：①备忘录模式又叫做快照模式，该模式将当前对象的内部状态保存到备忘录中，以便在需要时能将对象的状态恢复到原先保存的状态。备忘录模式提供了一种保存和恢复状态的机制，常用于快照的记录和状态的存储，在系统发生鼓掌或数据发生不一致时能够方便地将数据恢复到某个历史状态。②备忘录的核心是设计备忘录类及用于管理备忘录的管理者类，主要角色如下：发起人Originator：记录当前时刻的内部状态，定义创建备忘录和回复备忘录数据的方法。备忘录Memento：负责存储对象的内部状态。状态管理者Storage：对备忘录的历史状态进行存储，定义了保存和获取备忘录状态的功能。注意备忘录只能被保存或恢复，不能进行修改。</p><p><em><strong>*Q26：讲一讲状态模式*</strong></em><br>答：①状态模式指给对象定义不同的状态，并为不同的状态定义不同的行为，在对象的状态发生变换时自动切换状态的行为。状态模式是一种对象行为型模式，它将对象的不同行为封装到不同的状态中，遵循单一职责原则。②具体角色如下：环境： 也叫做上下文，用于维护对象当前的状态，并在对象状态发生变化时触发对象行为的变化。抽象状态：定义接口，用于定义对象中不同状态对应行为。具体状态：抽象状态的实现类</p><p><em><strong>*Q27：讲一讲访问者模式*</strong></em><br>答：①访问者模式指将数据结构和数据的操作分离开来，使其在不改变数据结构的前提下动态添加作用于这些元素的操作。访问者模式通过定义不同的访问者实现对数据的不同操作，因此在需要给数据添加新的操作时只需为其定义一个新的访问者即可。②访问者模式是一种对象行为型模式，主要特点是将数据结构和作用于结构上的操作解耦，使得集合的操作可自由地演化而不影响其数据结构，它适用于数据结构稳定但操作多变的系统中。③主要角色如下：抽象访问者：定义了一个访问元素的接口，为每类元素都定义了一个访问操作，该操作中的参数类型对应被访问元素的数据类型。具体访问者：抽象访问者的实现类，实现了不同访问者访问元素后具体行为。抽象元素：定义了访问该元素的入口方法，不同访问者类型代表不同访问者。具体元素：实现抽象元素定义的入口方法，根据访问者的不同类型实现不同逻辑业务。</p><p><em><strong>*Q28：讲一讲中介者模式*</strong></em><br>答：①中介者模式指对象和对象之间不直接交互，而是通过一个名为中介者的角色来实现，使原有对象之间的关系变得松散，且可以通过定义不同的中介者来改变它们之间的交互。②主要包含以下角色：抽象中介者：中介者接口，定义了注册同事对象方法和转发同时对象信息的方法。具体中介者：中介者接口的实现类，定义了一个集合保存同事对象，协调各同事角色之间的交互关系。抽象同事类：定义同事的接口类，持有中介者对象，并定义同事对象交互的抽象方法，同时实现同事类的公共方法和功能。具体同事类：抽象同事的实现类，在需要与其他同事对象交互时，通过中介者对象来完成。</p><p><em><strong>*Q29：讲一讲解释器模式*</strong></em><br>答：①解释器模式给定一种语言，并定义该语言的语法表示，然后设计一个解释器来解释语言的语法，这种模式常被用于SQL解析、符号处理引擎等。②解释器模式包含以下主要角色：抽象表达式：定义解释器的接口，约定解释器所包含的操作。终结符表达式：抽象表达式的子类，用来定义语法中和终结符有关的操作，语法中的每一个终结符都应有一个与之对应的终结表达式。非终结符表达式：抽象表达式的子类，用来定义语法中和非终结符有关的操作，语法中的每条规则都有一个非终结符表达式与之对应。环境：定义各个解释器需要的共享数据或公共功能。</p><h2 id="计算机网络-7"><a href="#计算机网络-7" class="headerlink" title="*计算机网络 7*"></a><em><strong>*计算机网络 7*</strong></em></h2><p><em><strong>*Q1：说一说OSI网络模型*</strong></em><br>答：网络的七层架构从下到上主要包括物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。①****物理层*<em><strong>：物理层主要定义物理设备标准，主要作用是传输比特流，具体做法是在发送端将1、0转化为电流强弱来进行传输，在到达目的地之后再将电流强弱转化为1、0，也就是我们常说的模数转换与数模转换，这一层的数据叫做比特。②</strong></em>*数据链路层*<em><strong>：数据链路层主要用于对数据包中的MAC地址进行解析和封装。这一层的数据叫做帧，在这一层工作的设备是网卡、网桥、交换机。③</strong></em>*网络层*<em><strong>：网络层主要用于对数据包中的IP地址进行封装和解析，这一层的数据叫做数据包。在这一层工作的设备有路由器、交换机、防火墙等。④</strong></em>*传输层*<em><strong>：传输层定义了传输数据的协议和端口号，主要用于数据的分段、传输和重组。在这一层工作的协议有TCP和UDP等。TCP是传输控制协议，传输效率低，可靠性强，用于传输对可靠性要求高，数据量大的数据，比如支付宝转账业务；UDP是用户数据报协议，用于传输可靠性要求不高，数据量小的数据，例如抖音等视频服务。⑤</strong></em>*会话层*<em><strong>：会话层在传输层的基础上建立连接和管理会话，具体包括登陆验证、断点续传、数据粘包与分包等。在设备之间需要互相识别的可以是IP，也可以是MAC或者主机名。⑥</strong></em>*表示层*<em><strong>：表示层主要对接收的数据进行解释、加密、解密、压缩、解压缩等，即把计算机能够识别的内容转换成人能够识别的内容（图片、声音、文字等）。⑦</strong></em>*应用层****：基于网络构建具体应用，例如FTP上传文件下载服务、Telnet服务、HTTP服务、DNS服务、SNMP邮件服务等。</p><p><em><strong>*Q2：说一说TCP/IP的网络模型*</strong></em><br>答：TCP/IP不是指TCP和IP这两个协议的合称，而是指因特网的整个TCP/IP协议簇。从协议分层模型方面来讲，TCP/IP由4个层次组成：网络接口层、网络层、传输层和应用层。①****网络接口层*<em><strong>：定义了主机间网络连通的协议，具体包括Echernet、FDDI、ATM等通信协议。②</strong></em>*网络层*<em><strong>：主要用于数据的传输、路由及地址的解析，以保障主机可以把数据发送给任何网络上的目标。数据经过网络传输，发送的顺序和到达的顺序可能发生变化。在网络层使用IP协议和ARP地址解析协议。③</strong></em>*传输层*<em><strong>：使源端和目的端的机器上的对等实体可以基于会话相互通信。在这一层定义了两个端到端的协议TCP和UDP。TCP是面向连接的协议，提供可靠的报文传输和对上层应用的连接服务，除了基本的数据传输，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP是面向无连接的不可靠传输的协议，主要用于不需要TCP的排序和流量控制等功能的应用程序。④</strong></em>*应用层****：负责具体应用层协议的定义，包括Telnet虚拟终端协议、FTP文件传输协议、SMTP简单电子邮件传输协议、DNS域名解析服务、NNTP网上新闻传输协议和HTTP超文本传输协议等。</p><p><em><strong>*Q3：简述TCP的三次握手过程，为什么不是两次或四次？*</strong></em><br>答：①服务端创建传输控制块TCB，进入LISTEN状态，准备接收客户端的请求。客户端同样先创建TCB，然后当准备建立连接时向服务端发送连接请求报文（SYN=1，seq=x），然后进入SYN-SENT状态。②服务端收到后向客户端发送确认报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN-RCVD状态。③客户端接收到确认后，再向服务端发送一个确认报文（ACK=1，ack=y+1，seq=x+1），然后进入ESTABLISHED状态，服务端接收后也进入ESTABLISHED状态。<br>④不是两次的原因是为了避免无效的连接请求突然发送到服务端，而此时客户端已关闭，服务端误以为客户端将要发送数据会白白浪费资源。⑤不是四次的原因是将服务端的SYN和ACK报文拆分成两次发送和一次的效果是相同的，没有意义。</p><p><em><strong>*Q4：简述TCP的四次握手过程，为什么不是三次？*</strong></em><br>答：①当客户端准备关闭连接时，向服务端发送连接终止报文（FIN=1，seq=u），进入FIN-WAIT-1状态。②服务端接收后向客户端发送确认报文（ACK=1，ack=u+1，seq=v），进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态，此时TCP连接处于半关闭状态。③当服务端也发送完全部数据准备断开连接时，向客户发送连接终止报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST-ACK状态。④客户端接收到该报文后，发送一个确认报文（ACK=w+1，ack=1，seq=u+1），进入TIME-WAIT状态，然后等待2MSL时间后关闭。服务端收到后关闭，时间将略早于客户端。⑤不是三次的原因第一是为了保证客户端发送的最后一个报文可以到达服务端，如果该报文丢失那么服务端会超时重传之前的FIN+ACK报文，客户端可以在2MSL内收到，第二是防止已失效的报文发送到客户端，在2MSL后客户端在本连接时间内发出的所有报文都将从网络中消失。</p><p><em><strong>*Q5：简述HTTP的传输流程*</strong></em><br>答：①地址解析：地址解析通过域名系统DNS解析服务器域名从而获得主机的IP地址。例如客户端的浏览器请求<a href="http://localhost:8080/index.html%EF%BC%8C%E5%88%99%E5%8F%AF%E5%88%86%E6%9E%90%E5%87%BA%EF%BC%9A%E5%8D%8F%E8%AE%AE%E5%90%8DHTTP%E3%80%81%E4%B8%BB%E6%9C%BA%E5%90%8Dlocalhost%E3%80%81%E7%AB%AF%E5%8F%A38080%E3%80%81%E5%AF%B9%E8%B1%A1%E8%B7%AF%E5%BE%84/index.html%E3%80%82%E2%91%A1%E5%B0%81%E8%A3%85HTTP%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E5%90%8D%E3%80%81%E4%B8%BB%E6%9C%BA%E5%90%8D%E3%80%81%E7%AB%AF%E5%8F%A3%E3%80%81%E5%AF%B9%E8%B1%A1%E8%B7%AF%E5%BE%84%E7%AD%89%E5%B9%B6%E7%BB%93%E5%90%88%E6%9C%AC%E6%9C%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BF%A1%E6%81%AF%E5%B0%81%E8%A3%85%E6%88%90%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%85%E3%80%82%E2%91%A2%E5%B0%81%E8%A3%85TCP%E5%8C%85%EF%BC%9A%E5%B0%86HTTP%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B0%81%E8%A3%85%E6%88%90TCP%E6%95%B0%E6%8D%AE%E5%8C%85%E3%80%82%E2%91%A3%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%EF%BC%9A%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%BA%E5%88%B6%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E3%80%82%E2%91%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%9A%E5%9C%A8%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%90%8E%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82%E2%91%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E6%8E%A5%E6%94%B6%E5%88%B0%E8%AF%B7%E6%B1%82%E5%90%8E%EF%BC%8C%E7%BB%93%E5%90%88%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%8C%E7%84%B6%E5%90%8E%E5%90%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%94%E5%9B%9E%E7%9B%B8%E5%BA%94%E7%9A%84%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%E3%80%82%E5%9C%A8%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%E4%B8%AD%E5%8C%85%E5%90%AB%E7%8A%B6%E6%80%81%E8%A1%8C%E3%80%81%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E5%8F%B7%E3%80%81%E6%88%90%E5%8A%9F%E6%88%96%E9%94%99%E8%AF%AF%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%81%E6%B6%88%E6%81%AF%E4%BD%93%E7%AD%89%E5%86%85%E5%AE%B9%E3%80%82%E2%91%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E5%90%91%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%90%8E%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%E3%80%82%E4%BD%86%E5%A6%82%E6%9E%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%96%E8%80%85%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E6%B6%88%E6%81%AF%E5%A4%B4%E5%8A%A0%E5%85%A5%E4%BA%86Connection:keep-alive%EF%BC%8C%E5%88%99TCP%E8%BF%9E%E6%8E%A5%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%90%8E%E4%BB%8D%E7%84%B6%E4%BF%9D%E6%8C%81%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%EF%BC%8C%E5%9C%A8%E4%B8%8B%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E3%80%82%E9%87%87%E7%94%A8keep-alive%E4%B8%8D%E4%BD%86%E5%87%8F%E5%B0%91%E4%BA%86%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E8%BF%98%E8%8A%82%E7%BA%A6%E4%BA%86%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E3%80%82">http://localhost:8080/index.html，则可分析出：协议名HTTP、主机名localhost、端口8080、对象路径/index.html。②封装HTTP数据包：解析协议名、主机名、端口、对象路径等并结合本机自己的信息封装成一个HTTP请求数据包。③封装TCP包：将HTTP请求数据包进一步封装成TCP数据包。④建立TCP连接：基于TCP的三次握手机制建立TCP连接。⑤客户端发送请求：在建立连接后，客户端发送一个请求给服务器。⑥服务器响应：服务器在接收到请求后，结合业务逻辑进行数据处理，然后向客户端返回相应的响应信息。在响应信息中包含状态行、协议版本号、成功或错误的代码、消息体等内容。⑦服务器关闭TCP连接：服务器在向浏览器发送请求响应数据后关闭TCP连接。但如果浏览器或者服务器在消息头加入了Connection:keep-alive，则TCP连接在请求响应数据后仍然保持连接状态，在下一次请求中浏览器可以继续使用相同的连接发送请求。采用keep-alive不但减少了请求响应的时间，还节约了网络带宽和系统资源。</a></p><p><em><strong>*Q6：HTTPS是什么？*</strong></em><br>答：HTTPS是以安全为目标的HTTP通道，它在HTTP中加入****SSL层*<em><strong>以提高数据传输的安全性。HTTP被用于在Web浏览器和网站服务器之间传递信息，但以明文方式发送内容，</strong></em>*不提供任何方式的数据加密****，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP不适合传输一些敏感信息，比如身份证号码、密码等。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并对浏览器和服务器之间的通信进行数据加密，以保障数据传输的安全性，其端口一般是443。</p><p><em><strong>*Q7：简述HTTPS的加密流程*</strong></em><br>答：①发起请求：客户端在通过TCP和服务器建立连接之后（443端口），发出一个请求证书的消息给服务器，在该请求消息里包含自己可实现的算法列表和其他需要的消息。②证书返回：服务端在收到消息后回应客户端并返回证书，在证书中包含服务器信息、域名、申请证书的公司、公钥、数据加密算法等。③证书验证：客户端在收到证书后，判断证书签发机构是否正确，并使用该签发机构的公钥确认签名是否有效，客户端还会确认在证书中列出的域名就是它正在连接的域名。如果客户端确认证书有效，则生成对称密钥，并使用公钥将对称密钥加密。④密钥交换：客户端将加密后的对称密钥发送给服务器，服务器在接收到对称密钥后使用私钥解密。⑤数据传输：经过上述步骤，客户端和服务器就完成了密钥对的交换，在之后的数据传输过程中，客户端和服务端就可以基于对称加密（加密和解密使用相同密钥的加密算法）对数据加密后在网络上传输，保证了网络数据传输的安全性。</p><h2 id="操作系统-2"><a href="#操作系统-2" class="headerlink" title="*操作系统 2*"></a><em><strong>*操作系统 2*</strong></em></h2><p><em><strong>*Q1：进程和线程有什么区别？*</strong></em><br>答：①进程是一个具有独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度的一个独立单位。②线程是一种轻量级的进程，是一个基本的CPU执行单元也是程序执行流的最小单元。线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程不拥有系统资源，只拥有一点运行必备的资源，但可与其他同属一个进程的线程共享进程拥有的全部资源。③引入进程的目的是为了更好地使多道程序并发执行，提高系统资源利用率和吞吐量，增加并发程度。引入线程地目的使为了减小程序在并发执行时的开销，提高系统的并发能力。④堆是线程共享的，栈是线程私有的。</p><p><em><strong>*Q2：死锁产生的原因和解决方法？*</strong></em><br>答：①死锁是多个进程竞争共享资源而造成互相等待的僵局，若无外力作用这些进程都将无法向前推进。②死锁产生的原因是非剥夺资源的竞争和进程的不恰当推进顺序。③预防死锁：破坏****互斥条件*<em><strong>、破坏</strong></em>*不剥夺条件*<em><strong>、破坏</strong></em>*请求和保持条件*<em><strong>、破坏</strong></em>*循环等待条件****。④预防死锁：安全状态：能找到一个分配资源的序列让所有进程都顺序完成。银行家算法：采用预分配策略检查分配完成时系统是否处于安全状态。⑤检测死锁：利用死锁定理化简资源分配图检测死锁的存在。⑥解除死锁：资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便其他线程继续推进。撤销进程法：强制撤销部分、甚至全部进程并抢夺其资源，以便让其他进程继续推进。进程回退法：让一个或多个进程回退到足以避免死锁的地步。</p>]]></content>
      
      
      <categories>
          
          <category> 面试专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis核心组件面试题</title>
      <link href="/2023/03/03/mybatis-he-xin-zu-jian-mian-shi-ti/"/>
      <url>/2023/03/03/mybatis-he-xin-zu-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-核心组件-面试题"><a href="#MyBatis-核心组件-面试题" class="headerlink" title="MyBatis 核心组件 + 面试题"></a>MyBatis 核心组件 + 面试题</h2><p>[toc]</p><h3 id="MyBatis-介绍"><a href="#MyBatis-介绍" class="headerlink" title="MyBatis&nbsp;介绍"></a>MyBatis&nbsp;介绍</h3><p>MyBatis 是一款优秀的 ORM（Object Relational Mapping，对象关系映射）框架，它可以通过对象和数据库之间的映射，将程序中的对象自动存储到数据库中。它是 Apache 提供的一个开源项目，之前的名字叫做 iBatis，2010 年迁移到了 Google Code，并且将名字改为我们现在所熟知的 MyBatis，又于 2013 年 11 月迁移到了 Github。</p><p>MyBatis 提供了普通 SQL 查询、事务、存储过程等功能，它的优缺点如下。</p><p><strong>优点</strong>：</p><ul><li>相比于 JDBC 需要编写的代码更少</li><li>使用灵活，支持动态 SQL</li><li>提供映射标签，支持对象与数据库的字段关系映射</li></ul><p><strong>缺点</strong>：</p><ul><li>SQL 语句依赖于数据库，数据库移植性差</li><li>SQL 语句编写工作量大，尤其在表、字段比较多的情况下</li></ul><p>总体来说，MyBatis 是一个非常优秀和灵活的数据持久化框架，适用于需求多变的互联网项目，也是当前主流的 ORM 框架。</p><h4 id="MyBatis-重要组件"><a href="#MyBatis-重要组件" class="headerlink" title="MyBatis&nbsp;重要组件"></a>MyBatis&nbsp;重要组件</h4><p>MyBatis&nbsp;中的重要组件如下：</p><ul><li>Mapper 配置：用于组织具体的查询业务和映射数据库的字段关系，可以使用 XML 格式或 Java 注解格式来实现；</li><li>Mapper 接口：数据操作接口也就是通常说的 DAO 接口，要和 Mapper 配置文件中的方法一一对应；</li><li>Executor：MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 执行的；</li><li>SqlSession：类似于 JDBC 中的 Connection，可以用 SqlSession 实例来直接执行被映射的 SQL 语句；</li><li>SqlSessionFactory：SqlSessionFactory 是创建 SqlSession 的工厂，可以通过 SqlSession openSession() 方法创建 SqlSession 对象。</li></ul><h4 id="MyBatis-执行流程"><a href="#MyBatis-执行流程" class="headerlink" title="MyBatis 执行流程"></a>MyBatis 执行流程</h4><p>MyBatis 完整执行流程如下图所示：</p><p><img src="https://images.gitbook.cn/4070e4c0-da75-11e9-b7a4-5f21fd84c626"></p><p>MyBatis 执行流程说明：</p><ol><li>首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。</li><li>创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。</li><li>创建会话，根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession），会话对象是一个接口，该接口中包含了对数据库操作的增、删、改、查方法。</li><li>创建执行器，因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。</li><li>封装 SQL 对象，在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。</li><li>操作数据库，拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。</li></ol><h3 id="MyBatis-XML-版"><a href="#MyBatis-XML-版" class="headerlink" title="MyBatis&nbsp;XML&nbsp;版"></a>MyBatis&nbsp;XML&nbsp;版</h3><p>MyBatis&nbsp;使用分为两个版本：XML&nbsp;版和&nbsp;Java&nbsp;注解版。接下来我们使用 Spring Boot 结合 MyBatis 的 XML 版，来实现对数据库的基本操作，步骤如下。</p><h4 id="1）创建数据表"><a href="#1）创建数据表" class="headerlink" title="1）创建数据表"></a>1）创建数据表</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> <span class="token identifier"><span class="token punctuation">`</span>t_user<span class="token punctuation">`</span></span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token identifier"><span class="token punctuation">`</span>t_user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">auto_increment</span> <span class="token keyword">comment</span> <span class="token string">'主键id'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>username<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'用户名'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>password<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">null</span> <span class="token keyword">comment</span> <span class="token string">'密码'</span><span class="token punctuation">,</span>  <span class="token identifier"><span class="token punctuation">`</span>nick_name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">null</span><span class="token punctuation">,</span>  <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span> <span class="token keyword">auto_increment</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">default</span> <span class="token keyword">charset</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）添加依赖"><a href="#2）添加依赖" class="headerlink" title="2）添加依赖"></a>2）添加依赖</h4><p>在项目添加对 MyBatis 和 MySQL 支持的依赖包，在&nbsp;pom.xml&nbsp;文件中添加如下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>mybatis<span class="token operator">-</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">2.1</span><span class="token number">.0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>    <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>mysql<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>mysql<span class="token operator">-</span>connector<span class="token operator">-</span>java<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">8.0</span><span class="token number">.16</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mybatis-spring-boot-starter 是 MyBatis 官方帮助我们快速集成 Spring Boot 提供的一个组件包，mybatis-spring-boot-starter 2.1.0 对应 MyBatis 的版本是 3.5.2。</p><h4 id="3）增加配置文件"><a href="#3）增加配置文件" class="headerlink" title="3）增加配置文件"></a>3）增加配置文件</h4><p>在&nbsp;application.yml&nbsp;文件中添加以下内容：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">spring<span class="token operator">:</span>  datasource<span class="token operator">:</span>    url<span class="token operator">:</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>learndb<span class="token operator">?</span>serverTimezone<span class="token operator">=</span><span class="token constant">UTC</span><span class="token operator">&amp;</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>characterEncoding<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span><span class="token operator">&amp;</span>useSSL<span class="token operator">=</span><span class="token boolean">true</span>    username<span class="token operator">:</span> root    password<span class="token operator">:</span> root    driver<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>name<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span></span>Driver</span>mybatis<span class="token operator">:</span>  config<span class="token operator">-</span>location<span class="token operator">:</span> classpath<span class="token operator">:</span>mybatis<span class="token operator">/</span>mybatis<span class="token operator">-</span>config<span class="token punctuation">.</span>xml  mapper<span class="token operator">-</span>locations<span class="token operator">:</span> classpath<span class="token operator">:</span>mybatis<span class="token operator">/</span>mapper<span class="token comment">/*.xml  type-aliases-package: com.interview.mybatislearning.model</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li>mybatis.config-location：配置 MyBatis 基础属性；</li><li>mybatis.mapper-locations：配置 Mapper 对应的 XML 文件路径；</li><li>mybatis.type-aliases-package：配置项目中实体类包路径。</li></ul><p>注：如果配置文件使用的是&nbsp;application.properties，配置内容是相同的，只是内容格式不同。</p><h4 id="4）创建实体类"><a href="#4）创建实体类" class="headerlink" title="4）创建实体类"></a>4）创建实体类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserEntity</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5980266333958177104L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> passWord<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> nickName<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">UserEntity</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">,</span> <span class="token class-name">String</span> passWord<span class="token punctuation">,</span> <span class="token class-name">String</span> nickName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>passWord <span class="token operator">=</span> passWord<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nickName <span class="token operator">=</span> nickName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> userName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getPassWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> passWord<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPassWord</span><span class="token punctuation">(</span><span class="token class-name">String</span> passWord<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>passWord <span class="token operator">=</span> passWord<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nickName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNickName</span><span class="token punctuation">(</span><span class="token class-name">String</span> nickName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nickName <span class="token operator">=</span> nickName<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5）创建-XML-文件"><a href="#5）创建-XML-文件" class="headerlink" title="5）创建&nbsp;XML&nbsp;文件"></a>5）创建&nbsp;XML&nbsp;文件</h4><p><strong>mybatis-config.xml</strong>（基础配置文件）：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">configuration</span> <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="token string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Integer<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Integer<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Long<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Long<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HashMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.util.HashMap<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LinkedHashMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.util.LinkedHashMap<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ArrayList<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.util.ArrayList<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LinkedList<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.util.LinkedList<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mybatis-config.xml&nbsp;主要是为常用的数据类型设置别名，用于减少类完全限定名的长度，比如：<code>resultType="Integer"</code>&nbsp;完整示例代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getAllCount<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Integer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    select    count(*)    from t_user<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>UserMapper.xml</strong>（业务配置文件）：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">mapper</span> <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.interview.mybatislearning.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.interview.mybatislearning.model.UserEntity<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BIGINT<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userName<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>passWord<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nick_name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nickName<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Base_Column_List<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>        id, username, password, nick_name    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Base_Where_List<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userName != null  and userName != ''<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            and userName = #{userName}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span>  <span class="token punctuation">&gt;</span></span>        SELECT        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Base_Column_List<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        FROM t_user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getOne<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Long<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BaseResultMap<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>        SELECT        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Base_Column_List<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        FROM t_user        WHERE id = #{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insert<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.interview.mybatislearning.model.UserEntity<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>       INSERT INTO               t_user               (username,password,nick_name)           VALUES               (#{userName}, #{passWord}, #{nickName})    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>update</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>update<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.interview.mybatislearning.model.UserEntity<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>        UPDATE        t_user        SET        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userName != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>username = #{userName},<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>passWord != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>password = #{passWord},<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>        nick_name = #{nickName}        WHERE        id = #{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>delete<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Long<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>       DELETE FROM                t_user       WHERE                id =#{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上配置我们增加了增删改查等基础方法。</p><h4 id="6）增加-Mapper-文件"><a href="#6）增加-Mapper-文件" class="headerlink" title="6）增加&nbsp;Mapper&nbsp;文件"></a>6）增加&nbsp;Mapper&nbsp;文件</h4><p>此步骤我们需要创建一个与&nbsp;XML&nbsp;对应的业务&nbsp;Mapper&nbsp;接口，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserEntity</span><span class="token punctuation">&gt;</span></span> <span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">UserEntity</span> <span class="token function">getOne</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">UserEntity</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">UserEntity</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7）添加-Mapper-包扫描"><a href="#7）添加-Mapper-包扫描" class="headerlink" title="7）添加 Mapper 包扫描"></a>7）添加 Mapper 包扫描</h4><p>在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.interview.mybatislearning.mapper"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisLearningApplication</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">MyBatisLearningApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8）编写测试代码"><a href="#8）编写测试代码" class="headerlink" title="8）编写测试代码"></a>8）编写测试代码</h4><p>经过以上步骤之后，整个&nbsp;MyBatis&nbsp;的集成就算完成了。接下来我们写一个单元测试，验证一下。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MybatislearningApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserEntity</span><span class="token punctuation">(</span><span class="token string">"laowang"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">,</span> <span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> userMapper<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本文我们知道 MyBatis 是一个优秀和灵活的数据持久化框架，MyBatis 包含 Mapper 配置、Mapper 接口、Executor、SqlSession、SqlSessionFactory 等几个重要的组件，知道了 MyBatis 基本流程：MyBatis 首先加载 Mapper 配置和 SQL 映射文件，通过创建会话工厂得到 SqlSession 对象，再执行 SQL 语句并返回操作信息。我们也使用 XML 的方式，实现了 MyBatis 对数据库的基础操作。</p>]]></content>
      
      
      <categories>
          
          <category> 面试专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> 面试 </tag>
            
            <tag> Mapper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类和接口的应用面试题</title>
      <link href="/2023/03/03/chou-xiang-lei-he-jie-kou-de-ying-yong-mian-shi-ti/"/>
      <url>/2023/03/03/chou-xiang-lei-he-jie-kou-de-ying-yong-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类和接口的应用-面试题"><a href="#抽象类和接口的应用-面试题" class="headerlink" title="抽象类和接口的应用 + 面试题"></a>抽象类和接口的应用 + 面试题</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。简单来说，使用关键字 <strong>abstract</strong> 修饰的类就叫做抽象类。</p><h4 id="抽象类使用"><a href="#抽象类使用" class="headerlink" title="抽象类使用"></a>抽象类使用</h4><p>示例代码，如下：</p><pre class="line-numbers language-none"><code class="language-none">abstract class AbstractAnimal {    public AbstractAnimal() {        System.out.println("Init AbstractAnimal.");    }    static String name = "AbstractAnimal";    public abstract void eat();    public void run() {        System.out.println("AbstractAnimal Run.");    }}class Animal extends AbstractAnimal {    public static void main(String[] args) {        AbstractAnimal animal = new Animal();        animal.run();        System.out.println(animal.name);        animal.eat();    }      @Override    public void eat() {        System.out.println("Animal Eat.");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码执行的结果：</p><pre class="line-numbers language-none"><code class="language-none">Init AbstractAnimal.AbstractAnimal Run.AbstractAnimalAnimal Eat.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>使用 <strong>abstract</strong> 关键字修饰的方法叫做抽象方法，抽象方法仅有声明没有方法体。如下代码：</p><pre class="line-numbers language-none"><code class="language-none">public abstract void m();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="抽象类的特性"><a href="#抽象类的特性" class="headerlink" title="抽象类的特性"></a>抽象类的特性</h4><ul><li>抽象类不能被初始化</li><li>抽象类可以有构造方法</li><li>抽象类的子类如果为普通类，则必须重写抽象类中的所有抽象方法</li><li>抽象类中的方法可以是抽象方法或普通方法</li><li>一个类中如果包含了一个抽象方法，这个类必须是抽象类</li><li>子类中的抽象方法不能与父类中的抽象方法同名</li><li>抽象方法不能为 private、static、final 等关键字修饰</li><li>抽象类中可以包含普通成员变量，访问类型可以任意指定，也可以使用静态变量（static）</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>接口（interface）是抽象类的延伸，它允许一个类可以实现多个接口，弥补了抽象类不能多继承的缺陷，接口是对类的描述，使用 <strong>interface</strong> 关键字来声明。</p><h4 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h4><p>示例代码，如下：</p><pre class="line-numbers language-none"><code class="language-none">interface IAnimal {    void run();}class AnimalImpl implements IAnimal {    public static void main(String[] args) {        IAnimal animal = new AnimalImpl();        animal.run();    }    @Override    public void run() {        System.out.println("AnimalImpl Run.");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Java-8-中接口的改动"><a href="#Java-8-中接口的改动" class="headerlink" title="Java 8 中接口的改动"></a>Java 8 中接口的改动</h4><p><strong>1）接口中增加了 default 方法和 static 方法，可以有方法体</strong><br>示例代码，如下：</p><pre class="line-numbers language-none"><code class="language-none">interface IAnimal {    static void printSex() {        System.out.println("Male Dog");    }    default void printAge() {        System.out.println("18");    }}class AnimalImpl implements IAnimal {    public static void main(String[] args) {        IAnimal.printSex();        IAnimal animal = new AnimalImpl();        animal.printAge();  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：static 方法属于接口方法，可以直接使用；default 属于实例方法，必须先创建实例。</p><p><strong>2）接口中的静态变量会被继承</strong><br>示例代码，如下：</p><pre class="line-numbers language-none"><code class="language-none">interface IAnimal {    static String animalName = "Animal Name";    static void printSex() {        System.out.println("Male Dog");    }}class AnimalImpl implements IAnimal {    public static void main(String[] args) {        System.out.println(animalName);        IAnimal.printSex();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：静态变量会被继承，静态方法不会被继承。</p><p><strong>3）新增函数式接口</strong></p><p>函数式接口（Function Interface）是一个特殊的接口，使用 <code>@FunctionInterface</code> 注解声明，定义这种接口可以使用 <strong>Lambda</strong> 表达式直接调用。<br>示例代码，如下：</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfaceinterface IAnimal {    static String animalName = "Animal Name";    static void printSex() {        System.out.println("Male Dog");    }    default void printAge() {        System.out.println("18");    }    void sayHi(String name);}class FunctionInterfaceTest {    public static void main(String[] args) {        IAnimal animal = name -&gt; System.out.println(name);        animal.sayHi("WangWang");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：使用 <code>@FunctionInterface</code>&nbsp;声明的函数式接口，抽象方法必须有且仅有一个，但可以包含其他非抽象方法。</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-抽象类中能不能包含方法体？"><a href="#1-抽象类中能不能包含方法体？" class="headerlink" title="1. 抽象类中能不能包含方法体？"></a>1. 抽象类中能不能包含方法体？</h4><p>答：抽象类中可以包含方法体。抽象类的构成也可以完全是包含方法体的普通方法，只不过这样并不是抽象类最优的使用方式。</p><p>题目解析：包含了方法体的抽象类示例代码如下：</p><pre class="line-numbers language-none"><code class="language-none">abstract class AbstractAnimal {    public void run() {        System.out.println("AbstractAnimal Run.");    }}class Animal extends AbstractAnimal {    public static void main(String[] args) {        AbstractAnimal animal = new Animal();        animal.run();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码执行的结果是： <code>AbstractAnimal Run.</code></p><h4 id="2-抽象类能不能被实例化？为什么？"><a href="#2-抽象类能不能被实例化？为什么？" class="headerlink" title="2. 抽象类能不能被实例化？为什么？"></a>2. 抽象类能不能被实例化？为什么？</h4><p>答：抽象类不能被实例化，因为抽象类和接口的设计就是用来规定子类行为特征的，就是让其他类来继承，是多态思想的一种设计体现，所以强制规定抽象类不能被实例化。</p><h4 id="3-抽象方法可以被-private-修饰吗？为什么？"><a href="#3-抽象方法可以被-private-修饰吗？为什么？" class="headerlink" title="3. 抽象方法可以被 private 修饰吗？为什么？"></a>3. 抽象方法可以被 private 修饰吗？为什么？</h4><p>答：抽象方法不能使用 private 修饰，因为抽象方法就是要子类继承重写的，如果设置 private 则子类不能重写此抽象方法，这与抽象方法的设计理念相违背，所以不能被 private 修饰。</p><h4 id="4-添加以下哪个选项不会引起编译器报错？"><a href="#4-添加以下哪个选项不会引起编译器报错？" class="headerlink" title="4. 添加以下哪个选项不会引起编译器报错？"></a>4. 添加以下哪个选项不会引起编译器报错？</h4><pre class="line-numbers language-none"><code class="language-none">abstract class AbstractAnimal {    static String animalName = "AbstractAnimal";      }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>A：protected abstract void eat();<br>B： void eat();<br>C：abstract void eat(){};<br>D：animalName += “Cat”;</p><p>答：A</p><p>题目解析：选项 B 普通方法必须有方法体；选项 C 抽象方法不能有方法体；选项 D 变量赋值操作必须在方法内。</p><h4 id="5-以下关于抽象类和抽象方法说法正确的是？"><a href="#5-以下关于抽象类和抽象方法说法正确的是？" class="headerlink" title="5. 以下关于抽象类和抽象方法说法正确的是？"></a>5. 以下关于抽象类和抽象方法说法正确的是？</h4><p>A：抽象类中的方法必须全部为抽象方法<br>B： 抽象类中必须包含一个抽象方法<br>C：抽象类中不能包含普通方法<br>D：抽象类中的方法可以全部为普通方法（包含方法体）</p><p>答：D</p><p>题目解析：抽象类中可以没有方法或者全部为普通方法，都是允许的，如下代码所示：</p><pre class="line-numbers language-none"><code class="language-none">abstract class AbstractAnimal {    public void run() {        System.out.println("AbstractAnimal Run.");    }}class Animal extends AbstractAnimal {    public static void main(String[] args) {        AbstractAnimal animal = new Animal();        animal.run();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序执行的结果为：AbstractAnimal Run.</p><h4 id="6-接口和普通类有什么关系？"><a href="#6-接口和普通类有什么关系？" class="headerlink" title="6. 接口和普通类有什么关系？"></a>6. 接口和普通类有什么关系？</h4><p>答：在 Java 语言设计中，接口不是类，而是对类的一组需求描述，这些类必须要遵循接口描述的统一格式进行定义。</p><h4 id="7-接口能不能有方法体？"><a href="#7-接口能不能有方法体？" class="headerlink" title="7. 接口能不能有方法体？"></a>7. 接口能不能有方法体？</h4><p>答：JDK 8 之前接口不能有方法体，JDK 8 之后新增了 static 方法和 default 方法，可以包含方法体。</p><h4 id="8-执行以下代码会输出什么结果？"><a href="#8-执行以下代码会输出什么结果？" class="headerlink" title="8. 执行以下代码会输出什么结果？"></a>8. 执行以下代码会输出什么结果？</h4><pre class="line-numbers language-none"><code class="language-none">interface IAnimal {    static String animalName = "Animal Name";}class AnimalImpl implements IAnimal {    static String animalName = new String("Animal Name");    public static void main(String[] args) {        System.out.println(IAnimal.animalName == animalName);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答：执行的结果为 false。</p><p>题目解析：子类使用 new String… 重新创建了变量 animalName，又因为使用 == 进行内存地址比较，所以结果就是 false。</p><h4 id="9-抽象类和接口有什么区别？"><a href="#9-抽象类和接口有什么区别？" class="headerlink" title="9. 抽象类和接口有什么区别？"></a>9. 抽象类和接口有什么区别？</h4><p>答：抽象类和接口的区别，主要分为以下几个部分。</p><ul><li>默认方法</li><li>抽象类可以有默认方法的实现</li><li>JDK 8 之前接口不能有默认方法的实现，JDK 8 之后接口可以有默认方法的实现</li><li>继承方式</li><li>子类使用 extends 关键字来继承抽象类</li><li>子类使用 implements 关键字类实现接口</li><li>构造器</li><li>抽象类可以有构造器</li><li>接口不能有构造器</li><li>方法访问修饰符</li><li>抽象方法可以用 public / protected / default 等修饰符</li><li>接口默认是 public 访问修饰符，并且不能使用其他修饰符</li><li>多继承</li><li>一个子类只能继承一个抽象类</li><li>一个子类可以实现多个接口</li></ul><h4 id="10-以下抽象方法描述正确的是？"><a href="#10-以下抽象方法描述正确的是？" class="headerlink" title="10. 以下抽象方法描述正确的是？"></a>10. 以下抽象方法描述正确的是？</h4><p>A：抽象方法可以是静态（static）的<br>B：抽象方法可同时是本地方法（native）<br>C：抽象方法可以被 synchronized 修饰<br>D：以上都不是</p><p>答：D</p><p>题目解析：抽象方法需要被子类重写，而静态方法是无法被重写的，因此抽象方法不能被静态（static）修饰；本地方法是由本地代码实现的方法，而抽象方法没有实现，所以抽象方法不能同时是本地方法；synchronized 和方法的实现细节有关，而抽象方法不涉及实现细节，因此抽象方法不能被 synchronized 修饰。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象类和接口都是面向对象编程中多态的具体实现，在 Java 编程思想中占据着重要的地位，同时也是初级面试岗位必问的问题之一，但由于接口在 JDK 8 中的改动比较大，因而面试者在网上搜到的绝大数关于接口和抽象类区别的答案也是不准确的，这点需要面试者特别注意一下。</p>]]></content>
      
      
      <categories>
          
          <category> 面试专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 抽象类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试题汇总</title>
      <link href="/2023/03/03/mysql-mian-shi-ti-hui-zong/"/>
      <url>/2023/03/03/mysql-mian-shi-ti-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-面试题汇总"><a href="#MySQL-面试题汇总" class="headerlink" title="MySQL 面试题汇总"></a>MySQL 面试题汇总</h2><p>[toc]</p><h4 id="1-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#1-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="1. 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>1. 说一下 MySQL 执行一条查询语句的内部执行过程？</h4><p>答：MySQL 执行一条查询的流程如下：</p><ul><li>客户端先通过连接器连接到 MySQL 服务器；</li><li>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器；</li><li>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器；</li><li>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好；</li><li>优化器执行完就进入执行器，执行器则开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li></ul><h4 id="2-MySQL-查询缓存有什么优缺点？"><a href="#2-MySQL-查询缓存有什么优缺点？" class="headerlink" title="2.MySQL 查询缓存有什么优缺点？"></a>2.MySQL 查询缓存有什么优缺点？</h4><p>答：MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。</p><p>查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。</p><h4 id="3-MySQL-的常用引擎都有哪些？"><a href="#3-MySQL-的常用引擎都有哪些？" class="headerlink" title="3.MySQL 的常用引擎都有哪些？"></a>3.MySQL 的常用引擎都有哪些？</h4><p>答：MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p><h4 id="4-常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#4-常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="4. 常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>4. 常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h4><p>答：InnoDB 和 MyISAM 最大的区别是&nbsp;InnoDB 支持事务，而&nbsp;MyISAM 不支持事务，它们其他主要区别如下：</p><ul><li>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</li><li>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</li><li>InnoDB 支持外键，MyISAM 不支持外键；</li><li>MyISAM 性能比&nbsp;InnoDB 高；</li><li>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</li><li>InnoDB 主键查询性能高于 MyISAM。</li></ul><h4 id="5-什么叫回表查询？"><a href="#5-什么叫回表查询？" class="headerlink" title="5. 什么叫回表查询？"></a>5. 什么叫回表查询？</h4><p>答：普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p><h4 id="6-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#6-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="6. 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>6. 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h4><p>答：不是，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p><h4 id="7-一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#7-一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="7. 一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>7. 一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h4><p>答：如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p><h4 id="8-什么是独立表空间和共享表空间？它们的区别是什么？"><a href="#8-什么是独立表空间和共享表空间？它们的区别是什么？" class="headerlink" title="8. 什么是独立表空间和共享表空间？它们的区别是什么？"></a>8. 什么是独立表空间和共享表空间？它们的区别是什么？</h4><p>答：共享表空间指的是数据库的所有表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。</p><p>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。</p><p>共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，因此表依然很大，而独立表空间如果删除表就会清除空间。</p><h4 id="9-清空表的所有数据性能最好的语句是？"><a href="#9-清空表的所有数据性能最好的语句是？" class="headerlink" title="9. 清空表的所有数据性能最好的语句是？"></a>9. 清空表的所有数据性能最好的语句是？</h4><p>A：delete from t<br>B：delete t<br>C：drop table t<br>D：truncate table t</p><p>答：D</p><p>题目解析：truncate 清除表数据不会写日志，delete 要写日志，因此 truncate 的效率要高于 delete。</p><h4 id="10-唯一索引和普通索引哪个性能更好？"><a href="#10-唯一索引和普通索引哪个性能更好？" class="headerlink" title="10. 唯一索引和普通索引哪个性能更好？"></a>10. 唯一索引和普通索引哪个性能更好？</h4><p>答：唯一索引和普通索引的性能对比分为以下两种情况：</p><ul><li>对于查询来说两者都是从索引树进行查询，性能几乎没有任何区别；</li><li>对于更新操作来说，因为唯一索引需要先将数据读取到内存，然后需要判断是否有冲突，因此比普通索引要多了判断操作，从而性能就比普通索引性能要低。</li></ul><h4 id="11-left-join-和-right-join-的区别是什么？"><a href="#11-left-join-和-right-join-的区别是什么？" class="headerlink" title="11.left join 和 right join 的区别是什么？"></a>11.left join 和 right join 的区别是什么？</h4><p>答：left join 和 right join 的区别如下：</p><ul><li>left join（左联结），返回左表全部记录和右表联结字段相等的记录；</li><li>right join（右联结），返回右表全部记录和左表联结字段相等的记录。</li></ul><h4 id="12-什么是最左匹配原则？它的生效原则有哪些？"><a href="#12-什么是最左匹配原则？它的生效原则有哪些？" class="headerlink" title="12. 什么是最左匹配原则？它的生效原则有哪些？"></a>12. 什么是最左匹配原则？它的生效原则有哪些？</h4><p>答：最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，指的是索引以最左边为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)：</p><ul><li>where a=1 只使用了索引 a；</li><li>where a=1 and b=2 只使用了索引 a,b；</li><li>where a=1 and b=2 and c=3 使用 a,b,c；</li><li>where b=1 or where c=1 不使用索引；</li><li>where a=1 and c=3 只使用了索引 a；</li><li>where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。</li></ul><h4 id="13-以下-or-查询有什么问题吗？该如何优化？"><a href="#13-以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="13. 以下 or 查询有什么问题吗？该如何优化？"></a>13. 以下 or 查询有什么问题吗？该如何优化？</h4><blockquote><p>select * from t where num=10 or num=20;</p></blockquote><p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p><blockquote><p>select * from t where num=10</p><p>union</p><p>select * from t where num=20;</p></blockquote><h4 id="14-事务是什么？它有什么特性？"><a href="#14-事务是什么？它有什么特性？" class="headerlink" title="14. 事务是什么？它有什么特性？"></a>14. 事务是什么？它有什么特性？</h4><p>答：事务是一系列的数据库操作，是数据库应用的基本单位。</p><p>在 MySQL 中只有 InnoDB 引擎支持事务，它的四个特性如下：</p><ul><li>原子性（Atomic），要么全部执行，要么全部不执行；</li><li>一致性（Consistency），事务的执行使得数据库从一种正确状态转化为另一种正确状态；</li><li>隔离性（Isolation），在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</li><li>持久性（Durability），事务提交后，其结果永久保存在数据库中。</li></ul><h4 id="15-MySQL-中有几种事务隔离级别？分别是什么？"><a href="#15-MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="15.MySQL 中有几种事务隔离级别？分别是什么？"></a>15.MySQL 中有几种事务隔离级别？分别是什么？</h4><p>答：MySQL 中有四种事务隔离级别，分别是：</p><ul><li>read uncommited，未提交读，读到未提交数据；</li><li>read committed，读已提交，也叫不可重复读，两次读取到的数据不一致；</li><li>repetable read，可重复读；</li><li>serializable，串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</li></ul><p>MySQL 默认使用&nbsp;repetable read 的事务隔离级别。</p><h4 id="16-如何设置-MySQL-的事务隔离级别？"><a href="#16-如何设置-MySQL-的事务隔离级别？" class="headerlink" title="16. 如何设置 MySQL 的事务隔离级别？"></a>16. 如何设置 MySQL 的事务隔离级别？</h4><p>答：MySQL 事务隔离级别 mysql.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置：</p><blockquote><p>transaction-isolation = REPEATABLE-READ</p></blockquote><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><h4 id="17-MySQL-出现了中文乱码该如何解决？"><a href="#17-MySQL-出现了中文乱码该如何解决？" class="headerlink" title="17.MySQL 出现了中文乱码该如何解决？"></a>17.MySQL 出现了中文乱码该如何解决？</h4><p>答：解决 MySQL 中文乱码的问题，可以设置全局编码或设置某个数据库或表的编码为 utf8。 设置全局编码：</p><pre class="line-numbers language-none"><code class="language-none">set character_set_client='utf8';set character_set_connection='utf8';set character_set_results='utf8';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置数据库的编码：</p><pre class="line-numbers language-none"><code class="language-none">alter database db character set utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置表的编码：</p><pre class="line-numbers language-none"><code class="language-none">alter table t character set utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="18-InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？"><a href="#18-InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？" class="headerlink" title="18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？"></a>18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h4><p>答：因为 B 树、Hash、红黑树或二叉树存在以下问题。</p><ul><li>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</li><li>Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高。</li><li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。</li><li>红黑树：树的高度随着数据量增加而增加，IO 代价高。</li></ul><h4 id="19-MySQL-是如何处理死锁？"><a href="#19-MySQL-是如何处理死锁？" class="headerlink" title="19.MySQL&nbsp;是如何处理死锁？"></a>19.MySQL&nbsp;是如何处理死锁？</h4><p>答：MySQL 对待死锁常见的两种策略：</p><ul><li>通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时；</li><li>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。</li></ul><h4 id="20-什么是全局锁？它的应用场景有哪些？"><a href="#20-什么是全局锁？它的应用场景有哪些？" class="headerlink" title="20. 什么是全局锁？它的应用场景有哪些？"></a>20. 什么是全局锁？它的应用场景有哪些？</h4><p>答：全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全量逻辑备份，这个时候整个库会处于完全的只读状态。</p><h4 id="21-使用全局锁会导致什么问题？"><a href="#21-使用全局锁会导致什么问题？" class="headerlink" title="21. 使用全局锁会导致什么问题？"></a>21. 使用全局锁会导致什么问题？</h4><p>答：使用全局锁会使整个系统不能执行更新操作，所有的更新业务会出于等待状态；如果你是在从库进行备份，则会导致主从同步严重延迟。</p><h4 id="22-InnoDB-存储引擎有几种锁算法？"><a href="#22-InnoDB-存储引擎有几种锁算法？" class="headerlink" title="22.InnoDB 存储引擎有几种锁算法？"></a>22.InnoDB 存储引擎有几种锁算法？</h4><p>答：InnoDB 的锁算法包括以下三种：</p><ul><li>Record Lock — 单个行记录上的锁；</li><li>Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</li><li>Next-Key Lock — 锁定一个范围，包括记录本身。</li></ul><h4 id="23-InnoDB-如何实现行锁？"><a href="#23-InnoDB-如何实现行锁？" class="headerlink" title="23.InnoDB 如何实现行锁？"></a>23.InnoDB 如何实现行锁？</h4><p>答：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁。使用 for update 来实现行锁，具体脚本如下：</p><blockquote><p>select * from t where id=1 for update</p></blockquote><p>其中 id 字段必须有索引。</p><h4 id="24-MySQL-性能指标都有哪些？如何得到这些指标？"><a href="#24-MySQL-性能指标都有哪些？如何得到这些指标？" class="headerlink" title="24.MySQL 性能指标都有哪些？如何得到这些指标？"></a>24.MySQL 性能指标都有哪些？如何得到这些指标？</h4><p>答：MySQL 最重要的性能指标有以下两个：</p><ul><li>QPS（Queries Per Second），每秒查询数，一台数据库每秒能够处理的查询次数；</li><li>TPS（Transactions Per Second），每秒处理事务数。</li></ul><p>这些性能指标可以通过 show status 来查询当前数据库状态的结果信息中估算出来，show status 会有 300 多条状态信息记录，其中以下这些信息 QPS 和 TPS 有关系：</p><ul><li>Uptime，服务器已经运行的时间，单位秒；</li><li>Questions，已经发送给数据库查询数；</li><li>Com_select，查询次数，实际查询次数；</li><li>Com_insert，插入次数；</li><li>Com_delete，删除次数；</li><li>Com_update，更新次数；</li><li>Com_commit，事务次数；</li><li>Com_rollback，回滚次数。</li></ul><h4 id="25-MySQL-中的重要日志分为哪几个？"><a href="#25-MySQL-中的重要日志分为哪几个？" class="headerlink" title="25.MySQL 中的重要日志分为哪几个？"></a>25.MySQL 中的重要日志分为哪几个？</h4><p><strong>① 错误日志</strong>：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p><blockquote><p>mv hostname.err &nbsp;hostname.err.old</p><p>mysqladmin flush-logs</p></blockquote><p><strong>② 查询日志</strong>：查询日志在 MySQL 中被称为 general log（通用日志），查询日志里的内容不要被 “查询日志” 误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p><ul><li>insert 查询为了避免数据冲突，如果此前插入过数据，则当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</li><li>update 时也会查询因为更新的时候很可能会更新某一块数据；</li><li>delete 查询，只删除符合条件的数据；</li></ul><p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。</p><p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，因此，可以根据自己的实际情况来决定是否开启查询日志。</p><p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p><blockquote><p>set global general_log=1</p><p>set global log_output=’table’;</p></blockquote><p>general_log=1 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p><p><strong>③ 慢日志</strong>：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p><blockquote><p>set global slow_query_log=’ON’;</p></blockquote><p>使用 set global slow_query_log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。因此如果要永久生效，就要修改配置文件 my.cnf，设置 slow_query_log=1 并重启 MySQL 服务器。</p><p><strong>④ redo log（重做日志）</strong>：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。</p><p><strong>⑤ undo log（回滚日志）</strong>：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。undo log 默认存放在共享表空间中，在 ySQL 5.6 中，undo log 的存放位置还可以通过变量 innodb_undo_directory 来自定义存放目录，默认值为 “.” 表示 datadir 目录。</p><p><strong>⑥ bin log（二进制日志）</strong>：是一个二进制文件，主要记录所有数据库表结构变更，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，bin log 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其他额外信息，但是它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句。 binlog 的作用如下：</p><ul><li>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</li><li>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</li><li>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</li></ul><p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p><p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。</p><p>通过以下命令来查询 binlog 是否开启：</p><blockquote><p>show variables like ‘log_%’;</p></blockquote><p><img src="https://images.gitbook.cn/48857550-df7e-11e9-9b80-07a210d8c96e"></p><p>binlog 格式分为 STATEMENT、ROW 和 MIXED 三种。</p><ul><li>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，因此相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间，并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL，比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如，InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制。</li><li>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，因此，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，因此可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等。</li><li>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT_USER()、ROW_COUNT() 等无法确定的函数。</li></ul><h4 id="26-redo-log-和-binlog-有什么区别？"><a href="#26-redo-log-和-binlog-有什么区别？" class="headerlink" title="26.redo log&nbsp;和&nbsp;binlog&nbsp;有什么区别？"></a>26.redo log&nbsp;和&nbsp;binlog&nbsp;有什么区别？</h4><p>redo log（重做日志）和 binlog（归档日志）都是&nbsp;MySQL&nbsp;的重要的日志，它们的区别如下：</p><ul><li>redo log 是物理日志，记录的是 “在某个数据页上做了什么修改”；</li><li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 ID=2 这一行的 c 字段加 1”；</li><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用；</li><li>redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的，“追加写” 是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，因此 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p><h4 id="27-慢查询日志的获取方式有哪些？"><a href="#27-慢查询日志的获取方式有哪些？" class="headerlink" title="27. 慢查询日志的获取方式有哪些？"></a>27. 慢查询日志的获取方式有哪些？</h4><p>答：慢查询日志的常见获取方式如下。</p><ul><li>使用 MySQL 自带功能，开启慢查询日志，在 MySQL 的安装目录下找到 my.cnf 文件设置 <code>slow-query-log=On</code> 开启慢查询，慢查询默认时长为 10s，默认存储文件名为 host_name-slow.log。</li><li>使用三方开源方案 zabbix，zabbix 是一个基于 Web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案，能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位 / 解决存在的各种问题。</li></ul><h4 id="28-如何定位慢查询？"><a href="#28-如何定位慢查询？" class="headerlink" title="28. 如何定位慢查询？"></a>28. 如何定位慢查询？</h4><p>答：使用 MySQL 中的 explain 分析执行语句，比如：</p><blockquote><p>explain select * from t where id=5;</p></blockquote><p>如下图所示：</p><p><img src="https://images.gitbook.cn/5ec8ebd0-df7e-11e9-9b80-07a210d8c96e"></p><p>其中：</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行</li><li>select_type&nbsp;— 表示查询的类型。</li><li>table&nbsp;— 输出结果集的表</li><li>partitions&nbsp;— 匹配的分区</li><li>type&nbsp;— 表示表的连接类型</li><li>possible_keys&nbsp;— 表示查询时，可能使用的索引</li><li>key&nbsp;— 表示实际使用的索引</li><li>key_len&nbsp;— 索引字段的长度</li><li>ref—&nbsp; 列与索引的比较</li><li>rows&nbsp;— 大概估算的行数</li><li>filtered&nbsp;— 按表条件过滤的行百分比</li><li>Extra&nbsp;— 执行情况的描述和说明</li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li>all — 扫描全表数据</li><li>index — 遍历索引</li><li>range — 索引范围查找</li><li>index_subquery — 在子查询中使用 ref</li><li>unique_subquery — 在子查询中使用 eq_ref</li><li>ref_or_null — 对 null 进行索引的优化的 ref</li><li>fulltext — 使用全文索引</li><li>ref — 使用非唯一索引查找数据</li><li>eq_ref — 在 join 查询中使用主键或唯一索引关联</li><li>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</li></ul><h4 id="29-MySQL-中常见的读写分离方案有哪些？"><a href="#29-MySQL-中常见的读写分离方案有哪些？" class="headerlink" title="29.MySQL 中常见的读写分离方案有哪些？"></a>29.MySQL 中常见的读写分离方案有哪些？</h4><p>答：MySQL 中常见的读写分离方案通常为以下两种：</p><ul><li>使用 MySQL 官方提供的数据库代理产品 MySql ProxySQL 搭建自动分配的数据库读写分离环境；</li><li>在程序层面配置多数据源使用代码实现读写分离。</li></ul><h4 id="30-怎样保证主备数据库无延迟？"><a href="#30-怎样保证主备数据库无延迟？" class="headerlink" title="30. 怎样保证主备数据库无延迟？"></a>30. 怎样保证主备数据库无延迟？</h4><p>答：通常保证主备数据库无延迟有以下三种方法。</p><ul><li>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds_behind_master 参数是用来衡量主备延迟时间的长短。</li><li>对比位点确保主备无延迟。Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li><li>对比 GTID 集合确保主备无延迟。Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li></ul><h4 id="31-什么是-MySQL-多实例，如何配置-MySQL-多实例？"><a href="#31-什么是-MySQL-多实例，如何配置-MySQL-多实例？" class="headerlink" title="31. 什么是 MySQL 多实例，如何配置 MySQL 多实例？"></a>31. 什么是 MySQL 多实例，如何配置 MySQL 多实例？</h4><p>答：MySQL 多实例就是在同一台服务器上启用多个 MySQL 服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展。 多实例的配置方法有两种：</p><ul><li>一个实例一个配置文件，不同端口；</li><li>同一配置文件（my.cnf）下配置不同实例，基于 MySQL 的 d_multi 工具。</li></ul><h4 id="32-表的优化策略有哪些？"><a href="#32-表的优化策略有哪些？" class="headerlink" title="32. 表的优化策略有哪些？"></a>32. 表的优化策略有哪些？</h4><p>「参考答案」常见的大表优化策略如下。</p><ul><li>读写分离，主库负责写，从库负责读。</li><li>垂直分区，根据数据属性单独拆表甚至单独拆库。</li><li>水平分区，保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中。水平拆分只是解决了单一表数据过大的问题，表数据还在同一台机器上，对于并发能力没有什么意义，因此水平拆分最好分库。另外分片事务难以解决，跨节点 join 性能较差。</li></ul><h4 id="33-数据库分片方案有哪些？"><a href="#33-数据库分片方案有哪些？" class="headerlink" title="33. 数据库分片方案有哪些？"></a>33. 数据库分片方案有哪些？</h4><p>「参考答案」数据库分片方案有哪些？ 答：数据库创建的分片方案有两种方式：客户端代理方式和中间件代理方式。</p><ul><li>客户端代理 — 分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现，比如 Sharding-JDBC、阿里 TDDL 等。</li><li>中间件代理 — 在应用层和数据层中间加了一个代理层。分片逻辑统一维护在中间件服务中，比如 MyCat、网易的 DDB 都是中间件代理的典型代表。</li></ul><h4 id="34-查询语句的优化方案有哪些？"><a href="#34-查询语句的优化方案有哪些？" class="headerlink" title="34. 查询语句的优化方案有哪些？"></a>34. 查询语句的优化方案有哪些？</h4><p>「参考答案」常见优化方案如下：</p><ul><li>不做列运算，把计算都放入各个业务系统实现；</li><li>查询语句尽可能简单，大语句拆小语句，减少锁时间；</li><li>不使用 select * 查询；</li><li>or 查询改写成 in 查询；</li><li>不用函数和触发器；</li><li>避免 %xx 查询；</li><li>少用 join 查询；</li><li>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123；</li><li>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描；</li><li>列表数据使用分页查询，每页数据量不要太大。</li></ul><h4 id="35-MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？"><a href="#35-MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？" class="headerlink" title="35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？"></a>35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h4><p>「参考答案」可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：</p><ul><li>定期断开空闲的长连接；</li><li>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql_reset_connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matery主题的配置</title>
      <link href="/2023/03/03/matery-zhu-ti-de-pei-zhi/"/>
      <url>/2023/03/03/matery-zhu-ti-de-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>本主题<strong>推荐你使用 Hexo 5.0.0 及以上的版本</strong>。如果，你已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了，建议你将 Hexo 升级到最新稳定的版本。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>git clone</code> 命令来下载:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2022-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2022-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2022-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建留言板-contact-页（可选的）"><a href="#新建留言板-contact-页（可选的）" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h3><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"contact"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> contact<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2022-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h3 id="新建友情链接-friends-页（可选的）"><a href="#新建友情链接-friends-页（可选的）" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2022-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h3><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token number">404</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> <span class="token number">404</span><span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2022-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"Oops～，我崩溃了！找不到你想要的页面 :("</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon"><a href="#配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找   </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二级菜单配置方法"><a href="#二级菜单配置方法" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)     </li><li>在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.      </li><li>注意每个二级菜单模块前要加 <code>-</code>.     </li><li>注意缩进格式</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle<span class="token punctuation">-</span>o  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book  <span class="token key atrule">Medias</span><span class="token punctuation">:</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>list    <span class="token key atrule">children</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Music        <span class="token key atrule">url</span><span class="token punctuation">:</span> /music        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>music      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Movies        <span class="token key atrule">url</span><span class="token punctuation">:</span> /movies        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>film      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Books        <span class="token key atrule">url</span><span class="token punctuation">:</span> /books        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>book      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Galleries        <span class="token key atrule">url</span><span class="token punctuation">:</span> /galleries        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音（建议安装）"><a href="#中文链接转拼音（建议安装）" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i <span class="token parameter variable">--save</span> hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true.</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true.</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长.</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）"><a href="#添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）"><a href="#添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="添加中文繁简转换"><a href="#添加中文繁简转换" class="headerlink" title="添加中文繁简转换"></a>添加中文繁简转换</h3><p>在主题的 <code>_config.yml</code> 文件中，开启 translate 为 enable。</p><blockquote><p>开启中文繁简转换如下修改。默认不开启。<br>实例演示： <a href="https://blog.17lai.site/">繁简转换</a> 底下 footer 栏</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">translate</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;% if (theme.socialLink.github) { %&gt;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= theme.socialLink.github %&gt;<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fab fa-github<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 是否在首页显示音乐</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span>         <span class="token comment"># 非吸底模式有效</span>    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">show</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">server</span><span class="token punctuation">:</span> netease   <span class="token comment"># require music platform: netease, tencent, kugou, xiami, baidu</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> playlist    <span class="token comment"># require song, playlist, album, search, artist</span>  <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">503838841</span>     <span class="token comment"># require song id / playlist id / album id / search keyword</span>  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token comment"># 开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>   <span class="token comment"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span>       <span class="token comment"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'random'</span>   <span class="token comment"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span>   <span class="token comment"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7</span>       <span class="token comment"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 列表默认折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="添加note"><a href="#添加note" class="headerlink" title="添加note"></a>添加note</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-note">演示</a></p></blockquote><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><pre class="line-numbers language-none"><code class="language-none">{% note [class] [no-icon] [summary] %}Any content (support inline tags too).{% endnote %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>[class]</code> : <em>Optional parameter.</em> Supported values: default | primary | success | info | warning | danger.</li><li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon in note.</li><li><code>[summary]</code> : <em>Optional parameter.</em> Optional summary of the note.</li></ul><p>All parameters are optional.</p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><pre class="line-numbers language-none"><code class="language-none">{% note %}#### Header(without define class style){% endnote %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加button"><a href="#添加button" class="headerlink" title="添加button"></a>添加button</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-button">演示</a></p></blockquote><h4 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h4><pre class="line-numbers language-none"><code class="language-none">{% button url, text, icon [class], [title] %}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>or</p><pre class="line-numbers language-none"><code class="language-none">{% btn url, text, icon [class], [title] %}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>url</code> : Absolute or relative path to URL.</li><li><code>text</code> : Button text. Required if no icon specified.</li><li><code>icon</code> : Font Awesome icon name. Required if no text specified.</li><li><code>[class]</code> : <em>Optional parameter.</em> Font Awesome class(es): <code>fa-fw</code> | <code>fa-lg</code> | <code>fa-2x</code> | <code>fa-3x</code> | <code>fa-4x</code> | <code>fa-5x</code></li><li><code>[title]</code> : <em>Optional parameter.</em> Tooltip at mouseover.</li></ul><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre class="line-numbers language-none"><code class="language-none">{% button #, Text %}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2022-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2022-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">hide</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230308110633329.png" alt="首页"></p><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230308111505718.png" alt="首页推荐文章"></p><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230308111655571.png" alt="文章分类"></p><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230308111857788.png" alt="关于"></p><p><img src="https://cdn.jsdelivr.net/gh/hasaki99/Computer-Graduation-Design-Notes@main/images/image-20230308112035623.png" alt="文章内容"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本变更记录"><a href="#版本变更记录" class="headerlink" title="版本变更记录"></a>版本变更记录</h2><p>参见 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/CHANGELOG.md">CHANGELOG.md</a></p><h2 id="更多部署方式"><a href="#更多部署方式" class="headerlink" title="更多部署方式"></a>更多部署方式</h2><blockquote><p>Jsdelivr 已经被封了，这两个可以加速访问快一点</p></blockquote><h3 id="vercel-部署"><a href="#vercel-部署" class="headerlink" title="vercel 部署"></a><a href="https://blog.17lai.site/posts/5311b619/#vercel-%E9%83%A8%E7%BD%B2">vercel 部署</a></h3><h3 id="cloudflare-Pages-部署"><a href="#cloudflare-Pages-部署" class="headerlink" title="cloudflare Pages 部署"></a><a href="https://blog.17lai.site/posts/5311b619/#cloudflare-Pages-%E9%83%A8%E7%BD%B2">cloudflare Pages 部署</a></h3>]]></content>
      
      
      <categories>
          
          <category> 主题美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> 美化 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装与配置</title>
      <link href="/2023/03/02/centos7-an-zhuang-yu-pei-zhi/"/>
      <url>/2023/03/02/centos7-an-zhuang-yu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS7安装与配置"><a href="#CentOS7安装与配置" class="headerlink" title="CentOS7安装与配置"></a>CentOS7安装与配置</h1><h2 id="1-安装比较简单，重点在配置磁盘"><a href="#1-安装比较简单，重点在配置磁盘" class="headerlink" title="1.安装比较简单，重点在配置磁盘"></a>1.安装比较简单，重点在配置磁盘</h2><p>  选择手动分区，一般选择LVM或Standard Partition(标准分区)</p><p>进入分区页面/boot分区默认1024M，swap分区为实际内存的1-2倍，除swap外其他分区系统文件类型选择ext4。</p><p> <strong>！注意</strong></p><p><strong>(1)有的机器若有/boot/efi分区，那必须要配。</strong></p><p><strong>(2)在使用U盘安装系统的过程中若进入到到dracut界面，则是机器没有找到你的U盘。这个配置是需要在上一步需要完成的，但在上一步我们并不知道U盘的文件名，所以索性在这一步查看一下U盘的设备名具体命令为 cd /dev ;输入 blkid 查看块设备的文件系统类型、LABEL、UUID等信息,然后记下设备名 按Ctrl+Alt+Delete重启回到安装界面，然后再回到安装界面,按下e或Tab进入编辑模式，将vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso quiet 这一行改成vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4(设备名) quite，改完按下Ctrl+x或Enter执行,就可以正常安装CentOS系统了。</strong></p><p><img src="https://juge233.oss-cn-hangzhou.aliyuncs.com/typora_img/image-20221019141121629.png" alt="image-20221019141121629"></p><h2 id="2-关闭selinux"><a href="#2-关闭selinux" class="headerlink" title="2.关闭selinux"></a>2.关闭selinux</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/selinux/config<span class="token assign-left variable">SELINUX</span><span class="token operator">=</span>disabled<span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-优化ulimit"><a href="#3-优化ulimit" class="headerlink" title="3.优化ulimit"></a>3.优化ulimit</h2><p>修改/etc/security/limits.conf 加入以下两行,reboot重启生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">soft nofile <span class="token number">32768</span>hard nofile <span class="token number">65536</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-配置网卡"><a href="#4-配置网卡" class="headerlink" title="4.配置网卡"></a>4.配置网卡</h2><p>ip addr查看网卡信息，由于CentOS mini安装没有net-tools工具包，不能使用ifconfig 查看地址，使用 yum install -y net-tools（yum install net-tools.x86_64）可以安装</p><p>编辑网卡配置文件#vi /etc/sysconfig/network-scripts/ifcfg-enxxx（网卡名称）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>none<span class="token assign-left variable">NAME</span><span class="token operator">=</span>enp7s0<span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>enp7s0<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes<span class="token assign-left variable">IPADDR</span><span class="token operator">=</span><span class="token number">10.10</span>.1.112<span class="token assign-left variable">GATEWAY</span><span class="token operator">=</span><span class="token number">10.10</span>.1.254<span class="token assign-left variable">DNS1</span><span class="token operator">=</span><span class="token number">114.114</span>.114.114<span class="token assign-left variable">DNS2</span><span class="token operator">=</span><span class="token number">8.8</span>.8.8<span class="token assign-left variable">PREFIX</span><span class="token operator">=</span><span class="token number">24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后执行service network restart或者/etc/init.d/network restart 来重启网络</p><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5.常用命令"></a>5.常用命令</h2><p>shutdown -h now 关闭系统  /halt 关闭系统  poweroff /关闭系统</p><p>shutdown -r now 重启 / reboot 重启</p><p>查看防火墙状态:systemctl status firewalld<br>systemctl stop   firewalld<br>systemctl disable firewalld<br>查看防火墙是否关闭状态:systemctl is-enabled firewalld</p><p>修改主机名称:vim /etc/hostname</p><p>配置主机名称映射:vim /etc/hosts</p><p>重启网卡/etc/init.d/network restart</p><p>ls -a　　列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来<br>ls -l (简写ll)　 显示文件和目录的详细资料</p><p>mkdir命令：创建</p><p>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录 </p><p>rm命令：删除</p><p>rm -f file1　　 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 　　删除一个叫做 ‘dir1’ 的目录’ （空目录才能删除）<br>rm -rf dir1 　　删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2　　 同时删除两个目录及它们的内容 </p><p>mv命令：该命令用于移动文件、目录或更名，move之意，它的常用参数如下：-f 如果目标文件已经存在，不会询问而直接覆盖</p><p>mv file1 file2  把文件file1重命名为file2 </p><p>mv file1 file2 dir  把文件file1、file2移动到目录dir中</p><p>cp命令：该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下， 它的常用参数如下：</p><p>cp -a file1 file2 连同文件的所有特性把文件file1复制成文件file2<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p><p>find命令：find是一个基于查找的功能非常强大的命令</p><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 </p><p>ps命令：该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：</p><p>-A ：所有的进程均显示出来<br>-a ：不与terminal有关的所有进程<br>-u ：有效用户的相关进程<br>-x ：一般与a参数一起使用，可列出较完整的信息<br>-l ：较长，较详细地将PID的信息列出<br>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：</p><p>ps aux  查看系统所有的进程数据<br>ps ax  查看不与terminal有关的所有进程<br>ps -lA  查看系统所有的进程数据<br>ps axjf  查看连同一部分进程树状态</p><p>kill命令：该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：</p><p>kill -signal PID<br>signal的常用参数如下：注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。</p><p>1：SIGHUP，启动被终止的进程<br>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行<br>9：SIGKILL，强制中断一个进程的进行<br>15：SIGTERM，以正常的结束进程方式来终止进程<br>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行<br>例如：</p><p># 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程<br>kill -SIGTERM %1<br># 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得<br>kill -SIGHUP PID</p><p>tar命令：该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：</p><ol><li>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 </li><li>查询：tar -jtv -f filename.tar.bz2 </li><li>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li></ol><p>chmod命令：该命令用于改变文件的权限，一般的用法如下：</p><p>chmod -R 777   chmod -R 777 意思就是将当前目录及目录下所有文件都给予777权限（所有权限）</p><p><strong>查看文件内容</strong><br>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p><h2 id="6-还是命令-更全"><a href="#6-还是命令-更全" class="headerlink" title="6.还是命令(更全)"></a>6.还是命令(更全)</h2><p><strong>Linux常用命令大全（非常全！！！）</strong></p><p>最近都在和Linux打交道，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。我将我了解到的命令列举一下，仅供大家参考：</p><p><strong>系统信息</strong><br>arch 显示机器的处理器<a href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&amp;spm=1001.2101.3001.7020">架构</a><br>uname -m 显示机器的处理器架构<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p><p><strong>关机 (系统的关机、重启以及登出 )</strong><br>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销 </p><p><strong>文件和目录</strong><br>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p><p>cp -r dir1 dir2 复制一个目录及子目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p><p><strong>文件搜索</strong><br>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径 </p><p><strong>挂载一个文件系统</strong><br>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p><p><strong>磁盘空间</strong><br>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p><p><strong>用户和群组</strong><br>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p><p><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p><p><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong><br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p><p><strong>打包和压缩文件</strong><br>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p><p><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong><br>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p><p><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong><br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p><p><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong><br>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p><p><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong><br>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p><p><strong>查看文件内容</strong><br>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p><p><strong>文本处理</strong><br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p><p><strong>字符设置和文件格式转换</strong><br>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式 </p><p><strong>文件系统分析</strong><br>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </p><p><strong>初始化一个文件系统</strong><br>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统 </p><p><strong>SWAP文件系统</strong><br>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p><p><strong>备份</strong><br>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p><p><strong>光盘</strong><br>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p><p><strong>网络 - （以太网和WIFI无线</strong>）<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’<br>route -n show routing table<br>route add -net 0/0 gw IP_Gateway configura default gateway<br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’<br>route del 0/0 gw IP_gateway remove static route<br>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>hostname show hostname of system<br>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>ip link show show link status of all interfaces<br>mii-tool eth0 show link status of ‘eth0’<br>ethtool eth0 show statistics of network card ‘eth0’<br>netstat -tup show all active network connections and their PID<br>netstat -tupl show all network services listening on the system and their PID<br>tcpdump tcp port 80 show all HTTP traffic<br>iwlist scan show wireless networks<br>iwconfig eth1 show configuration of a wireless network card<br>hostname show hostname<br>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>whois <a href="http://www.example.com/">www.example.com</a> lookup on Whois database </p><h1 id="安装Srun-4000系统"><a href="#安装Srun-4000系统" class="headerlink" title="安装Srun 4000系统"></a>安装Srun 4000系统</h1><h2 id="1-安装srun4k"><a href="#1-安装srun4k" class="headerlink" title="1.安装srun4k"></a>1.安装srun4k</h2><p>获取srun4k包 解压到根目录 /</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> srun4_centos7_xxxxx.tgz<span class="token builtin class-name">cd</span> /srun3./install <span class="token operator">&gt;</span> ./install.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-卸载srun4k"><a href="#2-卸载srun4k" class="headerlink" title="2.卸载srun4k"></a>2.卸载srun4k</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /srun3./uninstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-相关命令"><a href="#3-相关命令" class="headerlink" title="3.相关命令"></a>3.相关命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/srun3/bin/srun3d status <span class="token comment"># 服务状态</span>/srun3/bin/srun3d start <span class="token comment"># 服务启动</span>/srun3/bin/srun3d restart <span class="token comment"># 服务重启</span>/srun3/bin/srun3d stop <span class="token comment"># 服务关闭</span>/srun3/bin/rad_auth <span class="token parameter variable">-v</span> <span class="token comment">#查看内核版本号及server id</span>/srun3/bin/server_aaa restart/srun3/bin/server_portal restart/srun3/bin/server_httpd restart/etc/init.d/srun3kauth restart <span class="token comment">#修改Portal页面后执行命令</span>/srun3/bin/server_bas start  <span class="token comment">#单独启动DPDK网关</span>/srun3/www/Srun4k-webcron-install_v1.1.3.bin <span class="token comment">#srun4k开启定时任务8000</span><span class="token function">netstat</span> <span class="token parameter variable">-tupln</span> <span class="token operator">|</span> <span class="token function">grep</span> nginx  <span class="token comment">#查看nginx端口</span>route <span class="token comment">#显示和操作 IP 路由表。</span>routel <span class="token comment">#以好看的输出格式列出路由</span><span class="token comment">#抓包相关</span>tcpdump <span class="token parameter variable">-i</span> any <span class="token parameter variable">-u</span> udp-w /root/xxx.pcap tcpdump <span class="token parameter variable">-i</span> eth0 port <span class="token number">1812</span> or <span class="token number">1813</span> or <span class="token number">3799</span> or <span class="token number">2000</span> -w/na.cap<span class="token function">killall</span> srun_portal_server<span class="token punctuation">;</span>/srun3/bin/srun_portal_server <span class="token parameter variable">-d</span><span class="token function">killall</span> rad_dm<span class="token punctuation">;</span>/srun3/bin/rad_dm <span class="token parameter variable">-d</span><span class="token function">killall</span> radiusd<span class="token punctuation">;</span>/srun3/radius/sbin/radiusd <span class="token parameter variable">-X</span>  <span class="token operator">&gt;</span>/radius.txt <span class="token operator">&amp;</span>ss <span class="token parameter variable">-tnl</span>  <span class="token comment">#查看主机监听的tcp端口信息</span>/srun3/bin/ldap_test <span class="token parameter variable">-s</span> <span class="token parameter variable">-u</span> 用户名   <span class="token comment">#ldap测试用户名</span>修改Portal页面后执行命令 /etc/init.d/srun3kauth restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ss详情</p><p>ss 是 Socket Statistics 的缩写。ss 命令可以用来获取 socket 统计信息，它显示的内容和 netstat 类似。但 ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，而且比 netstat 更快。当服务器的 socket 连接数量变得非常大时，无论是使用 netstat 命令还是直接 cat /proc/net/tcp，执行速度都会很慢。ss 命令利用到了 TCP 协议栈中 tcp_diag。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，因此 ss 命令的性能会好很多。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-h, <span class="token parameter variable">--help</span> 帮助-V, <span class="token parameter variable">--version</span> 显示版本号-t, <span class="token parameter variable">--tcp</span> 显示 TCP 协议的 sockets-u, <span class="token parameter variable">--udp</span> 显示 UDP 协议的 sockets-x, <span class="token parameter variable">--unix</span> 显示 unix domain sockets，与 <span class="token parameter variable">-f</span> 选项相同-n, <span class="token parameter variable">--numeric</span> 不解析服务的名称，如 <span class="token string">"22"</span> 端口不会显示成 <span class="token string">"ssh"</span>-l, <span class="token parameter variable">--listening</span> 只显示处于监听状态的端口-p, <span class="token parameter variable">--processes</span> 显示监听端口的进程<span class="token punctuation">(</span>Ubuntu 上需要 <span class="token function">sudo</span><span class="token punctuation">)</span>-a, <span class="token parameter variable">--all</span> 对 TCP 协议来说，既包含监听的端口，也包含建立的连接-r, <span class="token parameter variable">--resolve</span> 把 IP 解释为域名，把端口号解释为协议名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
